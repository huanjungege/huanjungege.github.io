<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>20-03-09vuex</title>
    <url>/2020/03/09/20-03-09vuex/</url>
    <content><![CDATA[<h2 id="Vuex是什么？"><a href="#Vuex是什么？" class="headerlink" title="Vuex是什么？"></a>Vuex是什么？</h2><p>根据官网解释是一个专门为Vue.js应用程序开发的状态管理模式。（个人理解为数据管理，一个程序在刚开发阶段组件比较少，组件之间的传值解决也很方便，但是当程序越来越大，组件越来越多的时候数据越来越多的时候，组件传值变得复杂难以管理）。Vuex就是将多个组件都会用到的数据进行集中管理，哪个组件需要这些数据就在Vuex的存储库中提取，使数据的调用变得简单直接。</p>
<a id="more"></a>

<h3 id="Vuex的状态管理包含三个部分："><a href="#Vuex的状态管理包含三个部分：" class="headerlink" title="Vuex的状态管理包含三个部分："></a>Vuex的状态管理包含三个部分：</h3><ol>
<li>state，驱动应用的数据源；</li>
<li>view，以声明的方式将state映射到视图；</li>
<li>actions，响应在view上的用户输入导致的状态变化。</li>
</ol>
<img src="/2020/03/09/20-03-09vuex/1.jpg">

<p>这是一个单项数据流。</p>
<p>state中的数据渲染到view视图，用户通过actions交互事件更改state数据，数据再次渲染，形成一个单项数据流。</p>
<h2 id="正常情况下的数据管理"><a href="#正常情况下的数据管理" class="headerlink" title="正常情况下的数据管理"></a>正常情况下的数据管理</h2><p>通过官方文档实现一个计数器</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>&lt;h1&gt;点击数：&#123;&#123; count &#125;&#125;&lt;/h1&gt;<br>&lt;input type="button" value="点击增加" @click="addEvent" /&gt;<br>&lt;/template&gt;<br>export default &#123;<br>  name: "Store",<br>  data() &#123;<br>    return &#123;<br>      count: 0<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    addEvent:function()&#123;<br>        this.count++<br>    &#125;<br></code></pre></td></tr></table></figure>

{% asset_img 2.jpg %}

<p>那么Vuex的方式是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;!-- Vuex方式 --&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>点击数：&#123;&#123; $store.state.num &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"点击增加"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"emitAction"</span> /&gt;</span></span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">"Store"</span>,<br>  <span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-comment">//vuex中的mutation不能直接调用，我们需要调用store.commit方法</span><br>    <span class="hljs-attr">emitAction</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.$store.commit(<span class="hljs-string">'addEvent2'</span>)<br>    &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<img src="/2020/03/09/20-03-09vuex/3.jpg">

<p>当勾选了Vuex后，会自动创建一个store实例，在state中存储数据，mutations中 定义方法</p>
<img src="/2020/03/09/20-03-09vuex/4.jpg">

<p>Vuex中的state：</p>
<p>state可以称作Vuex存储数据的仓库，在组件中调用数据时我们发现在组件中的模板语法是这样的，$state.store.num,较为繁琐，我们可以这样写</p>
<img src="/2020/03/09/20-03-09vuex/6.jpg">

<p>这个时候发现下面也很繁琐所以Vuex提供了<code>mapState</code>辅助函数帮助我们生成计算属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//第一种方式</span><br><span class="hljs-attr">computed</span>:mapSate([<span class="hljs-string">'age'</span>,<span class="hljs-string">'gender'</span>,<span class="hljs-string">'num'</span>]);<br><span class="hljs-comment">//第二种</span><br>computed:mapState(&#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-string">'age'</span>,<br>    <span class="hljs-comment">//或者箭头函数方式</span><br>    <span class="hljs-attr">gender</span>:<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span>state.gender,<br>    <span class="hljs-attr">num</span>:<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.num<br>&#125;)<br><span class="hljs-attr">computed</span>: &#123;<br>    ...mapState([<span class="hljs-string">"username"</span>, <span class="hljs-string">"age"</span>, <span class="hljs-string">"list"</span>]),<br>    ...mapGetters([<span class="hljs-string">'xuAge'</span>])<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-comment">// addAge: function() &#123;</span><br>    <span class="hljs-comment">//   this.$store.commit("addAge");</span><br>    <span class="hljs-comment">// &#125;,</span><br>    ...mapMutations([<span class="hljs-string">'addAge'</span>,<span class="hljs-string">'getList'</span>]),<br>    ...mapActions([<span class="hljs-string">'getJoke'</span>])<br></code></pre></td></tr></table></figure>

<p>Vuex中的Getter：</p>
<p>刚开始想组件中有计算属性，那么为什么要使用getter，组件中的计算属性只能在该组件中使用而：</p>
<p>Getter相当于全局的computed(计算属性)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">getters:&#123;<br><span class="hljs-attr">reverseMSg</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state</span>)</span>&#123;<br><span class="hljs-comment">//返回它的颠倒值</span><br>  <span class="hljs-keyword">return</span> state.msg.split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>VueX中的mutations相当于组件中的methods</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//修改数据/状态的方法--methods</span><br>  <span class="hljs-attr">mutations</span>: &#123;<br>    addAge(state,payload)&#123;<br>      <span class="hljs-comment">// console.log(state)</span><br>      state.age += payload<br>    &#125;,<br>    getList(state,payload)&#123;<br>      state.list = payload<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure>

<p>VueX中的actions则是异步的修改数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">actions: &#123;<br>    getJoke(context)&#123;<br>      <span class="hljs-keyword">let</span> httpUrl = <span class="hljs-string">'https://api.apiopen.top/getJoke?page=1&amp;count10&amp;type=text'</span><br>      fetch(httpUrl).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> res.json()<br>      &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(res)<br>        context.commit(<span class="hljs-string">'getList'</span>,res.result)<br>      &#125;)<br>    &#125;<br>  &#125;<br>      <span class="hljs-comment">//将异步请求到的数据渲染到列表中</span><br>      &lt;ul&gt;<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, i) in $store.state.list"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"i"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    &lt;<span class="hljs-regexp">/ul&gt;</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs入门介绍</title>
    <url>/2019/10/22/2019-10-22-node-01/</url>
    <content><![CDATA[<h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><h2 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么?"></a><code>Node.js</code>是什么?</h2><p>在node官网的介绍中看到</p>
<ol>
<li><strong>Node.js® is a JavaScript runtime built on <a href="https://v8.dev/" target="_blank" rel="noopener">Chrome’s V8 JavaScript engine</a>.</strong></li>
</ol>
<ul>
<li>Nodejs不是一门语言，不是库和框架，是一个<code>Javascript</code>运行环境</li>
<li>以前只有浏览器可以解析执行Javascript代码，由于Node的出现现在js可以脱离浏览器运行</li>
<li>Node中没有BOM和DOM，在Ecmascript的基础上增加了一些服务器级别的操作API</li>
<li>例如：文件读写，网络服务的构建，网络通信，http服务器</li>
</ul>
<a id="more"></a>

<ol start="2">
<li><strong>Node.js uses an <code>event-driven</code>, <code>non-blocking I/O moedl</code>  that makes it <code>lightweight and efficent*</code></strong></li>
</ol>
<ul>
<li>event-driven:事件驱动</li>
<li>non-blocking I/O model： 非阻塞I/O类型（异步）</li>
<li>lightweight and efficent: 轻量和高效的</li>
</ul>
<p>这句话展现了Node.js的特性，在以后的学习中我们会慢慢理解</p>
<ol start="3">
<li><strong>Node.js package ecosytem ,<code>npm</code>,is the largest ecosystem of open source libraries in the world</strong></li>
</ol>
<ul>
<li>npm是世界上最大的开源库生态系统</li>
<li>绝大多数JavaScript相关的包都存放在npm上，这样可以让开发人员方便下载</li>
<li><code>npm install jquery</code></li>
</ul>
<h2 id="学习Node-js可以了解到"><a href="#学习Node-js可以了解到" class="headerlink" title="学习Node.js可以了解到"></a>学习Node.js可以了解到</h2><ul>
<li>B/S编程模型<ul>
<li>Browser-Sever</li>
<li>back-end</li>
</ul>
</li>
<li>模块化编程<ul>
<li>以前的JavaScript只能通过script标签加载，现在可以使用@import(‘文件路径’)</li>
</ul>
</li>
<li>Node常用API</li>
<li>异步编程<ul>
<li>回调函数</li>
<li>Promise</li>
<li>ES6(只是一种新语法)</li>
</ul>
</li>
</ul>
<h2 id="模块的导入与导出"><a href="#模块的导入与导出" class="headerlink" title="模块的导入与导出"></a>模块的导入与导出</h2><p>index1想要使用index2中的内容：index1中需要使用require()导入index2，index2中将需要被引用的内容使用module.exports()导出。</p>
<h2 id="Node中的包"><a href="#Node中的包" class="headerlink" title="Node中的包"></a>Node中的包</h2><p>包其实是一个存档文件。完全复合CommonJS规范的包目录最基本应该包含如下这些文件。</p>
<ol>
<li>package.json：包描述文件</li>
<li>bin：用于存放可执行二进制文件的目录</li>
<li>lib：用于存放JavaScript代码的目录</li>
<li>doc：用于存放文档的目录</li>
<li>test：用于存放单元测试用例的代码</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Node学习入门2</title>
    <url>/2019/10/22/2019-10-22-node-02/</url>
    <content><![CDATA[<h2 id="Node安装检测"><a href="#Node安装检测" class="headerlink" title="Node安装检测"></a>Node安装检测</h2><p>cmd中输入<code>node --version</code>/<code>node -v</code>检测版本号</p>
<img src="/2019/10/22/2019-10-22-node-02/01.png">

<a id="more"></a>

<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><ol>
<li><p>创建编写Javascript脚本</p>
<img src="/2019/10/22/2019-10-22-node-02/02.png">
</li>
<li><p>打开终端，定位到脚本文件所属目录（切换盘符输入d:,然后盘符内相关目录<code>cd 03Nodejs学习记录及代码练习\01</code>）</p>
</li>
<li><p>输入node &lt;”00-helloworld.js”&gt;</p>
<img src="/2019/10/22/2019-10-22-node-02/03.png">

</li>
</ol>
<p><strong>切记文件名字不要起node.js，并且最好不要起中文</strong></p>
<h2 id="Node-js中有没有BOM、DOM"><a href="#Node-js中有没有BOM、DOM" class="headerlink" title="Node.js中有没有BOM、DOM"></a>Node.js中有没有BOM、DOM</h2><ol>
<li><p>新建js文件</p>
<img src="/2019/10/22/2019-10-22-node-02/05.png">
</li>
<li><p>运行结果</p>
<img src="/2019/10/22/2019-10-22-node-02/04.png">

<p>可以看到报了引用错误，window is not defined，可见Node.js中没有BOM和DOM</p>
</li>
</ol>
<h2 id="Node的文件操作"><a href="#Node的文件操作" class="headerlink" title="Node的文件操作"></a>Node的文件操作</h2><p>Node具有文件操作的能力，<code>file-system</code>文件系统，我们简写为<code>fs</code></p>
<p><strong>在Node中进行文件操作必须引入文件系统</strong></p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用require()方法引用fs核心模块</span><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)<br><span class="hljs-comment">//读取文件</span><br><span class="hljs-comment">//第一个参数：文件地址</span><br><span class="hljs-comment">//第二个参数：回调函数</span><br><span class="hljs-comment">//回调函数中有两个参数(data 和 error)</span><br><span class="hljs-comment">//成功:error为null   data为数据</span><br><span class="hljs-comment">//失败:error为错误对象  data写入失败</span><br>fs.readFile(<span class="hljs-string">'./data/hello.txt'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, data</span>)</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(data);<span class="hljs-comment">//自动输入数据</span><br>    <span class="hljs-built_in">console</span>.log(data.toString());<span class="hljs-comment">//转换为字符串输出</span><br>&#125;)<br></code></pre></td></tr></table></figure>

{% asset_img 06.png %}

<h3 id="异步写入文件"><a href="#异步写入文件" class="headerlink" title="异步写入文件"></a>异步写入文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fs=<span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<br><span class="hljs-comment">//三个参数 </span><br><span class="hljs-comment">// 1.文件写入路径文件名</span><br><span class="hljs-comment">// 2.写入内容</span><br><span class="hljs-comment">// 3.回调函数（参数 error）</span><br><br><span class="hljs-comment">//写入成功  error为null</span><br><span class="hljs-comment">//写入失败  error为错误对象</span><br>fs.writeFile(<span class="hljs-string">'./data/你好Node.md'</span>, <span class="hljs-string">"你好Nodejs！"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'写入成功'</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="当文件处理出现错误"><a href="#当文件处理出现错误" class="headerlink" title="当文件处理出现错误"></a>当文件处理出现错误</h3><p>我们在上述回调函数中添加代码<code>console.log(error)</code>,那么在读取成功时返回null，在读取失败时返回错误代码</p>
<p>所以我们可以加入对error的判断代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(error)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"读取出错了"</span>);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(data.toString());<br>  &#125;<br></code></pre></td></tr></table></figure>

<h2 id="简单的HTTP服务"><a href="#简单的HTTP服务" class="headerlink" title="简单的HTTP服务"></a>简单的HTTP服务</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//加载http模块</span><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>)<br><span class="hljs-comment">//创建http实例</span><br><span class="hljs-keyword">var</span> server = createServer()<br><span class="hljs-comment">//注册request请求事件，当客户端请求过来，就会自动触发服务器的request事件，然后执行回调函数</span><br>server.on(<span class="hljs-string">'request'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'收到客户端请求了'</span>)<br>&#125;)<br><span class="hljs-comment">//绑定端口号，启动服务器</span><br>server.listen(<span class="hljs-number">3000</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'服务器启动成功了，通过127.0.0.1:3000进行访问'</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>这样服务端启动成功并且接收到请求，浏览器却接收不到响应，一直在等待。。</p>
<h3 id="如何进行响应"><a href="#如何进行响应" class="headerlink" title="如何进行响应"></a>如何进行响应</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//加载http模块</span><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>)<br><span class="hljs-comment">//创建http实例</span><br><span class="hljs-keyword">var</span> server = createServer()<br><span class="hljs-comment">//注册request请求事件，当客户端请求过来，就会自动触发服务器的request事件，然后执行回调函数</span><br><span class="hljs-comment">// reuqest请求事件处理函数，共有两个参数</span><br><span class="hljs-comment">//    Request:请求对象   用来获取请求对象信息，例如请求路径</span><br><span class="hljs-comment">//    Response: 响应对象  用来给客户端发送响应信息</span><br>server.on(<span class="hljs-string">'request'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request,response</span>)</span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'收到客户端请求了,请求地址为'</span> + request.url)<br>    <span class="hljs-comment">//用户请求路径不同响应不同的信息</span><br>    <span class="hljs-keyword">if</span>(request.url == <span class="hljs-string">'/index'</span>)&#123;<br>        response.write(<span class="hljs-string">'hello'</span>)<br>        response.end();<span class="hljs-comment">//告诉客户端：我的话说完了，可以呈递给用户了</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(request.url == <span class="hljs-string">'/tags'</span>)&#123;<br>        response.write(<span class="hljs-string">'hi'</span>)<br>        response.end();<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//绑定端口号，启动服务器</span><br>server.listen(<span class="hljs-number">3000</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'服务器启动成功了，通过127.0.0.1:3000进行访问'</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="Node中的核心模块"><a href="#Node中的核心模块" class="headerlink" title="Node中的核心模块"></a>Node中的核心模块</h2><p>Node为Javascript提供了很多服务器级别的API,这些API绝大多数都包装到了一个具名的核心模块中了</p>
<p>例如：</p>
<ol>
<li>文件操作的<code>fs</code>模块</li>
<li>http构建服务的<code>http</code>模块</li>
<li><code>path</code>路径操作模块</li>
<li><code>os</code>操作系统信息模块</li>
</ol>
<p>所以以后当知道要引用一个核心模块，就千万别忘了’引用‘</p>
<h3 id="require的两个作用"><a href="#require的两个作用" class="headerlink" title="require的两个作用"></a>require的两个作用</h3><p>require方法的第一个作用就是加载模块，具名的核心模块或者自己编写的模块</p>
<p>例：</p>
<img src="/2019/10/22/2019-10-22-node-02/06.png">

<p><strong>note:相对路径必须加./    如不加会被当做核心模块</strong></p>
<p>在Node中没有全局作用域，只有模块作用域，模块完全封闭，外部与内部无法互相访问，那么模块之间如何进行通信，下面介绍require的第二个作用</p>
<p>拿到被加载文件模块导出的接口对象</p>
<p>每个文件模块都提供了一个对象<code>exports</code>（默认是一个空对象）</p>
<img src="/2019/10/22/2019-10-22-node-02/08.png">

<p>可以看到经过exports挂载的foo可以被a.js访问到，并且b中本身自带的foo并不受影响</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Js中的Array类型总结</title>
    <url>/2019/10/28/2019-10-28-Array/</url>
    <content><![CDATA[<h1 id="Js中的Array类型"><a href="#Js中的Array类型" class="headerlink" title="Js中的Array类型"></a>Js中的Array类型</h1><p>序：除了Object类型之外，Array类型恐怕是ECAMAScript中最常用的类型了，特点：有序列表，并且数组的每一项都可以保存任意数据类型的数据，数组的大小可以动态的调整。</p>
<h2 id="创建数组的方式"><a href="#创建数组的方式" class="headerlink" title="创建数组的方式"></a>创建数组的方式</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>使用Array构造函数:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br></code></pre></td></tr></table></figure>

<ol>
<li>如果预先知道数组保存项的数量，可以给数组传递数量</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">20</span>);  <span class="hljs-comment">//创建数组项数为20的数组</span><br></code></pre></td></tr></table></figure>

<p>2.直接 向数组传递要传入的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">"1"</span>,<span class="hljs-string">"2"</span>);<br></code></pre></td></tr></table></figure>

<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><a id="more"></a>

<p>使用数组字面量法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> colors = [<span class="hljs-string">"green"</span>,<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>];<br><span class="hljs-keyword">var</span> colors = []; <span class="hljs-comment">//空数组</span><br></code></pre></td></tr></table></figure>

<p><strong>数组的<code>length</code>很有特点，它不是只读的，我们可以直接控制数组的<code>length</code>值，控制数组的末尾移除项或者添加新项</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> colors = [<span class="hljs-string">"green"</span>,<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>];<br>colors.length = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">console</span>.log(colors[<span class="hljs-number">3</span>]); <span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure>

<p>由于将colors的length值增加了1，所以当我们访问到3号索引，数组动态的添加了undefined值</p>
<h2 id="数组中的方法"><a href="#数组中的方法" class="headerlink" title="数组中的方法"></a>数组中的方法</h2><h3 id="find"><a href="#find" class="headerlink" title="find()"></a><code>find()</code></h3><p>用于找出第一个符合条件的数组成员，它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-4</span>,<span class="hljs-number">8</span>].find(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//-4</span><br></code></pre></td></tr></table></figure>

<h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a><code>includes()</code></h3><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">2</span>)     <span class="hljs-comment">// true</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">4</span>)     <span class="hljs-comment">// false</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">NaN</span>].includes(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.isArray([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">Array</span>.isarray(&#123;<span class="hljs-attr">foo</span>:<span class="hljs-number">123</span>&#125;)<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>转换方法一共有三种<code>tostring()</code>、<code>tolocaleString()</code>、<code>valueOf()</code>作用返回数组中的每个值的字符串形式拼接而成的一个以逗号分隔的字符串，而<code>join()</code>方法则可以使用不同的分隔符来构建字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> colors = [<span class="hljs-string">"green"</span>,<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>];<br>alert(colors.join(<span class="hljs-string">"||"</span>)); <span class="hljs-comment">//green||red||blue</span><br>alert(colors.join(<span class="hljs-string">":"</span>));<span class="hljs-comment">//geren:red:blue</span><br></code></pre></td></tr></table></figure>

<p><em>如果数组中的某一项为null或undefined，那么以上方法返回的结果中以空字符串表示</em></p>
<h3 id="栈方法（后进先出）"><a href="#栈方法（后进先出）" class="headerlink" title="栈方法（后进先出）"></a>栈方法（后进先出）</h3><p>ECMAScript中数组也提供了让数组的行为类似于其它数据结构的方法</p>
<p><code>push()</code>方法：接收任意数量的值，将他们逐个添加到数组末尾</p>
<p><code>pop()</code>方法:删除数组末尾最后一项，减少length值</p>
<h3 id="队列方法（先进先出）"><a href="#队列方法（先进先出）" class="headerlink" title="队列方法（先进先出）"></a>队列方法（先进先出）</h3><p><code>unshift()</code>方法：从数组前端添加任意项</p>
<p><code>shift()</code>方法：从数组前端减少任意项</p>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><h4 id="reverse-方法：会反转数组的顺序"><a href="#reverse-方法：会反转数组的顺序" class="headerlink" title="reverse()方法：会反转数组的顺序"></a><code>reverse()</code>方法：会反转数组的顺序</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>alert(arr.reverse()); <span class="hljs-comment">//5,4,3,2,1</span><br></code></pre></td></tr></table></figure>

<h4 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort()方法"></a><code>sort()</code>方法</h4><p><code>sort()</code>以字母顺序排列数组，sort会调用每个数组的<code>toString()</code>方法，比较得到的字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>];<br>arr.sort()<br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">//0,1,10,15,5</span><br></code></pre></td></tr></table></figure>

<p>这种情况是数值5虽然小于10，但是字符串进行比较时却位于10的前面。这时可以使用一个比较函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">value1,value2</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(value1 &gt; value2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(varlue1 &lt; value2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br>比较两个参数，如果第一个值在第二个值之后则返回<span class="hljs-number">-1</span>，如果在第二个值之前返回<span class="hljs-number">1</span>；<br>简化<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare2</span>(<span class="hljs-params">a,b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a-b;<br>&#125;<br>arr.sort(compare2)<br></code></pre></td></tr></table></figure>

<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat()`方法"></a>concat()`方法</h4><p><code>concat()</code>可以基于当前数组中的所有项来创建一个新数组。具体来说这个方法会创建当前数组的副本，然后将接收到的参数添加到数组末尾，最后返回到新创建的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> arr2 = arr.concat(<span class="hljs-number">5</span>,[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]);<br>alert(arr2); <span class="hljs-comment">//1,2,3,4,5,6,7;</span><br></code></pre></td></tr></table></figure>

<h4 id="slice-方法"><a href="#slice-方法" class="headerlink" title="slice()方法"></a><code>slice()</code>方法</h4><p>它能够基于当前数组中的一项或者多项创建新的数组（对数组进行截取），可以接收一个或两个参数</p>
<h5 id="一个参数时："><a href="#一个参数时：" class="headerlink" title="一个参数时："></a>一个参数时：</h5><p>截取参数位到末尾的所有项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> colors = [<span class="hljs-string">"green"</span>,<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"orange"</span>];<br><span class="hljs-keyword">var</span> result = colors.slice(<span class="hljs-number">2</span>);<br>alert(result) <span class="hljs-comment">//blue,orange</span><br></code></pre></td></tr></table></figure>

<h5 id="两个参数时："><a href="#两个参数时：" class="headerlink" title="两个参数时："></a>两个参数时：</h5><p>截取第一个参数位到第二个参数位之前一位的所有项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> colors = [<span class="hljs-string">"green"</span>,<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"orange"</span>];<br><span class="hljs-keyword">var</span> result = colors.slice(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br>alert(result) <span class="hljs-comment">//green red</span><br></code></pre></td></tr></table></figure>

<h4 id="splice-方法"><a href="#splice-方法" class="headerlink" title="splice()方法"></a><code>splice()</code>方法</h4><p><code>splice()</code>方法恐怕要算最强大的数组方法了，它有很多中用法</p>
<ul>
<li><p>删除：可以删除任意数组的项，输入两个参数，要删除的第一项位置和删除的个数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> colors = [<span class="hljs-string">"red"</span>,<span class="hljs-string">"green"</span>,<span class="hljs-string">"blue"</span>];<br>colors.splice(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">//green,blue   第一个开始删除一个</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>替换：在指定位置插入任意数量的项，且同时删除任意数量的项，三个参数：起始位置、要删除的个数、要插入的项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> colors = [<span class="hljs-string">"red"</span>,<span class="hljs-string">"green"</span>,<span class="hljs-string">"blue"</span>];<br>colors.splice(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"red"</span>,<span class="hljs-string">"purple"</span>)<br>alert(colors); <span class="hljs-comment">//red,red,purple,green,blue</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>插入：在指定位置插入任意数量的项，三个参数：起始位置、0、插入的项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//插入可以理解为在替换过程中不删除数组的元素而直接添加元素，那么第二个参数便为0；</span><br><span class="hljs-keyword">var</span> colors = [<span class="hljs-string">"red"</span>,<span class="hljs-string">"green"</span>,<span class="hljs-string">"blue"</span>];<br>colors.splice(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-string">"orange"</span>);<br>alert(colors); <span class="hljs-comment">// red,green,orange,blue</span><br></code></pre></td></tr></table></figure>

<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p><code>indexOf()</code>和<code>lastIndexOf()</code>方法。一个从数组开头开始查找，一个从数组末尾开始查找</p>
<h4 id="一个参数时-参数为要查找的项"><a href="#一个参数时-参数为要查找的项" class="headerlink" title="一个参数时:参数为要查找的项"></a>一个参数时:参数为要查找的项</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">"banana"</span>,<span class="hljs-string">"apple"</span>,<span class="hljs-string">"mango"</span>,<span class="hljs-string">"orange"</span>,<span class="hljs-string">"apple"</span>];<br>fruits.indexOf(apple);<span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure>

<h4 id="两个参数时：参数为要查找的项，和起始位置，如果找不到返回-1"><a href="#两个参数时：参数为要查找的项，和起始位置，如果找不到返回-1" class="headerlink" title="两个参数时：参数为要查找的项，和起始位置，如果找不到返回-1"></a>两个参数时：参数为要查找的项，和起始位置，如果找不到返回-1</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">"banana"</span>,<span class="hljs-string">"apple"</span>,<span class="hljs-string">"mango"</span>,<span class="hljs-string">"orange"</span>,<span class="hljs-string">"apple"</span>];<br>fruits.indexOf(<span class="hljs-string">"apple"</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">//4</span><br></code></pre></td></tr></table></figure>

<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><h4 id="map-方法：对数组中的每一项进行给定函数，返回每次函数调用结果组成数组"><a href="#map-方法：对数组中的每一项进行给定函数，返回每次函数调用结果组成数组" class="headerlink" title="map()方法：对数组中的每一项进行给定函数，返回每次函数调用结果组成数组"></a><code>map()</code>方法：对数组中的每一项进行给定函数，返回每次函数调用结果组成数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> x*x;<br>&#125;<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-keyword">var</span> result = arr.map(pow);<br>alert(result); <span class="hljs-comment">//1,4,9,16,25,36</span><br><span class="hljs-comment">//将数组转为字符串</span><br><span class="hljs-keyword">var</span> result2 = arr.map(toString)<br>alert(result2);<span class="hljs-comment">//"1","2","3","4","5","6"</span><br></code></pre></td></tr></table></figure>

<h4 id="every-和some-方法"><a href="#every-和some-方法" class="headerlink" title="every()和some()方法"></a><code>every()</code>和<code>some()</code>方法</h4><p>两个方法都是对数组中的每一项运行给定函数，但<code>every()</code>方法在所有项返回true时才会返回true，相反some只有一项返回true就返回true；</p>
<h4 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter()方法"></a><code>filter()</code>方法</h4><p>把传入的函数依次作用于每个元素，根据返回值是true还是false决定保留还是丢弃该元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">var</span> results = numbers.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">items,index,array</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (items &gt; <span class="hljs-number">2</span>);<br> &#125;)<br>alert(results)<span class="hljs-comment">//3,5,6,3</span><br><br><span class="hljs-comment">//删除掉偶数</span><br><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> results = numbers.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">items,index,array</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (items % <span class="hljs-number">2</span>!== <span class="hljs-number">0</span>);<br> &#125;)<br>alert(results)<span class="hljs-comment">//1,3,5,3</span><br></code></pre></td></tr></table></figure>


</li>
</ul>
<p>  <code>filter()</code>方法接收的回调函数可以有多个参数，通常我们使用第一个参数表示Array的某个元素，另两个参数表示元素的位置和数组本身</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//去掉重复的元素</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">var</span> result = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element,index,self</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> arr.indexOf(element) === index;<br> &#125;)<br>alert(result)<span class="hljs-comment">//1,2,3,4,5</span><br><span class="hljs-comment">//indexOf总返回第一个元素的位置，后续重复元素位置与indexOf返回不相等</span><br></code></pre></td></tr></table></figure>


<h4 id="forEach-方法：本质与for循环迭代数组一样"><a href="#forEach-方法：本质与for循环迭代数组一样" class="headerlink" title="forEach()方法：本质与for循环迭代数组一样"></a><code>forEach()</code>方法：本质与for循环迭代数组一样</h4><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><p>  <code>reduce()</code>方法和<code>reduceRight()</code>方法，这两个方法都会迭代数组的所有项，构建一个最终返回的值，四个参数：前一个值、当前值、项的索引和数组对象</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用reduce求数组所有值的和</span><br><span class="hljs-keyword">var</span> value = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">var</span> sum = value.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev,cur,index,array</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> prev + cur;<br>&#125;)<br>alert(sum); <span class="hljs-comment">//15</span><br></code></pre></td></tr></table></figure>


<p>  <strong>使用reduce还是reduceRight主要取决于要从哪头开始遍历数组，除此之外它们完全相同</strong></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中面向对象程序设计</title>
    <url>/2019/10/29/2019-10-29-js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象与继承"><a href="#面向对象与继承" class="headerlink" title="面向对象与继承"></a>面向对象与继承</h1><p>原型模式</p>
<p>我们所创建的每个函数都有一个<code>prototype</code>(原型)属性，这个属性是一个指针，指向一个对象，意思就是所有对象都可以共享它所包含的属性和方法，并且所有对象都会从它的原型上继承一个<code>constructor</code>属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;&#125;;<br>o.constructor === <span class="hljs-built_in">Object</span>; <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

{% asset_img 03.jpg %}

<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br>Person.prototype.name = <span class="hljs-string">"mike"</span>;<br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-keyword">this</span>.name);<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person();<br>preson1.sayName(); <span class="hljs-comment">//mike</span><br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person();<br>person2.sayName(); <span class="hljs-comment">//mike</span><br>alert(person1.sayName == person2.sayName) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h2 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h2><img src="/2019/10/29/2019-10-29-js面向对象/01.jpg">

<img src="/2019/10/29/2019-10-29-js面向对象/02.jpg">

<p><strong>事实上现在所展示的原型链还少一环，所有引用类型默认都继承了<code>Object</code>，而这个继承也是通过原型链实现的。因此默认原型内部还有一个指针，指向<code>Object.prototype</code>下面这个图为我们展示了完整的原型链</strong></p>
<img src="/2019/10/29/2019-10-29-js面向对象/04.png">

<p>虽然通过对象实例可以访问保存在原型中的值，但是却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性与实例原型中的属性重名，那么会在实例中创建该属性以屏蔽原型中的那个属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>&#125;<br>Person.prototype.name = <span class="hljs-string">"mike"</span>;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person();<br>person1.name = <span class="hljs-string">"Greg"</span>;<br>alert(person1.name)<span class="hljs-comment">//Greg已经修改</span><br>alert(person2.name)<span class="hljs-comment">//mike 仍然访问原型数据</span><br><span class="hljs-keyword">delete</span> person1.name<br>alert(person1.name)<span class="hljs-comment">//mike</span><br></code></pre></td></tr></table></figure>

<h2 id="实现b继承a的方法"><a href="#实现b继承a的方法" class="headerlink" title="实现b继承a的方法"></a>实现b继承a的方法</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>   <br>&#125;<br><span class="hljs-comment">//原型方法</span><br>A.prototype.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-string">"Hello"</span>);<br> &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-comment">//将父类的实例作为子类的原型</span><br>B.prototype = <span class="hljs-keyword">new</span> A();<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> B();<br>alert(b.sayHi()); <span class="hljs-comment">//Hello</span><br></code></pre></td></tr></table></figure>

<p>缺点：不能给父类构造函数传递参数，父子构造函数的原型对象有共享数据问题</p>
<h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.friends = [<span class="hljs-string">'jely'</span>,<span class="hljs-string">'bob'</span>]<br>    <span class="hljs-keyword">this</span>.sayName() = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-keyword">this</span>.name);<br>  &#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-comment">//使用call借用A的构造函数</span><br>    A.call(<span class="hljs-keyword">this</span>,name);<br>&#125;<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> B(<span class="hljs-string">"Tom"</span>);<br>b.sayName();<span class="hljs-comment">//Tom</span><br>b.friends;<span class="hljs-comment">// jely,bob</span><br></code></pre></td></tr></table></figure>

<p>组合继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params">name</span>) </span>&#123;<br>           <span class="hljs-keyword">this</span>.name = name;<br>           <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">"red"</span>, <span class="hljs-string">"blue"</span>, <span class="hljs-string">"green"</span>];<br><br>       &#125;<br>       A.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           alert(<span class="hljs-keyword">this</span>.name);<br>       &#125;<br>       <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params">name,age</span>) </span>&#123;<br>           <span class="hljs-comment">//继承属性</span><br>           A.call(<span class="hljs-keyword">this</span>,name);<br>           <span class="hljs-keyword">this</span>.age = age;<br>       &#125;<br>       <span class="hljs-comment">//继承方法</span><br>       B.prototype = <span class="hljs-keyword">new</span> A();<br>       <span class="hljs-comment">//修复构造函数指向</span><br>       B.prototype.construnctor = B;<br>       <span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> B(<span class="hljs-string">"Greg"</span>,<span class="hljs-number">27</span>);<br></code></pre></td></tr></table></figure>

<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> A = &#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">"Nicholas"</span>,<br>            <span class="hljs-attr">friends</span>: [<span class="hljs-string">"Shelby"</span>, <span class="hljs-string">"Court"</span>, <span class="hljs-string">"Van"</span>]<br>        &#125;;<br><br>        <span class="hljs-keyword">var</span> B = <span class="hljs-built_in">Object</span>.create(A);<br>        B.name = <span class="hljs-string">"Greg"</span>;<br>        B.friends.push(<span class="hljs-string">"Rob"</span>);<br>        <span class="hljs-keyword">var</span> C = <span class="hljs-built_in">Object</span>.create(person);<br>        C.name = <span class="hljs-string">"Linda"</span>;<br>        C.friends.push(<span class="hljs-string">"Barbie"</span>);<br><br>        alert(A.friends);      <span class="hljs-comment">//"Shelby,Court,Van,Rob,Barbie"</span><br></code></pre></td></tr></table></figure>

<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，后再像真地是它做了所有工作一样返回对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//封装函数</span><br>        <span class="hljs-comment">//original---&gt;原始的</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">original</span>) </span>&#123;<br>            <span class="hljs-keyword">var</span> clone = object(original); <span class="hljs-comment">//通过调用函数创建一个新对象</span><br>            clone.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//以某种方式增强这个对象</span><br>                alert(<span class="hljs-string">"hi"</span>)<br>            &#125;;<br>            <span class="hljs-keyword">return</span> clone;<span class="hljs-comment">//返回这个对象</span><br>        &#125;<br><br>        <span class="hljs-keyword">var</span> A =&#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">"mike"</span>,<br>            <span class="hljs-attr">friends</span>:[<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>]<br>        &#125;;<br>        <span class="hljs-keyword">var</span> b = create(A);<br>        b.sayHi(); <span class="hljs-comment">//hi</span><br></code></pre></td></tr></table></figure>

<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inherit</span>(<span class="hljs-params">b,a</span>)</span>&#123;<br>   <span class="hljs-keyword">var</span> prototype = object(a.prototype)<span class="hljs-comment">//创建对象</span><br>    prototype.constructor = b;<br>    b.prototype = prototype;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"green"</span>];<br>&#125;<br>A.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-keyword">this</span>.name);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>    A.call(<span class="hljs-keyword">this</span>.name);<br>&#125;<br>inherit(B,A);<br></code></pre></td></tr></table></figure>

<p>原型链的构建是通过将一个类型的实例赋值给另一个构造函 数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借 用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的 属性，同时还能保证只使用构造函数模式来定义类型。使用多的继承模式是组合继承，这种模式使用 原型链继承共享的属性和方法，而通过借用构造函数继承实例属性</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title>Js函数表达式</title>
    <url>/2019/10/31/2019-10-31-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<img src="/2019/10/31/2019-10-31-函数表达式/48.jpg">

<a id="more"></a>

<h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数是在一个函数通过名字调用自身的情况下构成的</p>
<p>一个经典的递归阶乘函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(num &lt;= <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> num * f(num<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>arguments.callee</code>是一个指向正在执行函数的指针，因此它可以实现对函数的递归调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(num &lt;= <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> num * <span class="hljs-built_in">arguments</span>.callee(num<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>通过使用<code>arguments.calee</code>代替函数名，可以确保无论怎样调用函数都不会出问题，因此，在编写递归函数时，使用<code>agruments.callee</code>总比使用函数名更保险</strong></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="执行环境与作用域"><a href="#执行环境与作用域" class="headerlink" title="执行环境与作用域"></a>执行环境与作用域</h3><p>想要理解闭包就要理解执行环境与作用域:</p>
<p>每个函数都有自己的执行环境，每个执行环境都有一个与之关联的变量对象，当代码在一个环境中执行的时候，会创建变量对象的一个作用域链，如果这个环境是函数的话，则将其活动对象作为变量对象，活动对象最开始只包含一个变量，即arguments对象。</p>
<p>变量的作用域：全局变量和局部变量，js语言中，函数内部可以直接读取全局变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n=<span class="hljs-number">100</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;<br>alert(n);<br>&#125;<br>f1()<span class="hljs-comment">//100</span><br></code></pre></td></tr></table></figure>

<p>另一方面，在函数外部无法读取函数内的局部变量（注意这里内部声明变量要使用var，否则实际上声明 了一个全局变量）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>&#125;<br>alert(n); <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure>

<h3 id="那么什么是闭包呢？"><a href="#那么什么是闭包呢？" class="headerlink" title="那么什么是闭包呢？"></a>那么什么是闭包呢？</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数</p>
<p><strong>理解：闭包就是能够读取其它函数内部变量的函数，他是函数内部与外部连接起来的一座桥梁</strong></p>
<p>作用：</p>
<ol>
<li>从外部读取局部变量</li>
<li>让变量的始终保存在内存中</li>
</ol>
<p>那么如何从外部读取局部变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//那就是在函数内部在定义一个函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> n = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">//局部变量n对外部不可见，对f2是可见的</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>)</span>&#123;<br>        alert(n); <span class="hljs-comment">//100</span><br>    &#125;<br>    <span class="hljs-comment">//将f2作为返回值</span><br>    <span class="hljs-keyword">return</span> f2;<span class="hljs-comment">//</span><br>&#125;<br><span class="hljs-keyword">var</span> result= f1();<br>result();<span class="hljs-comment">//100</span><br></code></pre></td></tr></table></figure>

<p>上述代码中<code>f2</code>函数，就是闭包。</p>
<p>2.将变量的值保存在内存中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　<span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>;<br>    <span class="hljs-comment">//nAdd没有使用var声明，它是一个全局变量，值为一个匿名函数</span><br>　　　　nAdd=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;n+=<span class="hljs-number">1</span>&#125;<br>　　　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　　　alert(n);<br>　　　　&#125;<br>　　　　<span class="hljs-keyword">return</span> f2;<br>　　&#125;<br>　　<span class="hljs-keyword">var</span> result=f1();<br>　　result(); <span class="hljs-comment">// 999</span><br>　　nAdd();<br>　　result(); <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure>

<p>在这段代码中，result实际上就是闭包<code>f2</code>函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在<code>f1</code>调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于<code>f1</code>是<code>f2</code>的父函数，而<code>f2</code>被赋给了一个全局变量，这导致<code>f2</code>始终在内存中，而<code>f2</code>的存在依赖于<code>f1</code>，因此<code>f1</code>也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是”<code>nAdd=function(){n+=1}</code>“这一行，首先在<code>nAdd</code>前面没有使用var关键字，因此<code>nAdd</code>是一个全局变量，而不是局部变量。其次，<code>nAdd</code>的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以<code>nAdd</code>相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h3 id="关于this对象"><a href="#关于this对象" class="headerlink" title="关于this对象"></a>关于<code>this</code>对象</h3><p>我们需要理解两个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"The Window"</span>;<br><br>　　<span class="hljs-keyword">var</span> object = &#123;<br>　　　　<span class="hljs-attr">name</span> : <span class="hljs-string">"My Object"</span>,<br><br>　　　　<span class="hljs-attr">getNameFunc</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　　　<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　　　　　<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>　　　　　　&#125;;<br><br>　　　　&#125;<br><br>　　&#125;;<br><br>　　alert(object.getNameFunc()());<span class="hljs-comment">//The window</span><br></code></pre></td></tr></table></figure>

<p>在全局函数中，this等于window,而匿名函数的执行环境具有全局性，因此this队形通常指向window</p>
<p>例2</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"The Window"</span>;<br><br>　　<span class="hljs-keyword">var</span> object = &#123;<br>　　　　<span class="hljs-attr">name</span> : <span class="hljs-string">"My Object"</span>,<br><br>　　　　<span class="hljs-attr">getNameFunc</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　　　<span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;<br>　　　　　　<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　　　　　<span class="hljs-keyword">return</span> that.name;<br>　　　　　　&#125;;<br><br>　　　　&#125;<br><br>　　&#125;;<br><br>　　alert(object.getNameFunc()());<br></code></pre></td></tr></table></figure>

<p>在定义匿名函数之前就将this对象赋值给了that，而在定义了闭包之后，闭包可以访问这个变量，此时的that正是引用着object的this。</p>
<h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>在作用域链这种配置机制下引出的指的注意的副作用，即闭包只能取得包含函数中任何的变量的最后一个值</p>
<p>所以当返回函数引入了循环变量时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> arr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++) &#123;<br>        arr.push(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> i * i;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">var</span> results = count();<br><span class="hljs-keyword">var</span> f1 = results[<span class="hljs-number">0</span>];<span class="hljs-comment">//16</span><br><span class="hljs-keyword">var</span> f2 = results[<span class="hljs-number">1</span>];<span class="hljs-comment">//16</span><br><span class="hljs-keyword">var</span> f3 = results[<span class="hljs-number">2</span>];<span class="hljs-comment">//16</span><br></code></pre></td></tr></table></figure>

<p>全部都是<code>16</code>！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了<code>4</code>，因此最终结果为<code>16</code>。</p>
<p>解决：方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> arr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++) &#123;<br>        arr.push((<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> n * n;<br>            &#125;<br>        &#125;)(i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">var</span> results = count();<br><span class="hljs-keyword">var</span> f1 = results[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">var</span> f2 = results[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">var</span> f3 = results[<span class="hljs-number">2</span>];<br><br>f1(); <span class="hljs-comment">// 1</span><br>f2(); <span class="hljs-comment">// 4</span><br>f3(); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>闭包</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-11-11-Vue-01</title>
    <url>/2019/11/11/2019-11-11-Vue-01/</url>
    <content><![CDATA[<h1 id="Vue-js是什么"><a href="#Vue-js是什么" class="headerlink" title="Vue.js是什么"></a>Vue.js是什么</h1><p><code>Vue</code>是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，<code>Vue</code> 被设计为可以自底向上逐层应用。<code>Vue</code> 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">现代化的工具链</a>以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener">支持类库</a>结合使用时，<code>Vue</code> 也完全能够为复杂的单页应用提供驱动。</p>
<a id="more"></a>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol>
<li><p><code>v-once指令</code>:进行一次行插值，当数据改变时，插值处的内容不会更新</p>
</li>
<li><p><code>v-html指令</code>：输出<code>html</code></p>
</li>
<li><p><code>v-cloak指令</code>：可以隐藏未编译的标签直到实例准备完毕。解决插值表达式问题</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs javascript">[v-cloak]&#123;display: none&#125;<br>&lt;div v-cloak&gt;<br>    &#123;&#123; message &#125;&#125;<br>&lt;/div&gt;<br>//不会显示直到编译结束<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>v-text指令</code>：没有需要用v-cloak解决的插值闪烁问题。并且它会覆盖元素中原本的内容，插值表达式只会替换自己的占位符</p>
</li>
<li><p><code>v-bind指令</code>:（缩写 ：）用来动态的绑定一个或多个特性（属性类似：title，class，style），或一个组件prop到表达式</p>
</li>
<li><p><code>v-on指令</code>: （简写：@）绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;button v-on:click="doThis"&gt;&lt;/button&gt;<br>&lt;!-- 缩写 --&gt;<br>&lt;button @click="doThis"&gt;&lt;/button&gt;<br>.stop - 调用 event.stopPropagation()。<br>.prevent - 调用 event.preventDefault()。<br>.capture - 添加事件侦听器时使用 capture 模式。<br>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。<br>.&#123;keyCode | keyAlias&#125; - 只当事件是从特定键触发时才触发回调。<br>.native - 监听组件根元素的原生事件。<br>.once - 只触发一次回调。<br>.left - (2.2.0) 只当点击鼠标左键时触发。<br>.right - (2.2.0) 只当点击鼠标右键时触发。<br>.middle - (2.2.0) 只当点击鼠标中键时触发。<br>.passive - (2.3.0) 以 &#123; passive: true &#125; 模式添加侦听器<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>v-model指令</code>：数据双向绑定，仅限于表单数据。</p>
<p>输出的属性会影响元素变化</p>
</li>
<li><p><code>v-for指令</code>：对数据进行遍历</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>js作用域</title>
    <url>/2019/11/27/2019-11-27-js%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="关于函数作用域"><a href="#关于函数作用域" class="headerlink" title="关于函数作用域"></a>关于函数作用域</h1><p>几乎所有编程语言的基本功能之一就是<strong>能够存储变量当中的值</strong>，并且能在这之后进行访问和修改，那么变量存储在哪里？程序需要的时候如何找到他们。</p>
<p>事实上js也是一门编译语言，并且大部分情况下编译发生在代码执行前的几微秒（甚至更短）。</p>
<h2 id="关于编译原理"><a href="#关于编译原理" class="headerlink" title="关于编译原理"></a>关于编译原理</h2><a id="more"></a>

<p>传统编译语言的流程中，程序的一段源代码在执行之前会有三个步骤，统称为“编译”。</p>
<ol>
<li><p>分词/词法分析</p>
<p>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代 码块被称为词法单元（token）。例如，考虑程序 var a = 2;。这段程序通常会被分解成 为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。</p>
</li>
<li><p>解析/语法分析</p>
<p>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。</p>
</li>
<li><p>代码生成</p>
<p>将AST转换为可执行代码的过程被称为代码生成。</p>
</li>
</ol>
<h2 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h2><h3 id="进行工作的工作员"><a href="#进行工作的工作员" class="headerlink" title="进行工作的工作员"></a>进行工作的工作员</h3><ol>
<li><p>引擎</p>
<p>从头到尾负责整个JavaScript程序的编译及执行过程</p>
</li>
<li><p>编译器</p>
<p>负责语法分析及代码生成</p>
</li>
<li><p>作用域</p>
<p>负责收集并维护所有声明的变量组成的一系列查询，并实施非常严格的规则，确定当前执行的代码对这些标识符的访问权限</p>
</li>
</ol>
<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>对于 var a = 2 ;</p>
<p>为变量分配内存，将其命名为a，然后将值2保存进这个变量，这句话并不完全正确</p>
<p>事实上编译器会进行如下处理：</p>
<ul>
<li>遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的 集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a。</li>
<li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值 操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。</li>
</ul>
<p>如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异 常！</p>
<h4 id="编译器的查询类型"><a href="#编译器的查询类型" class="headerlink" title="编译器的查询类型"></a>编译器的查询类型</h4><p>当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图 找到变量的容器本身，从而可以对其赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a)<br></code></pre></td></tr></table></figure>

<p>其中对a的引用是一个RHS引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取 得 a 的值，这样才能将值传递给 console.log(..)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>写给自己看的flex布局</title>
    <url>/2020/02/20/2020-02-20-1/</url>
    <content><![CDATA[<h5 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h5><p>flex布局相关的属性分两组，一组作用在flex容器上，还有一组作用在flex子项上</p>
<table>
<thead>
<tr>
<th align="center">作用在flex容器上</th>
<th align="center">作用在flex子项上</th>
</tr>
</thead>
<tbody><tr>
<td align="center">flex-direction</td>
<td align="center">order</td>
</tr>
<tr>
<td align="center">flex-wrap</td>
<td align="center">flex-grow</td>
</tr>
<tr>
<td align="center">flex-flow</td>
<td align="center">flex-shrink</td>
</tr>
<tr>
<td align="center">justify-content</td>
<td align="center">flex-basis</td>
</tr>
<tr>
<td align="center">align-items</td>
<td align="center">flex</td>
</tr>
<tr>
<td align="center">align-content</td>
<td align="center">align-self</td>
</tr>
</tbody></table>
<p>flex有很多属性，和平时使用的css不同的是它控制的是一个容器和容器内的所有子项，通常不是针对某一个子元素，所以在最开始的时候总是习惯的想要对某一个元素进行时会纠结不清到底使用哪个属性。</p>
<p>最后认为搞清楚flex布局最重要的也就是明白控制元素的主轴</p>
<img src="/2020/02/20/2020-02-20-1/41.png">

<p>也就是使用<code>flex-direction</code>控制主轴方向，通常默认主轴水平方向，那么使用<code>justify-content</code>去控制子项在水平方向的对齐方式是便是控制子项在X轴上的对齐方式。当<code>flex-direction</code>:column;时，主轴由原来的X轴变为Y轴，那么<code>justify-content</code>控制的便是纵向的布局，而不是一味的认为控制当前页面的横向布局。</p>
<a id="more"></a>

<ol>
<li>flex-direction`：用来控制子项的整体布局方向,<strong>也就是决定了子项的主轴</strong>。</li>
</ol>
<p>   <code>flex-direction</code>: <code>row</code>(显示为行，从左向右)|<code>row-reverse</code>(从右向左)|<code>column</code>(显示为列)|<code>column-reverse</code>(与column相反)</p>
<ol start="2">
<li><p><code>flex-wrap</code>：控制子项整体单行显示或换行显示</p>
<p><code>flex-wrap</code>: <code>nowrap</code>(单行显示不换行)|<code>wrap</code>(宽度不足换行显示)|<code>wrap-reverse</code>(宽度不足换行，下面的子项去上面)</p>
</li>
<li><p><strong><code>align-items</code>flex的子项们在（侧轴）主轴垂直方向上的对齐方式</strong></p>
<p><code>stretch</code>默认值。子项拉伸</p>
<p><code>flex-start</code>:逻辑CSS属性值，与文档流相关，默认表现为容器顶部对齐</p>
<p><code>flex-end</code>:逻辑CSS属性值，与文档流方向相关。默认表现为容器底部对齐。</p>
<p><code>center</code>:表现为垂直居中对齐</p>
<p><code>baseline</code>:表现为所有flex子项都对于flex容器的基线对齐</p>
</li>
<li><p><strong><code>justify-content</code>:决定主轴水平方向子项的对齐和分布方式</strong></p>
<p><code>justify-content</code>: <code>flex-start</code>(与文档流方向相关，默认为左对齐)|<code>flex-end</code>(右对齐)|<code>center</code>(表现为居中对齐)|<code>space-between</code>(两端对齐)|<code>space-around</code>(环绕，展现为边缘的空白只有中间空白的一半)|<code>space-evenly</code>(均等，每个子项两侧空白完全相等)</p>
</li>
<li><p><code>algin-content</code>可以看成与<code>justify-content</code>是相似的但是且对立的属性，前者指明水平方向flex子项的对齐和分布方式，而<code>align-content</code>则指明垂直方向每一项flex元素的对齐和分布方式哦。<strong>如果所有flex子项只有一行，则<code>aligi-content</code>属性是没有任何效果的</strong>；</p>
<p><code>stretch</code>默认值。每一行flex子元素都等比例拉伸。例如，如果共两行flex子元素，则每一行拉伸高度是50%。</p>
<p><code>flex-start</code>逻辑CSS属性值，与文档流方向相关。默认表现为顶部堆砌。</p>
<p><code>flex-end</code>逻辑CSS属性值，与文档流方向相关。默认表现为底部堆放。</p>
<p><code>center</code>表现为整体垂直居中对齐。</p>
<p><code>space-between</code>表现为上下两行两端对齐。剩下每一行元素等分剩余空间。</p>
<p><code>space-around</code>每一行元素上下都享有独立不重叠的空白空间。</p>
<p><code>space-evenly</code>每一行元素都完全上下等分。</p>
</li>
<li><p><code>flex-flow</code>: 为<code>flex-direction</code> 和<code>flex-wrap</code>两个属性的的缩写，例：flex-flow: row nowrap;</p>
<p>表示为子项从左向右排列，不换行</p>
</li>
</ol>
<h6 id="子项上的属性"><a href="#子项上的属性" class="headerlink" title="子项上的属性"></a>子项上的属性</h6><ol>
<li><code>order</code>: order:<integer>//整数值，控制子项的位置例如要子项在最前面只需要给一个-1就可以了</integer></li>
<li><code>flex-grow:</code>//数值默认0，可以是小数最大为1，控制占据剩余空间的比例</li>
<li><code>flex-shrink</code>: 当容器空间不足时单个元素的收缩比例</li>
<li><code>flex-basis</code>定义了在分配剩余空间之前元素的默认大小，默认auto，或指定尺寸</li>
<li><strong><code>flex</code>flex-grow,flex-shrink,flex-basis的缩写定义子项占多少份</strong></li>
<li><code>align-self</code>: 控制单独某一个flex子项的垂直对齐方式，与align-item类似，不过指定单个元素</li>
</ol>
<p>将一个父盒子中的两个子盒子左右居中对齐</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#father</span>&#123;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">1000px</span>;<br>            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid orange;<br>            <span class="hljs-attribute">display</span>: flex;<br>            <span class="hljs-attribute">justify-content</span>:space-between;<br>            <span class="hljs-attribute">align-items</span>: center;<br>        &#125;<br>        <span class="hljs-selector-class">.son1</span>,<span class="hljs-selector-class">.son2</span>&#123;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>            <span class="hljs-attribute">background-color</span>: red;<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Flex</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议</title>
    <url>/2020/02/27/2020-02-27/</url>
    <content><![CDATA[<p>TCP/IP协议 族各层的作用</p>
<ul>
<li><p>应用层：决定了用户提供应用服务时 通信的活动，比如FTP(文件传输协议)，DNS(域名系统)，HTTP</p>
</li>
<li><p>传输层：传输层对应上层应用层，提供处于网络连接中两台计算机之间的数据传输，传输层有两个性质不同的协议，TCP(传输控制协议)，UDP(用户数据报协议)</p>
<a id="more"></a>
</li>
<li><p>网络层：用来处理网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据传给对方。</p>
</li>
<li><p>链路层：用来 处理连接网络的硬件部分，包括操作系统，网卡，硬件的设备驱动等</p>
<img src="/2020/02/27/2020-02-27/1.png">

</li>
</ul>
<h3 id="确保可靠性的TCP协议"><a href="#确保可靠性的TCP协议" class="headerlink" title="确保可靠性的TCP协议"></a>确保可靠性的TCP协议</h3><p>TCP协议位于传输层，为了能够更容易的传输大数据将数据进行分割，并且要确保数据最终能否送达到对方，为列准确无误地将数据送达目标处，采用 了<strong>三次握手策略</strong></p>
<p>DNS服务是和HTTP协议一样位于应用层的协议，提供域名到ip地址之间的解析服务，由于用户通常适应字母配合数字进行记忆，但是计算机却更适合理解ip地址的一组纯数字，所以DNS服务应运而生，<strong>DNS协议通过 用户传入的域名进行查找对应的ip地址，或通过ip地址反向查找域名</strong></p>
<h3 id="URI与URL"><a href="#URI与URL" class="headerlink" title="URI与URL"></a>URI与URL</h3><p>URI(统一资源标识符)，标识某以互联网资源，而URL(统一资源定位符)，URI用字符串标识某一互联网资源，而URL表示资源的地址，可以说URL是URI的子集</p>
<p>URI：<a href="http://www.ietf.com/rfc/...txt" target="_blank" rel="noopener">http://www.ietf.com/rfc/...txt</a>  包括协议，登录信息，服务器地址，服务器端口号等</p>
<p>URL:<a href="http://ietf.com" target="_blank" rel="noopener">http://ietf.com</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Github与码云同时上传</title>
    <url>/2020/03/03/2020-03-03/</url>
    <content><![CDATA[<p>今天学校通知将毕业设计的项目每天进程上传到码云，那么一直使用GitHub的我该怎么同时维护，上网找到的办法是这样的（不一定是最简单的方法）</p>
<a id="more"></a>

<p>首先我在将本地的仓库上传到码云，打开本地.git文件夹中的cofig</p>
<img src="/2020/03/03/2020-03-03/6.jpg">

<p>然后github中创建同样的仓库，在cofig中添加如下代码</p>
<img src="/2020/03/03/2020-03-03/2.jpg">

<p>之后push会将代码同时推送到GitHub与码云</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>passport验证token</title>
    <url>/2020/03/06/2020-03-06-passport/</url>
    <content><![CDATA[<p>1关于token：</p>
<p>为什么出现token：session需要存储空间，其次需要依赖cookie来进行传递，或者url重写的方式。但是token在服务器是不需要存储用户信息的，并且传递方式不限于cookie传递，并且也可以保存起来。</p>
<a id="more"></a>

<p>token与session之间都是为了 身份验证。session一般翻译为会话，而token更多时候翻译为令牌；</p>
<p>关于jsonwebtoken：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jsonwebtoken'</span>);<br><span class="hljs-keyword">const</span> rule = &#123;<br>    <span class="hljs-attr">id</span>:user.id;<br>    name:user.name,<br>    <span class="hljs-attr">identity</span>:user.identity<br>&#125;<br><span class="hljs-comment">//sgin('规则','加密名字'，'过期时间'，'箭头函数')</span><br>jwt.sgin(rule,keys.secretOrKey,&#123; <span class="hljs-attr">exporesIn</span>:<span class="hljs-number">3600</span>&#125;,(err,token)=&gt;&#123;<br>    <span class="hljs-keyword">if</span>(err)&#123;<br>        <span class="hljs-built_in">console</span>.log(err);<br>        <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).json...<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        res.status(<span class="hljs-number">200</span>).json...<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>前端接收，存储在localstroage中</p>
<p>passport:</p>
<p>引入passport并进行初始化</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.use</span>(<span class="hljs-selector-tag">passport</span><span class="hljs-selector-class">.initialize</span>());<br></code></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">const</span> User = <span class="hljs-built_in">require</span>(<span class="hljs-string">"../dbModel/user"</span>);<br><span class="hljs-keyword">const</span> Admin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"../dbModel/admin"</span>);<br><span class="hljs-keyword">const</span> Key = <span class="hljs-built_in">require</span>(<span class="hljs-string">"../secret/jwtkey"</span>).KEYORSECRET;<br><span class="hljs-keyword">const</span> JwtStrategy = <span class="hljs-built_in">require</span>(<span class="hljs-string">'passport-jwt'</span>).Strategy,<br>      ExtractJwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'passport-jwt'</span>).ExtractJwt;<br><span class="hljs-keyword">var</span> opts = &#123;&#125;<br>opts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();<span class="hljs-comment">//通过配置信息来生成jwt的请求，验证这个token</span><br>opts.secretOrKey = Key;<br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">passport</span> =&gt;</span> &#123;<br>    passport.use(<span class="hljs-keyword">new</span> JwtStrategy(opts, <span class="hljs-function">(<span class="hljs-params">jwt_payload, done</span>) =&gt;</span> &#123;<span class="hljs-comment">//jwt_payload用户信息</span><br>        User.findById(jwt_payload.id)<br>                .then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">if</span> (user) &#123;<br>                        <span class="hljs-keyword">return</span> done(<span class="hljs-literal">null</span>, user);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        Admin.findById(jwt_payload.id)<br>                                .then(<span class="hljs-function"><span class="hljs-params">admin</span> =&gt;</span> &#123;<br>                                    <span class="hljs-keyword">if</span>(admin)&#123;<br>                                        <span class="hljs-keyword">return</span> done(<span class="hljs-literal">null</span>, admin);<br>                                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                                        <span class="hljs-keyword">return</span> done(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>                                        <span class="hljs-comment">// or you could create a new account</span><br>                                    &#125;<br>                                &#125;)<br>                    &#125;<br>                &#125;)<br>    &#125;));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>passport-jwt: 是passport中的对于jsonwebtoken的插件</p>
<p>验证请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">app.post(<span class="hljs-string">'/profile'</span>, passport.authenticate(<span class="hljs-string">'jwt'</span>, &#123; <span class="hljs-attr">session</span>: <span class="hljs-literal">false</span> &#125;),<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;        res.send(req.user.profile);    <br>     &#125;);<br></code></pre></td></tr></table></figure>

<p>new JwtStrategy(options, verify)</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>PPT模板</title>
    <url>/2019/03/29/3-29ppt%E6%A8%A1%E6%9D%BF%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="ppt模板"><a href="#ppt模板" class="headerlink" title="ppt模板"></a>ppt模板</h1><p><a href="https://pan.baidu.com/s/1tequzqrq0m7ok2BALQ2oow" target="_blank" rel="noopener">点这里哦！提取码twyn</a></p>
<img src="/2019/03/29/3-29ppt模板分享/base.jpg">

]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>resource</tag>
      </tags>
  </entry>
  <entry>
    <title>JS随记</title>
    <url>/2019/05/12/5-12/</url>
    <content><![CDATA[<h1 id="如何交换两个数"><a href="#如何交换两个数" class="headerlink" title="如何交换两个数"></a>如何交换两个数</h1><a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">var</span>  num1  =  <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span>  num2  =  <span class="hljs-number">20</span>;<br><span class="hljs-comment">//定义变量temp</span><br><span class="hljs-keyword">var</span>  temp;<br><span class="hljs-comment">//将num1的值给temp，temp==10；</span><br>temp  =  num1;<br><span class="hljs-comment">//将num2的值给num1，num1==20；</span><br>num1  =  num2;<br><span class="hljs-comment">//将temp的值给num2，num2==10；</span><br>num2  =  temp;<br><span class="hljs-built_in">console</span>.log(num1, num2);<br></code></pre></td></tr></table></figure>

<h2 id="方式2，适用于数字交换"><a href="#方式2，适用于数字交换" class="headerlink" title="方式2，适用于数字交换"></a>方式2，适用于数字交换</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs undefined">var  <span class="hljs-attribute">num1</span>=10;<br>var  <span class="hljs-attribute">num2</span>=20;<br><span class="hljs-attribute">num1</span>=num1+num2;<br><span class="hljs-attribute">num2</span>=num1-num2;<br><span class="hljs-attribute">num1</span>=num1-num2;<br>console.log(num1,num2);<br></code></pre></td></tr></table></figure>

<h1 id="js中的数据类型"><a href="#js中的数据类型" class="headerlink" title="js中的数据类型"></a>js中的数据类型</h1><p>原始数据类型：number,string,boolean,object,undefined,null</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span>;<br>console.log(<span class="hljs-built_in">num</span>+<span class="hljs-number">10</span>);<span class="hljs-comment">//NaN---not an number---&gt;不是一个数字</span><br></code></pre></td></tr></table></figure>

<h2 id="如何获取变量的数据类型"><a href="#如何获取变量的数据类型" class="headerlink" title="如何获取变量的数据类型"></a>如何获取变量的数据类型</h2><p>typeof 变量名<br>typeof (变量名)<br>console.log(typeof num);//number</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>数组案例</title>
    <url>/2019/05/15/5-15%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>案例</p>
<a id="more"></a>

<ol>
<li><p>求数组中所有元素的和</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>];<br><span class="hljs-keyword">var</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span> <span class="hljs-keyword">in</span> arr)&#123;<br>    sum+=arr[i];<br>&#125;<br><span class="hljs-built_in">console</span>.log(sum);<br></code></pre></td></tr></table></figure>
</li>
<li><p>求数组中所有元素的平均值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>];<br><span class="hljs-keyword">var</span> sum=<span class="hljs-number">0</span>,x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> arr)&#123;<br>    sum+=arr[i];<br>    x=sum/arr.length;<br>&#125;<br><span class="hljs-built_in">console</span>.log(x);<br></code></pre></td></tr></table></figure>
</li>
<li><p>求数组中所有元素的最大值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>];<br><span class="hljs-comment">//假设max是数组中最大的值</span><br><span class="hljs-keyword">var</span> max=arr[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> arr)&#123;<br><span class="hljs-comment">//将max与数组中的值挨个比较，max较小就将对比的值赋给max</span><br>    <span class="hljs-keyword">if</span>(max&lt;arr[i])&#123;<br>        max=arr[i];<br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(max);<br></code></pre></td></tr></table></figure>
</li>
<li><p>倒序输出数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=arr.length<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-built_in">console</span>.log(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>提示用户输入班级人数，求总成绩，平均值，最高分，最低分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//提示用户输入人数，并转成数字类型</span><br>      <span class="hljs-keyword">var</span> perCount = <span class="hljs-built_in">parseInt</span>(prompt(<span class="hljs-string">"请输入班级人数"</span>));<br>      <span class="hljs-comment">//定义数组存储班级的每个人的成绩</span><br>      <span class="hljs-keyword">var</span> perScores = [];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; perCount; i++) &#123;<br>          perScores[perScores.length] = <span class="hljs-built_in">parseInt</span>(prompt(<span class="hljs-string">"请输入第"</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">"个人"</span>));<br>      &#125;<br>      <span class="hljs-comment">//求总成绩</span><br>      <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>,<br>          avg = <span class="hljs-number">0</span>,<br>          max = <span class="hljs-number">0</span>,<br>          min = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; perScores.length; i++) &#123;<br>   <br>          sum += perScores[i];<br>          avg = sum / perScores.length;<br>          <span class="hljs-comment">//最大值</span><br>          max = perScores[<span class="hljs-number">0</span>];<br>   <br>          <span class="hljs-keyword">if</span> (max &lt; perScores[i]) &#123;<br>              max = perScores[i];<br>          &#125;<br>          min=perScores[<span class="hljs-number">0</span>];<br>          <span class="hljs-keyword">if</span>(min&gt;perCount[i])&#123;<br>              min=perScores[i];<br>          &#125;<br>      &#125;<br>      <span class="hljs-built_in">console</span>.log(sum);<br>      <span class="hljs-built_in">console</span>.log(avg);<br>      <span class="hljs-built_in">console</span>.log(min);<br>      <span class="hljs-built_in">console</span>.log(max);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>冒泡排序</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">30</span>,<span class="hljs-number">20</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.length<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;arr.length<span class="hljs-number">-1</span>-i;j++)&#123;<br>    <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123;<br>        <span class="hljs-keyword">var</span> temp=arr[j];<br>        arr[j]=arr[j+<span class="hljs-number">1</span>];<br>        arr[j+<span class="hljs-number">1</span>]=temp;<br>    &#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(arr);<br></code></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js中的函数</title>
    <url>/2019/05/16/5-16%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义方式如下："><a href="#函数定义方式如下：" class="headerlink" title="函数定义方式如下："></a>函数定义方式如下：</h2><a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abs</span>(<span class="hljs-params">x</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述abs()函数的定义如下：</p>
<ul>
<li>function指出这是一个函数定义；</li>
<li>abs是函数的名称；</li>
<li>(x)括号内列出函数的参数，多个参数以，分割；</li>
<li>{…}之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。</li>
</ul>
<p>函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。所以，函数内部通过条件判断可以实现非常复杂的逻辑。如果没有return语句，函数执行完毕也会返回结果，只是结果为undefined。</p>
<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">x,y</span>)</span>&#123;<br><span class="hljs-keyword">var</span> sum=x+y;<span class="hljs-comment">//没有返回值</span><br>&#125;<br><span class="hljs-keyword">var</span> result=f1(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br><span class="hljs-built_in">console</span>.log(result);<span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure>

<p>由于函数也是也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量</p>
<p>第二种定义函数的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> abs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -x;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这种方式下，function(x){}是一个匿名函数，它没有函数名。但是，这个函数赋值给了变量abs，所以，通过变量abs就可以调用该函数，这种方法需要在函数体末尾加一个；，表示赋值语句结束。</p>
<h2 id="函数的arguments"><a href="#函数的arguments" class="headerlink" title="函数的arguments"></a>函数的arguments</h2><p><code>JavasScript</code>函数有一个名为<code>arguments</code>对象的内置对象，arguments 对象包含函数调用时使用的参数数组</p>
<h3 id="Call"><a href="#Call" class="headerlink" title="Call()"></a>Call()</h3><p>通过<code>call()</code>能够使用属于另一个对象的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-attr">fullName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.lastName;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = &#123;<br>    <span class="hljs-attr">firstName</span>:<span class="hljs-string">"Bill"</span>,<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Gates"</span>,<br>&#125;<br><span class="hljs-keyword">var</span> person2 = &#123;<br>    <span class="hljs-attr">firstName</span>:<span class="hljs-string">"Steve"</span>,<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Jobs"</span>,<br>&#125;<br>person.fullName.call(person1);  <span class="hljs-comment">// 将返回 "Bill Gates"</span><br></code></pre></td></tr></table></figure>

<p>call的第一个参数指定了<code>this</code>的指向，往后的参数被依次传入函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> a, b, c </span>)</span>&#123; <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span> === <span class="hljs-built_in">window</span>); <span class="hljs-comment">// 输出:true</span><br>&#125;;<br>func.apply( <span class="hljs-literal">null</span>, [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ] );<br></code></pre></td></tr></table></figure>

<p>如果第一个参数传<code>null</code>,函数体内的 this 会指 向默认的宿主对象,在浏览器中则是 window</p>
<p><strong>所以call的第一个作用就是改变this的指向</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1=&#123; <br>    <span class="hljs-attr">name</span>: <span class="hljs-string">'sven'</span><br>&#125;;<br><span class="hljs-keyword">var</span> obj2=&#123; <br>    <span class="hljs-attr">name</span>: <span class="hljs-string">'anne'</span><br>&#125;;<br><span class="hljs-built_in">window</span>.name = <span class="hljs-string">'window'</span>;<br><span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <br>    <span class="hljs-built_in">console</span>.log ( <span class="hljs-keyword">this</span>.name );<br>&#125;;<br>getName(); <span class="hljs-comment">// 输出: window</span><br>getName.call( obj1 );<span class="hljs-comment">// 输出: sven</span><br>getName.call(obj2 ); <span class="hljs-comment">// 输出: anne</span><br></code></pre></td></tr></table></figure>

<p>箭头函数的几个使用注意点。</p>
<p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>
<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p>
<p>冒泡排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortArray</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                        <span class="hljs-keyword">var</span> temp = arr[j + <span class="hljs-number">1</span>];<br>                        arr[j + <span class="hljs-number">1</span>] = arr[j];<br>                        arr[j] = temp;<br>                    &#125;<br><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> arr;<br>        &#125;<br>        <span class="hljs-built_in">console</span>.log(sortArray([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">12</span>,<span class="hljs-number">32</span>,<span class="hljs-number">12</span>,<span class="hljs-number">21</span>]));<br></code></pre></td></tr></table></figure>

<p>斐波那契数列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fb</span>(<span class="hljs-params">n</span>)</span>&#123;<br>            <span class="hljs-keyword">var</span> first=<span class="hljs-number">1</span>,second=<span class="hljs-number">1</span>,result=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)&#123;<br>                result=first+second;<br>                first=second;<br>                second=result;<br>            &#125;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><span class="hljs-number">2.</span><br>&lt;script&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fb</span>(<span class="hljs-params">n</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(n=<span class="hljs-number">1</span>||n==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fb(n<span class="hljs-number">-1</span>)+fb(n<span class="hljs-number">-2</span>);<br>    &#125;<br>    &lt;<span class="hljs-regexp">/script&gt;</span><br></code></pre></td></tr></table></figure>

<p>arguments对象伪数组，可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abs</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> ? x : -x;<br>&#125;<br><br>abs(); <span class="hljs-comment">// 0</span><br>abs(<span class="hljs-number">10</span>); <span class="hljs-comment">// 10</span><br>abs(<span class="hljs-number">-9</span>); <span class="hljs-comment">// 9</span><br><span class="hljs-comment">//求几个数的和可以这样</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;<br>    sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-built_in">arguments</span>.length;i++)&#123;<br>sum+=<span class="hljs-built_in">arguments</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>6-19CSS相关问题</title>
    <url>/2020/06/19/6-19/</url>
    <content><![CDATA[<ul>
<li><p>text-indent:-999px;当做一个a链接的图片按钮时，可以用于在添加完图片时将原本的字隐藏，只显示图片作为链接按钮</p>
<img src="/2020/06/19/6-19/1.png">

<a id="more"></a>
</li>
<li><p>content用于在元素的::before和::after伪元素中插入内容。例如在自定义复选框样式时，</p>
<img src="/2020/06/19/6-19/2.png">

<p>使用label覆盖input，设置label的样式通过content设置在点击状态时显示背景图片</p>
</li>
<li><p>label标签表示用户界面中某个元素的说明。将一个 <code>&lt;label&gt;</code> 和一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input" target="_blank" rel="noopener">``</a> 元素相关联主要有这些优点：</p>
<ul>
<li>标签文本不仅与其相应的文本输入元素在视觉上相关联，程序中也是如此。 这意味着，当用户聚焦到这个表单输入元素时，屏幕阅读器可以读出标签，让使用辅助技术的用户更容易理解应输入什么数据。</li>
<li>你可以点击关联的标签来聚焦或者激活这个输入元素，就像直接点击输入元素一样。这扩大了元素的可点击区域，让包括使用触屏设备在内的用户更容易激活这个元素。</li>
</ul>
<p>将一个 <code>&lt;label&gt;</code> 和一个 <code>&lt;input&gt;</code> 元素匹配在一起，你需要给 <code>&lt;input&gt;</code> 一个 <code>id</code> 属性。而 <code>&lt;label&gt;</code> 需要一个 <code>for</code> 属性，其值和  <code>&lt;input&gt;</code> 的 <code>id</code> 一样。</p>
<p>另外，你也可以将 <code>&lt;input&gt;</code> 直接放在 <code>&lt;label&gt;</code> 里，此时则不需要 <code>for</code> 和 <code>id</code> 属性，因为关联已隐含存在</p>
</li>
<li><p>给父元素overflow：hidden；zoom：1；清除浮动。</p>
</li>
<li><p>移动端布局</p>
<ol>
<li>做移动端的两种方式，一个项目分为PC端适配和移动端布局，判断设备进行切换</li>
<li>一种PC移动端同时适配的响应式页面，适应pc页面和移动端页面，@media</li>
<li>@media screen and(max-width:300px)当页面宽度小于300像素时，使用此内容中的样式</li>
<li>宽度设为100%，盒子自动继承父盒子宽度</li>
</ol>
<p>轮播图</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs css">&lt;div class="btnList"&gt;<br>            &lt;div class="btn pre"&gt;&lt;&lt;/div&gt;<br>            &lt;div class="btn next"&gt;&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br>.swiper .btn.pre&#123;width: 100px;height: 60px;line-height: 60px;text-align: center;background-color: rgba(0,0, 0, 0.6);color: #ffffff;position: absolute;top: calc(50% - 30px);font-size: 35px;&#125;<br><br>.swiper .btn.next&#123;width: 100px;height: 60px;line-height: 60px;text-align: center;background-color: rgba(0,0, 0, 0.6);color: #ffffff;position: absolute;right: 0;;top: calc(50% - 30px);font-size: 35px;&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> preBtn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".swiper .pre"</span>);<br>        <span class="hljs-keyword">var</span> nextBtn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".swiper .next"</span>);<br>        <span class="hljs-keyword">var</span> imgListDivs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">".swiper .imgItems"</span>);<br>        <span class="hljs-comment">// 图片数组的索引</span><br>        <span class="hljs-keyword">var</span> currentImg = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 点击事件</span><br>        nextBtn.onclick=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            currentImg = currentImg + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 点击到最后一张图片，回到起点</span><br>            <span class="hljs-keyword">if</span>(currentImg&gt;=imgListDivs.length)&#123;<br>                currentImg= <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-comment">// 初始化，将所有的img列表的active去掉</span><br>            imgListDivs.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item,i</span>)</span>&#123;<br>                item.classList.remove(<span class="hljs-string">"active"</span>)<br>            &#125;)<br>            <span class="hljs-comment">// 点击后索引加1，active移动到下一个元素显示下一张图片</span><br>            imgListDivs[currentImg].classList.add(<span class="hljs-string">"active"</span>)<br>            <br>        &#125;<br>        preBtn.onclick=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            currentImg = currentImg - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(currentImg&lt;<span class="hljs-number">0</span>)&#123;<br>                currentImg= imgListDivs.length<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 初始化，将所有的img列表的active去掉</span><br>            imgListDivs.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item,i</span>)</span>&#123;<br>                item.classList.remove(<span class="hljs-string">"active"</span>)<br>            &#125;)<br>            imgListDivs[currentImg].classList.add(<span class="hljs-string">"active"</span>)<br>            <br>        &#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>廖雪峰官方网站Git粗略总结</title>
    <url>/2019/06/04/6-4git/</url>
    <content><![CDATA[<h1 id="git学习总结"><a href="#git学习总结" class="headerlink" title="git学习总结"></a>git学习总结</h1><ol>
<li><p>初始化一个Git仓库，使用<code>git init</code>命令</p>
</li>
<li><p>添加文件到Git仓库，分两步：</p>
<p>使用命令<code>git add&lt;file&gt;</code>，可反复多次使用，添加多个文件；</p>
<p>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</p>
<a id="more"></a>

</li>
</ol>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ol>
<li><p>使用<code>git log</code>命令查看最近到最远的修改记录，输出信息太多显得杂乱可以加上<code>--pretty=oneline</code> 参数</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs undefined">$ git log --pretty=oneline<br><span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master) append GPL<br>e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span> <span class="hljs-keyword">add</span> distributed<br>eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span> wrote a readme file<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用命令<code>git reset --hard HEAD^</code>回退到上一版本</p>
</li>
<li><p>回到未来在窗口没有被关掉时找到<code>commit id</code>，可以指定回到未来的某个版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs undefined">$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 1094a</span><br><span class="hljs-keyword">HEAD</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">now</span> <span class="hljs-keyword">at</span> <span class="hljs-number">83</span>b0afe append GPL<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果关闭了窗口使用<code>git reflog</code>名令查看每一次输入的命令找到曾经的<code>commit id</code></p>
</li>
</ol>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ol>
<li><code>git status</code>命令查看状态</li>
<li>再提交前，使用<code>git checkout --file</code>丢弃对工作区的修改<strong>–</strong>很重要</li>
<li>已经<code>git add</code>到暂存区，在<code>commit</code>之前<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉，重新放回工作区</li>
</ol>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>命令<code>git rm file</code>删除文件，并且<code>commit</code></p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>查看已经存放：git ls-files</p>
<p>查看还没添加的文件：git status</p>
<h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><p>命令<code>git clone</code>在本地克隆一个仓库。</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><ol>
<li>查看分支：<code>git branch</code></li>
<li>创建分支：<code>git branch &lt;name&gt;</code></li>
<li>切换分支：<code>git checkout &lt;name&gt;</code></li>
<li>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></li>
<li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></li>
<li>删除分支：<code>git branch -d &lt;name&gt;</code></li>
</ol>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>在分支上进行修改，提交后切换到master，在master分支下又进行了修改提交，这时候进行分支合并则会产生冲突，必须手动解决冲突</p>
<ol>
<li><code>git status</code>会告诉我们冲突的文件</li>
<li><code>git log --graph</code>可以看到分支合并图</li>
</ol>
<h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>当已经在本地创建了一个Git仓库后，又想在<code>GitHub</code>上创建一个Git仓库，并且让这两个仓库惊醒远程同步.</p>
<ol>
<li><p>新建远程仓库在<code>repository name</code>填入<code>learngit</code>,其它保持默认设置，点击创建，就成功创建了一个新的Git仓库</p>
</li>
<li><p>现在在本地的<code>learngit</code>运行命令</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs undefined">$ git remote <span class="hljs-keyword">add</span><span class="bash"> origin git@github.com:你的github账户名/learngit.git</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>下一步将本地库的所有内容推送到远程库上：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs undefined">$ git push -u origin master<br>Counting objects: <span class="hljs-number">20</span>, done.<br>Delta compression using up to <span class="hljs-number">4</span> threads.<br>Compressing objects: <span class="hljs-number">100</span>% (<span class="hljs-number">15</span>/<span class="hljs-number">15</span>), done.<br>Writing objects: <span class="hljs-number">100</span>% (<span class="hljs-number">20</span>/<span class="hljs-number">20</span>), <span class="hljs-number">1.64</span> KiB | <span class="hljs-number">560.00</span> KiB/s, done.<br>Total <span class="hljs-number">20</span> (delta <span class="hljs-number">5</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br>remote: Resolving deltas: <span class="hljs-number">100</span>% (<span class="hljs-number">5</span>/<span class="hljs-number">5</span>), done.<br>To github.com:michaelliao/learngit.git<br> * [new branch]      master -&gt; master<br>Branch <span class="hljs-string">'master'</span> <span class="hljs-keyword">set</span> up to track remote branch <span class="hljs-string">'master'</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'origin'</span><br></code></pre></td></tr></table></figure>

<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支master推送到远程。</p>
</li>
</ol>
<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>找到<code>GitHub</code>中的仓库使用<code>git clone</code>克隆一个本地库</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs undefined">$ git clone <span class="hljs-symbol">git@</span>github.com:michaelliao/gitskills.git<br>Cloning <span class="hljs-built_in">int</span>o <span class="hljs-string">'gitskills'</span>...<br>remote: Counting objects: <span class="hljs-number">3</span>, done.<br>remote: Total <span class="hljs-number">3</span> (delta <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>), pack-reused <span class="hljs-number">3</span><br>Receiving objects: <span class="hljs-number">100</span>% (<span class="hljs-number">3</span>/<span class="hljs-number">3</span>), done.<br></code></pre></td></tr></table></figure>

<p>在本地要在自己想要的盘符进行克隆，如果想克隆在D盘，那么只需要在D盘下运行<code>Git bash</code></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux</title>
    <url>/2019/06/05/6-5-linux-01/</url>
    <content><![CDATA[<h1 id="linux学习"><a href="#linux学习" class="headerlink" title="linux学习"></a>linux学习</h1><h2 id="学习linux的流程为："><a href="#学习linux的流程为：" class="headerlink" title="学习linux的流程为："></a>学习linux的流程为：</h2><ul>
<li>第一阶段：linux环境下的 基本操作命令，包括 文件操作命令(rm mkdir chmod chown) 编辑工具使用(vi vim) linux用户管理（useradd userdel）等</li>
<li>第二阶段：linux的各种配置（环境变量配置，网络配置，服务配置）</li>
<li>第三阶段：linux下如何搭建对应的语言开发环境(大数据，JavaEE,Python等)</li>
<li>第四阶段：能编写shell脚本，对linux服务器进行维护</li>
<li>第五阶段：能进行安全设置，防止攻击，保障服务器正常运行，能对系统调优</li>
<li>第六阶段：深入理解linux（对内核有研究），熟练掌握大型网站应用架构组成。并熟悉各个环节的部署和维护方法</li>
</ul>
<p><code>xrandr --size &lt;width&gt;x&lt;height&gt;</code>修改显示分辨率</p>
<h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p><em>linux中一切皆文件</em>linux文件系统采用级层式的树状目录结构，在此结构中的最上层是根目录“/”。</p>
<ul>
<li>/bin    binary的缩写，存放的是最经常使用的命令</li>
<li>/sbin   存放系统管理员使用的系统管理程序</li>
<li>/home  存放普通用户的主目录</li>
<li>/root   系统管理员</li>
<li>/lib    系统开机所需要的最基本的动态链接共享库，其作用类似于windows例的dll文件</li>
<li><strong>/etc</strong>  所有的系统管理所需要的配置文件和子目录</li>
<li>*<em>/usr *</em>  非常重要的目录，用户的很多应用程序和文件都放在这个目录下</li>
<li>/boot  存放的是启动linux时使用的核心文件</li>
<li>/media  系统自动识别一些设备，例如光盘和U盘</li>
<li>/opt   给主机额外安装软件所摆放的目录</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOs</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串总结</title>
    <url>/2019/07/22/7-22%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>String类型是字符串的对象包装类型，可以像下面这样使用String构造函数来创建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringObject = <span class="hljs-keyword">new</span> string(<span class="hljs-string">"hello world"</span>);<br></code></pre></td></tr></table></figure>

<p>ECMAScript中字符串是不可改变的，也就是说一旦创建他们的值就是不可改变的，要改变某个变量保存的字符串，首先要先销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量</p>
<a id="more"></a>

<h2 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//可直接进行换行，解决了传统的拼接方式的繁琐</span><br>$(<span class="hljs-string">'#result'</span>).append(<span class="hljs-string">`<br>  There are &lt;b&gt;<span class="hljs-subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items<br>   in your basket, &lt;em&gt;<span class="hljs-subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;<br>  are on sale!<br>`</span>);<br></code></pre></td></tr></table></figure>

<h2 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h2><h3 id="转化方法"><a href="#转化方法" class="headerlink" title="转化方法"></a>转化方法</h3><ol>
<li>使用<code>toString()</code>基本每个值都有的方法，该方法不接受<strong>null和undefined</strong></li>
<li>String(),属于强制转换，null和undefined返回他们本身</li>
</ol>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="length-返回字符串长度"><a href="#length-返回字符串长度" class="headerlink" title=".length:返回字符串长度"></a><code>.length</code>:返回字符串长度</h4><h4 id="indexOf-searchString-position-返回字符串中指定文本的位置（也就是索引）"><a href="#indexOf-searchString-position-返回字符串中指定文本的位置（也就是索引）" class="headerlink" title="indexOf(searchString, ?position)返回字符串中指定文本的位置（也就是索引）"></a><code>indexOf(searchString, ?position)</code>返回字符串中指定文本的位置（也就是索引）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//可添加一个参数，搜索指定文本的位置，或通过第二个参数限定从第几个索引开始查找</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">'The China full of name is China'</span><br><span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">'China'</span>)) <span class="hljs-comment">//没设置索引时显示的位于索引4的China</span><br><span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">'China'</span>, <span class="hljs-number">15</span>))<span class="hljs-comment">//索引开始的位置，第一个China被跳过</span><br><span class="hljs-comment">//当未查到文本时返回-1</span><br></code></pre></td></tr></table></figure>

<h4 id="lastIndexOf-同理，从字符串后方开始查询"><a href="#lastIndexOf-同理，从字符串后方开始查询" class="headerlink" title="lastIndexOf()同理，从字符串后方开始查询"></a><code>lastIndexOf()</code>同理，从字符串后方开始查询</h4><h4 id="search-方法检索字符串中的字符串"><a href="#search-方法检索字符串中的字符串" class="headerlink" title="search()方法检索字符串中的字符串"></a><code>search()</code>方法检索字符串中的字符串</h4><p>和<code>indexOf()</code>类似，查找指定字符串的位置，不同的是，<code>search()</code>,不接受第二个参数，而<code>indexOf()</code>不接受正则匹配模式</p>
<h4 id="提取部分字符串"><a href="#提取部分字符串" class="headerlink" title="提取部分字符串"></a>提取部分字符串</h4><p><code>slice(start, end)</code>,<code>substring(start, end)</code>,<code>substr(start, end)</code></p>
<h5 id="slice"><a href="#slice" class="headerlink" title="slice()"></a><code>slice()</code></h5><p>截取指定位置，指定个数的字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">"Apple, Banana, Mango"</span>;<br><span class="hljs-keyword">var</span> res = str.slice(<span class="hljs-number">7</span>,<span class="hljs-number">13</span>);<span class="hljs-comment">//Banana,截取索引7到13部分的字符串</span><br><span class="hljs-keyword">var</span> res = str.slice(<span class="hljs-number">-13</span>,<span class="hljs-number">-7</span>);<span class="hljs-comment">//Banana,从倒数第13截取到倒数第7位</span><br><span class="hljs-comment">//当只选择一个参数时，截取从参数索引位置开始后的所有剩余部分</span><br><span class="hljs-keyword">var</span> res = str.slice(<span class="hljs-number">7</span>)；<span class="hljs-comment">//Banana, Mango</span><br><span class="hljs-comment">//参数为负时，选取倒着数索引后的所有字符串</span><br><span class="hljs-keyword">var</span> res = str.slice(<span class="hljs-number">-13</span>)；<span class="hljs-comment">//Banana, Mango</span><br></code></pre></td></tr></table></figure>

<h5 id="substring-与slice-相似，但是不接受负值的索引"><a href="#substring-与slice-相似，但是不接受负值的索引" class="headerlink" title="substring()与slice()相似，但是不接受负值的索引"></a><code>substring()</code>与<code>slice()</code>相似，但是不接受负值的索引</h5><h5 id="substr-也与slice-相似，不同之处为第二个参数不再是结束截取的索引，而是要截取的长度"><a href="#substr-也与slice-相似，不同之处为第二个参数不再是结束截取的索引，而是要截取的长度" class="headerlink" title="substr()也与slice()相似，不同之处为第二个参数不再是结束截取的索引，而是要截取的长度"></a><code>substr()</code>也与<code>slice()</code>相似，不同之处为第二个参数不再是结束截取的索引，而是要截取的长度</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//	从第七位索引，截取6位字符串</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">"Apple, Banana, Mango"</span>;<br><span class="hljs-keyword">var</span> res = str.substr(<span class="hljs-number">7</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//Banana</span><br></code></pre></td></tr></table></figure>

<h4 id="字符串的替换方法reaplace"><a href="#字符串的替换方法reaplace" class="headerlink" title="字符串的替换方法reaplace()"></a>字符串的替换方法<code>reaplace()</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//replace()不会改变原有的字符串，而是返回新的字符串，替换的的文本为第一次匹配到的文本，对大小写敏感</span><br>str = <span class="hljs-string">"Please visit Microsoft!"</span>;<br><span class="hljs-keyword">var</span> n = str.replace(<span class="hljs-string">"Microsoft"</span>, <span class="hljs-string">"W3School"</span>);<br><span class="hljs-built_in">console</span>.log(n);<span class="hljs-comment">//Please visit W3School</span><br><span class="hljs-comment">//如需执行大小写不敏感的替换，请使用正则表达式 /i（大小写不敏感）：</span><br><span class="hljs-keyword">var</span> n = str.replace(<span class="hljs-regexp">/MICROSOFT/i</span>, <span class="hljs-string">"W3School"</span>);<br></code></pre></td></tr></table></figure>

<h4 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h4><p><code>ECMAScript</code>中涉及字符串大小写转换的方法有四个：<code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code>和<code>toLocaleUpperCase()</code>其中<code>toLowerCase()</code>和 <code>toUpperCase()</code>是两个经典的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stringValue = <span class="hljs-string">"hello world"</span>;<br>alert(stringValue.toLocaleUpperCase()); <span class="hljs-comment">// "HELLO WORLD";</span><br></code></pre></td></tr></table></figure>

<h4 id="concat-方法可用于代替加运算符"><a href="#concat-方法可用于代替加运算符" class="headerlink" title="concat() 方法可用于代替加运算符"></a><code>concat()</code> 方法可用于代替加运算符</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> text = <span class="hljs-string">"Hello"</span> + <span class="hljs-string">" "</span> + <span class="hljs-string">"World!"</span>;<br><span class="hljs-keyword">var</span> text = <span class="hljs-string">"Hello"</span>.concat(<span class="hljs-string">" "</span>,<span class="hljs-string">"World!"</span>);<br></code></pre></td></tr></table></figure>

<h4 id="trim-方法删除字符串两端的空白符"><a href="#trim-方法删除字符串两端的空白符" class="headerlink" title="trim()方法删除字符串两端的空白符"></a><code>trim()</code>方法删除字符串两端的空白符</h4><p>该方法最近常见的用法是在输入框，实现搜索匹配时，用于去除用户传值时产生的空格</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">"       Hello World!        "</span>;<br>alert(str.trim());<br></code></pre></td></tr></table></figure>

<p><code>charAt()</code>返回指定位置的字符</p>
<p><code>charCodeAt()</code>返回指定位置字符的Unicode 编码</p>
<h2 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode()方法"></a><code>fromCharCode()</code>方法</h2><p>String构造函数本身还有一个静态方法，接收单一或多个字符编码，然后将他们转换成一个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">alert(<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">104</span>,<span class="hljs-number">101</span>,<span class="hljs-number">108</span>,<span class="hljs-number">108</span>,<span class="hljs-number">111</span>));  <span class="hljs-comment">//"hello"</span><br>这里传递的是字符串hello中每个字符的Unicode编码。<br></code></pre></td></tr></table></figure>

<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a><code>repeat()</code></h3><p><code>repeat</code>方法返回一个新的字符串，表示将原字符串重复n次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">'x'</span>.repeat(<span class="hljs-number">3</span>) <span class="hljs-comment">// "xxx"</span><br><span class="hljs-string">'hello'</span>.repeat(<span class="hljs-number">2</span>) <span class="hljs-comment">// "hellohello"</span><br><span class="hljs-string">'na'</span>.repeat(<span class="hljs-number">0</span>) <span class="hljs-comment">// ""</span><br></code></pre></td></tr></table></figure>

<h3 id="padStart-amp-padEnd"><a href="#padStart-amp-padEnd" class="headerlink" title="padStart()&amp;padEnd()"></a><code>padStart()</code>&amp;<code>padEnd()</code></h3><p>这两个方法是在ES6中新增的语法，用于为字符串提供补全方法，</p>
<p>例如：</p>
<p>格式化时间后的字符串<code>3:18</code>3分18秒</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">formateTime(seconds) &#123;<br>      <span class="hljs-keyword">if</span> (seconds &lt; <span class="hljs-number">60</span>) &#123;<br>        <span class="hljs-keyword">return</span> seconds.toString().padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (seconds &lt; <span class="hljs-number">3600</span>) &#123;<br>        <span class="hljs-keyword">const</span> m = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>(seconds / <span class="hljs-number">60</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>        <span class="hljs-keyword">const</span> s = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>(seconds % <span class="hljs-number">60</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;m&#125;</span>:<span class="hljs-subst">$&#123;s&#125;</span>`</span><br>      &#125;<br>      <span class="hljs-keyword">const</span> h = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>(seconds / <span class="hljs-number">3600</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>      <span class="hljs-keyword">const</span> m = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>((seconds % <span class="hljs-number">3600</span>) / <span class="hljs-number">60</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>      <span class="hljs-keyword">const</span> s = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>((seconds % <span class="hljs-number">3600</span>) % <span class="hljs-number">60</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;h&#125;</span>:<span class="hljs-subst">$&#123;m&#125;</span>:<span class="hljs-subst">$&#123;s&#125;</span>`</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery总结一</title>
    <url>/2019/07/26/7-26jQuery%E6%80%BB%E7%BB%93%E4%B8%80/</url>
    <content><![CDATA[<h1 id="jQuery总结"><a href="#jQuery总结" class="headerlink" title="jQuery总结"></a>jQuery总结</h1><h2 id="引入jQuery的原因"><a href="#引入jQuery的原因" class="headerlink" title="引入jQuery的原因"></a>引入jQuery的原因</h2><p>在用js写代码会出现的问题</p>
<ul>
<li>window.onload事件有事件覆盖的问题，因此只能写一个事件</li>
<li><strong>浏览器兼容问题</strong></li>
<li>书写繁琐，代码量多</li>
<li>动画效果实现复杂</li>
</ul>
<p>jQuery可以解决上述问题</p>
<a id="more"></a>

<h2 id="jQuery怎么使用"><a href="#jQuery怎么使用" class="headerlink" title="jQuery怎么使用"></a>jQuery怎么使用</h2><p>jQuery就是js的一个类库，jQuery的方法原生js都可以实现，所有使用jQuery就是使用jQuery封装好的API。</p>
<p>这些API的共同特点几乎都是方法。所以在使用jQuery都是方法的调用。</p>
<h2 id="jquery的特点"><a href="#jquery的特点" class="headerlink" title="jquery的特点"></a>jquery的特点</h2><ol>
<li>隐式迭代：在调用方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法，我们不需要再进行循环，简化我们的操作，方便我们的调用</li>
<li>链式编程：<strong>原理 jQuery节点在调用api后会返回自身节点（return this）</strong></li>
</ol>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li>引入js文件</li>
<li>页面加载事件</li>
<li>功能代码</li>
</ol>
<h2 id="jQuery页面加载事件"><a href="#jQuery页面加载事件" class="headerlink" title="jQuery页面加载事件"></a>jQuery页面加载事件</h2><p>DOM</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onlad=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<span class="hljs-comment">//不仅要等文本加载完毕，而且要等图片也加载完毕才执行函数。</span><br></code></pre></td></tr></table></figure>

<p>jQuery的页面加载事件有以下几种</p>
<ol>
<li><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-built_in">window</span>).load(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;) /  $(<span class="hljs-built_in">window</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;)<br><span class="hljs-comment">//这两种方式也都需要页面所有元素都加载完毕才能触发</span><br></code></pre></td></tr></table></figure>
</li>
<li><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-built_in">document</span>).reday(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;)<span class="hljs-comment">//文档加载完毕，图片还没有加载的时候就可以触发</span><br></code></pre></td></tr></table></figure>
</li>
<li><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">上一种方法的简洁版<br>$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;)<br></code></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="jQuery中的选择器"><a href="#jQuery中的选择器" class="headerlink" title="jQuery中的选择器"></a>jQuery中的选择器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">id选择器   $(<span class="hljs-string">"#dev"</span>);<br>标签选择器  $(<span class="hljs-string">"p"</span>);<br>类选择器    $(<span class="hljs-string">".cls"</span>);<br><span class="hljs-comment">//层次选择器</span><br>$(<span class="hljs-string">"#dv span"</span>);  <span class="hljs-comment">//div这个父级元素中所有的span标签</span><br>$(<span class="hljs-string">"#dv&gt;span"</span>)   <span class="hljs-comment">//div这个父级元素的所有**直接子元素**span标签</span><br>$(<span class="hljs-string">"#dv~span"</span>)   <span class="hljs-comment">//div这个父级元素后面的兄弟元素</span><br></code></pre></td></tr></table></figure>

<p>基本过滤选择器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// :odd奇数选择</span><br>$(<span class="hljs-string">"li:odd"</span>).css(<span class="hljs-string">"background"</span>, <span class="hljs-string">"red"</span>);<br><br><span class="hljs-comment">// :even偶数选择</span><br>$(<span class="hljs-string">"li:even"</span>).css(<span class="hljs-string">"background"</span>, <span class="hljs-string">"green"</span>);<br><br><span class="hljs-comment">// :eq(index)索引选择器</span><br>$(<span class="hljs-string">"ul li:eq(3)"</span>).css(<span class="hljs-string">"font-size"</span>, <span class="hljs-string">"30px"</span>);<span class="hljs-comment">//设置第四个li的字体</span><br><br><span class="hljs-comment">// :lt(index)小于索引</span><br>$(<span class="hljs-string">"li:lt(6)"</span>).css(<span class="hljs-string">"font-size"</span>, <span class="hljs-string">"30px"</span>);<br><br><span class="hljs-comment">// :gt(index)大于该索引</span><br>$(<span class="hljs-string">".ulList1 li:gt(7)"</span>).css(<span class="hljs-string">"font-size"</span>, <span class="hljs-string">"40px"</span>);<br><br><span class="hljs-comment">// :first第一个</span><br>$(<span class="hljs-string">".ulList li:first"</span>).css(<span class="hljs-string">"font-size"</span>, <span class="hljs-string">"40px"</span>);<br><br><span class="hljs-comment">// :last最后一个</span><br>$(<span class="hljs-string">"li:last"</span>).css(<span class="hljs-string">"font-size"</span>, <span class="hljs-string">"40px"</span>);<br></code></pre></td></tr></table></figure>

<h3 id="筛选选择器"><a href="#筛选选择器" class="headerlink" title="筛选选择器"></a>筛选选择器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">.prev();      该元素前一个兄弟元素<br>.prevAll();   该元素前面所有兄弟元素<br>.next();      该元素后一个兄弟元素<br>.nextAll();   该元素后面所有兄弟元素<br>.parnet();    该元素的父级元素<br>.find();      后代寻找选择器（要指定参数）例：<br>jqul.find(<span class="hljs-string">"li"</span>).css(<span class="hljs-string">"background"</span>, <span class="hljs-string">"pink"</span>);<br>.sibling();   该元素所有兄弟元素<br></code></pre></td></tr></table></figure>

<h2 id="jQuery中的一些方法"><a href="#jQuery中的一些方法" class="headerlink" title="jQuery中的一些方法"></a>jQuery中的一些方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">jQuery对象.val();    <span class="hljs-comment">//表示获取元素的value属性值</span><br>jQuery对象.val(<span class="hljs-string">"值"</span>);    <span class="hljs-comment">//表示设置元素的value属性值</span><br><br>jQuery对象.css(<span class="hljs-string">"backgroundColor"</span>,<span class="hljs-string">"red"</span>)  设置css样式<br><br>jQuery对象.text()         <span class="hljs-comment">//获取元素的文本内容</span><br>jQuery对象.text(<span class="hljs-string">""</span>)       <span class="hljs-comment">//设置元素的文本内容</span><br><br>jQuery对象.html()         <span class="hljs-comment">//获取元素的html内容</span><br>jQuery对象.html(<span class="hljs-string">""</span>)       <span class="hljs-comment">//设置元素的html内容</span><br><br>jQuery对象.mouseenter()   <span class="hljs-comment">//鼠标进入事件</span><br>jQuery对象.mouseleave()   <span class="hljs-comment">//鼠标离开事件</span><br></code></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;script src="jquery-1.12.1.min.js"&gt;&lt;/script&gt;<br>&lt;script&gt;<br>    //页面加载事件<br>      $(function () &#123; <br>          $("ul&gt;li").mouseenter(function()&#123;<br>           //鼠标进入背景颜色变为红色，其他兄弟元素没有颜色<br>              $(this).css("backgroundColor","red").siblings("li").css("backgroundColor","";<br>          &#125;).mouseleave(function()&#123;<br>$(this).parent().find("li").css("backgroundColor","");//鼠标离开都没有颜色<br>          &#125;).click(function()&#123;<br>       //添加点击事件鼠标点击上方变为黄色，下方变为蓝色<br>              $(this).prevAll().css("backgroundColor","yellow").end().nextAll().css("backgroundColor","blue");<br>          &#125;)<br>          <br>       &#125;)<br>//html<br>&lt;ul&gt;<br>        &lt;li&gt;青岛啤酒（TsingTao）&lt;/li&gt;<br>        &lt;li&gt;瓦伦丁（Wurenbacher）&lt;/li&gt;<br>        &lt;li&gt;雪花（SNOW）&lt;/li&gt;<br>        &lt;li&gt;奥丁格教士（Franziskaner）&lt;/li&gt;<br>        &lt;li&gt;科罗娜喜力柏龙（Paulaner）&lt;/li&gt;<br>        &lt;li&gt;嘉士伯Kaiserdom&lt;/li&gt;<br>        &lt;li&gt;罗斯福（Rochefort）&lt;/li&gt;<br>        &lt;li&gt;粉象（Delirium）&lt;/li&gt;<br>        &lt;li&gt;爱士堡（Eichbaum）&lt;/li&gt;<br>        &lt;li&gt;哈尔滨牌蓝带&lt;/li&gt;<br>      &lt;/ul&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs javascript">.index();   //当前元素的索引<br>.hasClass()   //判断是否应用类样式<br>.addClass()    //添加类样式<br>.removeClass()  //删除类样式<br>.toggleClass()  //切换类样式<br><br>.show("1000","function")  //可不加参数，意为如果隐藏则显示该元素，参数1：秒数  2：添加函数<br>.hide("","")   //同上，隐藏该元素<br>例：<br>&lt;script src="jquery-1.12.1.min.js"&gt;&lt;/script&gt;<br>      &lt;script&gt;<br>          $(function()&#123;<br>    //按钮1添加点击事件，从后开始隐藏图片，利用了回调函数<br>            $("#btn1").click(function()&#123;<br>          $("div&gt;img:last").hide(1000,function f1()&#123;<br>              $(this).prev().hide(1000,f1)<br>          &#125;);<br>         <br>      &#125;);<br>    //按钮2添加点击事件，从第一张图片开始出现<br>      $("#btn2").click(function()&#123;<br>        $("div&gt;img:first").show(1000,function f2()&#123;<br>              $(this).next().show(1000,f2);<br>      &#125;);<br>    &#125;);<br>          &#125;);<br>&lt;body&gt;<br>    &lt;input type="button" value="隐藏动画" id="btn1"/&gt;<br>&lt;input type="button" value="显示动画" id="btn2"/&gt;<br>&lt;div&gt;<br>  &lt;img src="images/11.jpg"/&gt;<br>  &lt;img src="images/22.jpg"/&gt;<br>  &lt;img src="images/33.jpg"/&gt;<br>  &lt;img src="images/44.jpg"/&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">动画相关方法<br>.slideUp();   <span class="hljs-comment">//滑入</span><br>.slideDown();  <span class="hljs-comment">//滑出</span><br>.slideToggle(); <span class="hljs-comment">//滑入滑出</span><br><br>.fadeIn(); <span class="hljs-comment">//淡入</span><br>.fadeOut(); <span class="hljs-comment">//淡出</span><br>.fadeToggle();淡入淡出<br><br>animate()自定义动画<br>$(selector).animate(&#123;params&#125;,[speed],[easing],[callback]);<br><span class="hljs-comment">// &#123;params&#125;：要执行动画的CSS属性，带数字（必选）</span><br><span class="hljs-comment">// speed：执行动画时长（可选）</span><br><span class="hljs-comment">// easing:执行效果，默认为swing（缓动）  可以是linear（匀速）</span><br><span class="hljs-comment">// callback：动画执行完后立即执行的回调函数（可选）</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery总结二</title>
    <url>/2019/07/29/7-26jQuery%E6%80%BB%E7%BB%93%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="jQuery节点操作"><a href="#jQuery节点操作" class="headerlink" title="jQuery节点操作"></a>jQuery节点操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// $(htmlStr)</span><br><span class="hljs-comment">// htmlStr：html格式的字符串</span><br>$(<span class="hljs-string">'&lt;span-这是一个span元素&lt;/span-'</span>);<br></code></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">append  appendTo	在被选元素的结尾插入内容<br>prepend prependTo	在被选元素的开头插入内容<br>before				在被选元素之后插入内容<br>after				在被选元素之前插入内容<br></code></pre></td></tr></table></figure>

<h3 id="清空节点与删除节点"><a href="#清空节点与删除节点" class="headerlink" title="清空节点与删除节点"></a>清空节点与删除节点</h3><ul>
<li>empty：清空指定节点的所有元素，自身保留(清理门户)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">'div'</span>).empty(); <span class="hljs-comment">// 清空div的所有内容（推荐使用，会清除子元素上绑定的内容，源码）</span><br>$(<span class="hljs-string">'div'</span>).html(<span class="hljs-string">''</span>);<span class="hljs-comment">// 使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。</span><br></code></pre></td></tr></table></figure>

<ul>
<li>remove：相比于empty，自身也删除（自杀）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">'div'</span>).remove();<br></code></pre></td></tr></table></figure>

<h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><ul>
<li>作用：复制匹配的元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 复制$(selector)所匹配到的元素（深度复制）</span><br><span class="hljs-comment">// cloneNode(true)</span><br><span class="hljs-comment">// 返回值为复制的新元素，和原来的元素没有任何关系了。即修改新元素，不会影响到原来的元素。</span><br>$(selector).clone();<br></code></pre></td></tr></table></figure>

<h2 id="jQuery操作属性"><a href="#jQuery操作属性" class="headerlink" title="jQuery操作属性"></a>jQuery操作属性</h2><h3 id="attr操作"><a href="#attr操作" class="headerlink" title="attr操作"></a>attr操作</h3><ul>
<li>设置单个属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一个参数：需要设置的属性名</span><br><span class="hljs-comment">// 第二个参数：对应的属性值</span><br>$obj.attr(name, value);<br><span class="hljs-comment">// 用法举例</span><br>$(<span class="hljs-string">'img'</span>).attr(<span class="hljs-string">'title'</span>,<span class="hljs-string">'哎哟，不错哦'</span>);<br>$(<span class="hljs-string">'img'</span>).attr(<span class="hljs-string">'alt'</span>,<span class="hljs-string">'哎哟，不错哦'</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>设置多个属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 参数是一个对象，包含了需要设置的属性名和属性值</span><br>$obj.attr(obj)<br><span class="hljs-comment">// 用法举例</span><br>$(<span class="hljs-string">'img'</span>).attr(&#123;<br>    <span class="hljs-attr">title</span>:<span class="hljs-string">'哎哟，不错哦'</span>,<br>    <span class="hljs-attr">alt</span>:<span class="hljs-string">'哎哟，不错哦'</span>,<br>    <span class="hljs-attr">style</span>:<span class="hljs-string">'opacity:.5'</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li>获取属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 传需要获取的属性名称，返回对应的属性值</span><br>$obj.attr(name)<br><span class="hljs-comment">// 用法举例</span><br><span class="hljs-keyword">var</span> oTitle = $(<span class="hljs-string">'img'</span>).attr(<span class="hljs-string">'title'</span>);<br>alert(oTitle);<br></code></pre></td></tr></table></figure>

<ul>
<li>移除属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 参数：需要移除的属性名，</span><br>$obj.removeAttr(name);<br><span class="hljs-comment">// 用法举例</span><br>$(<span class="hljs-string">'img'</span>).removeAttr(<span class="hljs-string">'title'</span>);<br></code></pre></td></tr></table></figure>

<h3 id="prop操作"><a href="#prop操作" class="headerlink" title="prop操作"></a>prop操作</h3><ul>
<li>在jQuery1.6之后，对于checked、selected、disabled这类boolean类型的属性来说，不能用attr方法，只能用prop方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置属性</span><br>$(<span class="hljs-string">':checked'</span>).prop(<span class="hljs-string">'checked'</span>,<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 获取属性</span><br>$(<span class="hljs-string">':checked'</span>).prop(<span class="hljs-string">'checked'</span>);<span class="hljs-comment">// 返回true或者false</span><br></code></pre></td></tr></table></figure>

<h3 id="val-text-html"><a href="#val-text-html" class="headerlink" title="val()/text/()html()"></a>val()/text/()html()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$obj.val()		获取或者设置表单元素的value属性的值<br>$obj.html() 	对应innerHTML<br>$obj.text()		对应innerText/textContent，处理了浏览器的兼容性<br></code></pre></td></tr></table></figure>

<h2 id="jQuery尺寸和位置操作"><a href="#jQuery尺寸和位置操作" class="headerlink" title="jQuery尺寸和位置操作"></a>jQuery尺寸和位置操作</h2><h3 id="width方法与height方法"><a href="#width方法与height方法" class="headerlink" title="width方法与height方法"></a>width方法与height方法</h3><ul>
<li>设置或者获取高度，不包括内边距、边框和外边距</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 带参数表示设置高度</span><br>$(<span class="hljs-string">'img'</span>).height(<span class="hljs-number">200</span>);<br><span class="hljs-comment">// 不带参数获取高度</span><br>$(<span class="hljs-string">'img'</span>).height();<br></code></pre></td></tr></table></figure>

<p>获取网页的可视区宽高</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取可视区宽度</span><br>$(<span class="hljs-built_in">window</span>).width();<br><span class="hljs-comment">// 获取可视区高度</span><br>$(<span class="hljs-built_in">window</span>).height();<br></code></pre></td></tr></table></figure>

<h3 id="innerWidth-innerHeight-outerWidth-outerHeight"><a href="#innerWidth-innerHeight-outerWidth-outerHeight" class="headerlink" title="innerWidth/innerHeight/outerWidth/outerHeight"></a><code>innerWidth</code>/<code>innerHeight</code>/<code>outerWidth</code>/<code>outerHeight</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">innerWidth()/innerHeight()	方法返回元素的宽度/高度（包括内边距）。<br>outerWidth()/outerHeight()  方法返回元素的宽度/高度（包括内边距和边框）。<br>outerWidth(<span class="hljs-literal">true</span>)/outerHeight(<span class="hljs-literal">true</span>)  方法返回元素的宽度/高度（包括内边距、边框和外边距）。<br></code></pre></td></tr></table></figure>

<h3 id="scrollTop与scrollLeft"><a href="#scrollTop与scrollLeft" class="headerlink" title="scrollTop与scrollLeft"></a><code>scrollTop</code>与<code>scrollLeft</code></h3><ul>
<li>设置或者获取垂直滚动条的位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取页面被卷曲的高度</span><br>$(<span class="hljs-built_in">window</span>).scrollTop();<br><span class="hljs-comment">// 获取页面被卷曲的宽度</span><br>$(<span class="hljs-built_in">window</span>).scrollLeft();<br></code></pre></td></tr></table></figure>

<h3 id="offset方法与position方法"><a href="#offset方法与position方法" class="headerlink" title="offset方法与position方法"></a>offset方法与position方法</h3><ul>
<li>offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素(<code>offsetParent</code>)的位置。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;</span><br>$(selector).offset();<br><span class="hljs-comment">// 获取相对于其最近的有定位的父元素的位置。</span><br>$(selector).position();<br></code></pre></td></tr></table></figure>

<p>案例：固定导航栏   [17-固定导航栏<code>.html</code>]<br>案例：电梯导航     [18-电梯导航<code>.html</code>]</p>
<h2 id="jQuery事件机制"><a href="#jQuery事件机制" class="headerlink" title="jQuery事件机制"></a><code>jQuery</code>事件机制</h2><ul>
<li>JavaScript中已经学习过了事件，<code>jQuery</code>对JavaScript事件进行了封装，增加并扩展了事件处理机制。<code>jQuery</code>不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。</li>
</ul>
<h3 id="jQuery事件发展历程-了解"><a href="#jQuery事件发展历程-了解" class="headerlink" title="jQuery事件发展历程(了解)"></a><code>jQuery</code>事件发展历程(了解)</h3><p>简单事件绑定–bind事件绑定–delegate事件绑定–on事件绑定(推荐)</p>
<ul>
<li>简单事件注册</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">click(handler)			单击事件<br>mouseenter(handler)		鼠标进入事件<br>mouseleave(handler)		鼠标离开事件<br></code></pre></td></tr></table></figure>

<p>缺点：不能同时注册多个事件</p>
<ul>
<li>bind方式注册事件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一个参数：事件类型</span><br><span class="hljs-comment">// 第二个参数：事件处理程序</span><br>$(<span class="hljs-string">'p'</span>).bind(<span class="hljs-string">'click mouseenter'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 事件响应方法</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>缺点：不支持动态事件绑定</p>
<ul>
<li>delegate注册委托事件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一个参数：selector，要绑定事件的元素</span><br><span class="hljs-comment">// 第二个参数：事件类型</span><br><span class="hljs-comment">// 第三个参数：事件处理函数</span><br>$(<span class="hljs-string">'.parentBox'</span>).delegate(<span class="hljs-string">'p'</span>, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 为 .parentBox下面的所有的p标签绑定事件</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>缺点：只能注册委托事件，因此注册时间需要记得方法太多了</p>
<ul>
<li>on注册事件</li>
</ul>
<h3 id="on注册事件-重点"><a href="#on注册事件-重点" class="headerlink" title="on注册事件(重点)"></a>on注册事件(重点)</h3><ul>
<li><code>jQuery1.7</code>之后，<code>jQuery</code>用on统一了所有事件的处理方法。</li>
<li>最现代的方式，兼容<code>zepto</code>(移动端类似<code>jQuery</code>的一个库)，强烈建议使用。</li>
</ul>
<p>on注册简单事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。</span><br>$(selector).on( <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;);<br></code></pre></td></tr></table></figure>

<p>on注册事件委托</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定</span><br>$(selector).on( <span class="hljs-string">'click'</span>,<span class="hljs-string">'span'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;);<br></code></pre></td></tr></table></figure>

<p>事件委托原理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 事件委托的原理</span><br><span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#ul'</span>);<br>ul.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-comment">// console.log(e.target.tagName);</span><br>  <span class="hljs-keyword">if</span> (e.target.tagName.toLowerCase() === <span class="hljs-string">'li'</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(e.target);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>on注册事件的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）</span><br><span class="hljs-comment">// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。</span><br><span class="hljs-comment">// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）</span><br><span class="hljs-comment">// 第四个参数：handler，事件处理函数</span><br>$(selector).on(events[,selector][,data],handler);<br></code></pre></td></tr></table></figure>

<ul>
<li>通过源码查看 bind click delegate on 注册事件的区别</li>
</ul>
<h3 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h3><ul>
<li>unbind方式（不用）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$(selector).unbind(); <span class="hljs-comment">// 解绑所有的事件</span><br>$(selector).unbind(<span class="hljs-string">'click'</span>); <span class="hljs-comment">// 解绑指定的事件</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>undelegate</code>方式（不用）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$( selector ).undelegate(); <span class="hljs-comment">// 解绑所有的delegate事件</span><br>$( selector).undelegate( <span class="hljs-string">'click'</span> ); <span class="hljs-comment">// 解绑所有的click事件</span><br></code></pre></td></tr></table></figure>

<ul>
<li>off方式（推荐）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 解绑匹配元素的所有事件</span><br>$(selector).off();<br><span class="hljs-comment">// 解绑匹配元素的所有click事件</span><br>$(selector).off(<span class="hljs-string">'click'</span>);<br></code></pre></td></tr></table></figure>

<h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$(selector).click(); <span class="hljs-comment">// 触发 click事件</span><br>$(selector).trigger(<span class="hljs-string">'click'</span>);<br></code></pre></td></tr></table></figure>

<h3 id="jQuery事件对象"><a href="#jQuery事件对象" class="headerlink" title="jQuery事件对象"></a><code>jQuery</code>事件对象</h3><p><code>jQuery</code>事件对象其实就是<code>js</code>事件对象的一个封装，处理了兼容性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// screenX和screenY	对应屏幕最左上角的值</span><br><span class="hljs-comment">// clientX和clientY	距离页面左上角的位置（忽视滚动条）</span><br><span class="hljs-comment">// pageX和pageY	距离页面最顶部的左上角的位置（会计算滚动条的距离）</span><br><br><span class="hljs-comment">// event.keyCode	按下的键盘代码</span><br><span class="hljs-comment">// event.data	存储绑定事件时传递的附加数据</span><br><br><span class="hljs-comment">// event.stopPropagation()	阻止事件冒泡行为</span><br><span class="hljs-comment">// event.preventDefault()	阻止浏览器默认行为</span><br><span class="hljs-comment">// return false:既能阻止事件冒泡，又能阻止浏览器默认行为。</span><br></code></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li>按键变色 [19-按键变色<code>.html</code>]</li>
</ul>
<h2 id="jQuery补充知识点"><a href="#jQuery补充知识点" class="headerlink" title="jQuery补充知识点"></a><code>jQuery</code>补充知识点</h2><h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><ul>
<li>通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 <code>jQuery</code>对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">end(); <span class="hljs-comment">// 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。</span><br></code></pre></td></tr></table></figure>

<h3 id="each方法"><a href="#each方法" class="headerlink" title="each方法"></a>each方法</h3><ul>
<li><code>jQuery</code>的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。</li>
</ul>
<p>作用：遍历<code>jQuery</code>对象集合，为每个匹配的元素执行一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 参数一表示当前元素在所有匹配元素中的索引号</span><br><span class="hljs-comment">// 参数二表示当前元素（DOM对象）</span><br>$(selector).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index,element</span>)</span>&#123;&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h3><ul>
<li><code>jQuery</code>使用$作为标示符，但是如果与其他框架中的$冲突时，<code>jQuery</code>可以释放$符的控制权.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> c = $.noConflict();<span class="hljs-comment">// 释放$的控制权,并且把$的能力给了c</span><br></code></pre></td></tr></table></figure>

<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><ul>
<li>弹出层插件 layer<ul>
<li><a href="https://github.com/sentsin/layer" target="_blank" rel="noopener">layer插件</a></li>
</ul>
</li>
<li>放大镜插件<ul>
<li><a href="http://www.jacklmoore.com/zoom/" target="_blank" rel="noopener">jQuery.zoom</a></li>
</ul>
</li>
<li>轮播图插件<ul>
<li><a href="http://sorgalla.com/jcarousel/" target="_blank" rel="noopener">http://sorgalla.com/jcarousel/</a></li>
<li><a href="https://github.com/OwlCarousel2/OwlCarousel2" target="_blank" rel="noopener">https://github.com/OwlCarousel2/OwlCarousel2</a></li>
</ul>
</li>
<li>图片懒加载插件<ul>
<li><a href="https://github.com/tuupola/jquery_lazyload" target="_blank" rel="noopener">jQuery.lazyload</a></li>
</ul>
</li>
</ul>
<h3 id="自己探索插件"><a href="#自己探索插件" class="headerlink" title="自己探索插件"></a>自己探索插件</h3><ul>
<li><a href="https://github.com/aui/artDialog" target="_blank" rel="noopener">artDialog</a></li>
<li><a href="https://github.com/fat/zoom.js" target="_blank" rel="noopener">图片放大</a></li>
<li><a href="http://www.github.com" target="_blank" rel="noopener">github上搜索</a></li>
</ul>
<h2 id="jQuery插件开发"><a href="#jQuery插件开发" class="headerlink" title="jQuery插件开发"></a><code>jQuery</code>插件开发</h2><ul>
<li>给<code>jQuery</code>增加方法的两种方式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$.method = fn		静态方法<br>$.fn.method = fn	实例方法<br></code></pre></td></tr></table></figure>

<ul>
<li>增加一个静态方法，实现两个数的和，插件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$</span>) </span>&#123;<br>  $.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>&#125;(jQuery))<br><br>$.add(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>tab栏插件 [21-tab栏插件.html]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$</span>) </span>&#123;<br>  <span class="hljs-comment">// &#123;tabMenu: '#aa'&#125;</span><br>  $.tab = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;<br>    <span class="hljs-comment">// 默认参数</span><br>    <span class="hljs-keyword">var</span> defaults = &#123;<br>      <span class="hljs-attr">tabMenu</span>: <span class="hljs-string">'#tab'</span>,<br>      <span class="hljs-attr">activeClass</span>: <span class="hljs-string">'active'</span>,<br>      <span class="hljs-attr">tabMain</span>: <span class="hljs-string">'#tab-main'</span>,<br>      <span class="hljs-attr">tabMainSub</span>: <span class="hljs-string">'.main'</span>,<br>      <span class="hljs-attr">selectedClass</span>: <span class="hljs-string">'selected'</span><br>    &#125;<br>    <span class="hljs-comment">// 把options中的属性，把对应属性的值赋给defaults对应的属性</span><br>    <span class="hljs-comment">// defaults.tabMenu = options.tabMenu || defaults.tabMenu;</span><br>    <span class="hljs-comment">// for(var key in options) &#123;</span><br>    <span class="hljs-comment">//   defaults[key] = options[key];</span><br>    <span class="hljs-comment">// &#125;</span><br>    $.extend(defaults, options);<br><br>    $(defaults.tabMenu).on(<span class="hljs-string">'click'</span>, <span class="hljs-string">'li'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      $(<span class="hljs-keyword">this</span>)<br>        .addClass(defaults.activeClass)<br>        .siblings()<br>        .removeClass(defaults.activeClass);<br><br>      <span class="hljs-comment">//</span><br>      <span class="hljs-keyword">var</span> index = $(<span class="hljs-keyword">this</span>).index();<br>      <span class="hljs-comment">//</span><br>      $(defaults.tabMain + <span class="hljs-string">' '</span> + defaults.tabMainSub)<br>        .eq(index)<br>        .addClass(defaults.selectedClass)<br>        .siblings()<br>        .removeClass(defaults.selectedClass);<br>    &#125;)<br>  &#125;<br>&#125;(<span class="hljs-built_in">window</span>.jQuery))<br></code></pre></td></tr></table></figure>

<ul>
<li>表格插件  [22-表格插件<code>.html</code>]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>) </span>&#123;<br>  <span class="hljs-comment">// 内部的变量，外部无法访问，防止变量名冲突</span><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 给$增加了一个实例方法</span><br>  $.fn.table = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">header, data</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> array = [];<br>    array.push(<span class="hljs-string">'&lt;table&gt;'</span>);<br>    array.push(<span class="hljs-string">'&lt;tr&gt;'</span>);<br><br>    <span class="hljs-comment">// 生成表头</span><br>    $.each(header, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      array.push(<span class="hljs-string">'&lt;th&gt;'</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">'&lt;/th&gt;'</span>);<br>    &#125;)<br>    array.push(<span class="hljs-string">'&lt;/tr&gt;'</span>);<br><br><br>    <span class="hljs-comment">// 生成数据行</span><br>    $.each(data, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>&#123;<br>      <span class="hljs-comment">// this是当前遍历到的数组中的每一个对象</span><br>      <span class="hljs-comment">// 拼数据行</span><br>      array.push(<span class="hljs-string">'&lt;tr&gt;'</span>);<br>      array.push(<span class="hljs-string">'&lt;td&gt;'</span> + (index + <span class="hljs-number">1</span>) + <span class="hljs-string">'&lt;/td&gt;'</span>);<br><br>      <span class="hljs-comment">// 遍历对象，拼表格</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) &#123;<br>        array.push(<span class="hljs-string">'&lt;td&gt;'</span> + <span class="hljs-keyword">this</span>[key] + <span class="hljs-string">'&lt;/td&gt;'</span>);<br>      &#125;<br><br>      array.push(<span class="hljs-string">'&lt;/tr&gt;'</span>);<br>    &#125;)<br>    array.push(<span class="hljs-string">'&lt;/table&gt;'</span>);<br><br>    <span class="hljs-keyword">this</span>.append(array.join(<span class="hljs-string">''</span>));<br>  &#125;<br><br>&#125;(<span class="hljs-built_in">window</span>.jQuery))<br></code></pre></td></tr></table></figure>

<ul>
<li>插件开发的原理</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解析CSS层叠、优先级、继承</title>
    <url>/2020/07/02/7-2%E5%91%A8%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h2><p>对统一元素应用多个规则（样式）时，可能会包含冲突的声明，类似我们通过标签选择器，id选择器，类选择器分别为h1，指定不同字体，那么这个h1最终会采用哪种字体呢。</p>
<p>层叠就这一系列的规则，它决定了当不同选择器为元素设置样式时如何解决冲突。</p>
<a id="more"></a>

<p>层叠会依据三种条件来解决冲突，</p>
<ol>
<li>样式表的来源：样式是从哪里来的，包含我们自己写的样式和浏览器的样式等。</li>
<li>选择器的优先级：在多种选择器中，哪种选择器更重要。</li>
<li>源码的顺序：样式在样式表中出现的顺序。</li>
</ol>
<p>浏览器的默认样式被称作用户代理样式，也就是说让我们不设置样式时，浏览器会自动给元素添加一些样式，它的优先级很低，当我们设置样式时，会覆盖掉浏览器样式。</p>
<h3 id="同时浏览器将优先级分为两部分：HTML的行内样式和选择器样式。"><a href="#同时浏览器将优先级分为两部分：HTML的行内样式和选择器样式。" class="headerlink" title="同时浏览器将优先级分为两部分：HTML的行内样式和选择器样式。"></a>同时浏览器将优先级分为两部分：<strong>HTML的行内样式和选择器样式</strong>。</h3><p>如果使用HTML的style属性写样式，会覆盖掉任何来自样式表的样式</p>
<p>选择器的优先级</p>
<ul>
<li>id选择器的优先级要大于类选择器，那么当我们使用id选择器为h1设置颜色为红色，类选择器设置为黑色，浏览器就会将h1设置为红色，因为id选择器的优先级要高</li>
<li>如果选择器的id选择器更多，比如h1设置了三个id选择器，那么使用两个id选择器的样式会胜出</li>
<li>如果id选择器的数量一致，那么拥有更多类选择器的样式会胜出。</li>
</ul>
<p><strong>如果我们在CSS中写了一个声明，但是没有生效，一般就是被更高的优先级规则覆盖了，所以在大型项目中，通常让优先级尽可能低，这样当我们需要覆盖一些样式时才有更多的选择空间</strong></p>
<p><strong>浏览器遵循三个步骤,即来源、优先级、源码顺序来解析网页上每个元素和每个属性</strong></p>
<p>处理层叠的一些经验</p>
<ol>
<li>尽量不使用ID选择器，就算只使用一个ID也会大幅提高有心计，当需要覆盖这个优先级时，通常找不到另一个有意义的ID</li>
<li>尽量不适用！imporant，它比ID更难覆盖。</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>将CSS的样式声明叫做层叠值，那么当一个元素没有层叠值时，则可能继承某个祖先元素的值，比如通常给<body>加上一个<code>font-family</code>,那么页面中的<code>祖先元素</code>，都会继承这个字体，就不必给页面的每个元素明确指定字体了。</body></p>
<p>不是所有属性都会继承，通常使一些我们希望被继承的属性，它们主要都是与文本相关的属性<code>color</code>、<code>font</code>、<code>font-family</code>、<code>font-size</code>、<code>font-weight</code>、<code>font-variant、font-style、line-height、letter-spacing、text-align、text-indent</code>、<code>text-transform</code>、<code>white-space</code>以及<code>word-spacing</code>。</p>
<p>使用浏览器开发者工具追踪元素样式信息</p>
<img src="/2020/07/02/7-2周记/1.png">

<h2 id="特殊值inherit"><a href="#特殊值inherit" class="headerlink" title="特殊值inherit"></a>特殊值inherit</h2><p>当想要用继承替代一个层叠值便可以使用inherit</p>
<p>当body中设置了a链接的全局颜色时，footer的背景颜色为灰色，我们想要footer中链接的颜色继承自footer那么便可使用inherit</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs css">body a&#123;<br>  color: blue;<br>&#125;<br>footer: &#123;<br>  color: #666;<br>&#125;<br>footer a&#123;<br>  color: inherit; //#666<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>层叠</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>elementUi相关组件实例</title>
    <url>/2020/07/30/7-30%E8%AE%B0elementUi/</url>
    <content><![CDATA[<h1 id="项目中关于ElementUi的记录"><a href="#项目中关于ElementUi的记录" class="headerlink" title="项目中关于ElementUi的记录"></a>项目中关于ElementUi的记录</h1><h2 id="Pagination分页"><a href="#Pagination分页" class="headerlink" title="Pagination分页"></a>Pagination分页</h2><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-pagination</span><br>  <span class="hljs-attr">:page-size</span>=<span class="hljs-string">"20"</span><br>  <span class="hljs-attr">:pager-count</span>=<span class="hljs-string">"11"</span><br>  <span class="hljs-attr">layout</span>=<span class="hljs-string">"prev, pager, next"</span><br>  <span class="hljs-attr">:total</span>=<span class="hljs-string">"total"</span><br>   @<span class="hljs-attr">curtent-change</span>=<span class="hljs-string">"getpageUser"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-pagination</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>后端会获取数据的总条数和page页码</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">getPageUser(Page)&#123;<br>    userlist(&#123;Page&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span>&#123;<br>        <span class="hljs-keyword">this</span>.list = data.userlist<br>        <span class="hljs-keyword">this</span>.total = data.total<br>        <span class="hljs-keyword">this</span>.lsitloading = <span class="hljs-literal">false</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>没有接口时可以在data中先写上假数据以便测试</p>
<h2 id="日期选择器"><a href="#日期选择器" class="headerlink" title="日期选择器"></a>日期选择器</h2><p>设置开始时间和结束时间的默认值为最近一周</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"demonstration"</span>&gt;</span>默认<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-date-picker</span><br>      <span class="hljs-attr">v-model</span>=<span class="hljs-string">"value1"</span><br>      <span class="hljs-attr">type</span>=<span class="hljs-string">"daterange"</span><br>      <span class="hljs-attr">range-separator</span>=<span class="hljs-string">"至"</span><br>      <span class="hljs-attr">start-placeholder</span>=<span class="hljs-string">"开始日期"</span><br>      <span class="hljs-attr">end-placeholder</span>=<span class="hljs-string">"结束日期"</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-date-picker</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><span class="hljs-keyword">const</span> endDate = parseTime(now, <span class="hljs-string">'&#123;y&#125;-&#123;m&#125;-&#123;d&#125;'</span>)<br><span class="hljs-keyword">const</span> lastWeek = parseTime((<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>),<span class="hljs-string">'&#123;y&#125;-&#123;m&#125;-&#123;d&#125;'</span>)<br><span class="hljs-comment">//value1可以接收数组，当开始日期和结束日期都需要设置是传入个数组</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    data()&#123;<br>        <span class="hljs-attr">value</span>:[lastWeek,endDate]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>使用过滤器格式化时间</strong></p>
<h2 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h2><figure class="highlight html"><figcaption><span>+ javascrit</span></figcaption><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"account"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"svg-container"</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">svg-icon</span> <span class="hljs-attr">icon-class</span>=<span class="hljs-string">"user"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"account"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"loginForm.account"</span> <span class="hljs-attr">:maxlength</span>=<span class="hljs-string">"12"</span><span class="hljs-attr">name</span>=<span class="hljs-string">"account"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"用户名"</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">"on"</span> /&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">"password"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"svg-container"</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">svg-icon</span> <span class="hljs-attr">icon-class</span>=<span class="hljs-string">"password"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"passwordType"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"loginForm.password"</span> <span class="hljs-attr">:maxlength</span>=<span class="hljs-string">"16"</span> <span class="hljs-attr">:type</span>=<span class="hljs-string">"passwordType"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"密码"</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">"on"</span> @<span class="hljs-attr">keyup.enter.native</span>=<span class="hljs-string">"handleLogin"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"show-pwd"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"showPwd"</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">svg-icon</span> <span class="hljs-attr">:icon-class</span>=<span class="hljs-string">"passwordType=='password'?'eye':'eye-open'"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">:loading</span>=<span class="hljs-string">"loading"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width:100%"</span> @<span class="hljs-attr">click.native.prevent</span>=<span class="hljs-string">"handleLogin"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    data() &#123;<br>        <span class="hljs-keyword">const</span> validateAccount = <span class="hljs-function">(<span class="hljs-params">rule, value, callback</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (!validAccount(value)) &#123;<br>        callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'用户名应为3~16位字符'</span>))<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        callback()<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> validatePassword = <span class="hljs-function">(<span class="hljs-params">rule, value, callback</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (!validPassword(value)) &#123;<br>        callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'密码应为6~16位字符'</span>))<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        callback()<br>      &#125;<br>    &#125;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">labelPosition</span>: <span class="hljs-string">'right'</span>,<br>         <span class="hljs-attr">formLabelAlign</span>: &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>,<br>          <span class="hljs-attr">region</span>: <span class="hljs-string">''</span>,<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">''</span><br>        &#125;,<br>          <span class="hljs-comment">//trigger:'blur'当失去焦点时触发</span><br>      <span class="hljs-attr">loginRules</span>: &#123;<br>        <span class="hljs-attr">account</span>: [&#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>, <span class="hljs-attr">validator</span>: validateAccount &#125;],<br>        <span class="hljs-attr">password</span>: [&#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">'blur'</span>, <span class="hljs-attr">validator</span>: validatePassword &#125;]<br>      &#125;,<br>      &#125;;<br>    &#125;<br>  &#125;<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol>
<li>表单中 :model=”form”—&gt;表单数据对像</li>
<li>需要传入表单data和rule验证规则</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue-elementUi</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>组件库</tag>
      </tags>
  </entry>
  <entry>
    <title>7-31记</title>
    <url>/2020/07/31/7-31%E8%AE%B0/</url>
    <content><![CDATA[<p>模板字符串</p>
<p>数据库中返回的是纯数字模式的时间，例如下午四点，数据库中存储的为16，下午六点，数据库中储存的为18，</p>
<p>要求是我们需要将16展示为16：00-16：59的时间段</p>
<p>在elementUi的表格中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"姓名"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"180"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">"&#123;row&#125;"</span>&gt;</span>&#123;&#123; `$(row.hour):00 - $(row.hour):59` &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span><br></code></pre></td></tr></table></figure>

<a id="more"></a>

<ol>
<li><p>解构赋值</p>
<p>对象的解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123;foo, bar&#125; = &#123;<span class="hljs-attr">foo</span>: <span class="hljs-string">'aaa'</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">'bbb'</span>&#125;<br>foo <span class="hljs-comment">// 'aaa'</span><br>bar <span class="hljs-comment">// 'bbb'</span><br></code></pre></td></tr></table></figure>

<p>对像的属性没有次序，变量必须与属性同名，才能正确的值</p>
<ol start="3">
<li>JSON.stringify({x:5,y:6}) //{‘x’:’5’,”y”,’6’}</li>
<li>JSON.parse(json)//解析json转为js值或对象</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>组件库</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>7-7记</title>
    <url>/2020/07/07/7-7%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="rem布局"><a href="#rem布局" class="headerlink" title="rem布局"></a>rem布局</h3><p>新建rem.js文件创建自定义函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resize</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> baseFontSize = <span class="hljs-number">100</span>  <span class="hljs-comment">//设计稿100px相当于1rem</span><br>        <span class="hljs-keyword">var</span> designWidth = <span class="hljs-number">750</span>;<span class="hljs-comment">//设计稿宽度</span><br>        <span class="hljs-keyword">var</span> width = <span class="hljs-built_in">window</span>.innerWidth;<span class="hljs-comment">//屏幕宽度</span><br>        <span class="hljs-keyword">var</span> currentFontSize = (width/designWidth) * <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'html'</span>).style.fontSize = currentFontSize + <span class="hljs-string">'px'</span><br>    &#125;<br><br><br><br><br>    <span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        resize()<br>    &#125;<br>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>,resize)<br>&#125;())<br></code></pre></td></tr></table></figure>

<h3 id="关于mockjs的使用"><a href="#关于mockjs的使用" class="headerlink" title="关于mockjs的使用"></a>关于mockjs的使用</h3><p>当我们没有得到从后端传递来的数据时，可以在了解数据的类型之后，通过Mockjs在前端进行模拟数据的获取。</p>
<p>首先安装Mockjs</p>
<p>在api文件夹下新建数据文件夹（ServerData）在文件夹下创建数据文件position.js</p>
<p>在mockjs文件中首先导入Mockjs</p>
<p>导入postion文件</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-selector-tag">Mock</span><span class="hljs-selector-class">.mock</span>(<span class="hljs-string">'/api/posi'</span>,position)<br></code></pre></td></tr></table></figure>

<p>此时我们获取数据的接口为</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">export</span> const getPosiData = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> axios.request(&#123;<br> url:<span class="hljs-string">'posi'</span>,<br> method:<span class="hljs-string">'get'</span><br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>rem</category>
      </categories>
      <tags>
        <tag>模拟数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Date函数</title>
    <url>/2020/08/17/8-17Date%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="JS日期"><a href="#JS日期" class="headerlink" title="JS日期"></a>JS日期</h1><h2 id="关于创建时间对象"><a href="#关于创建时间对象" class="headerlink" title="关于创建时间对象"></a>关于创建时间对象</h2><h3 id="创建日期对象的四种方法"><a href="#创建日期对象的四种方法" class="headerlink" title="创建日期对象的四种方法"></a>创建日期对象的四种方法</h3><p><code>new Date()</code></p>
<p><code>new Date(year, month,day, hours, minutes, seconds, milliseconds)</code></p>
<p><code>new Date(milliseconds)</code></p>
<p><code>new Date(date string)</code></p>
<p>1、不传参数创建日期</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-comment">//Mon Aug 17 2020 17:47:35 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure>

<p>2、加入年月日等参数</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2020</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>);<span class="hljs-comment">//Fri Dec 11 2020 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="hljs-comment">//为日期指定内容</span><br></code></pre></td></tr></table></figure>

<p>注：<strong>对于月份来说一月的索引为0，12月为11</strong></p>
<p>所以我们在获取月份时也要注意+1才是正确的我们所说的月份</p>
<p>3、如果只传入一个参数，则按照毫秒为参数添加进函数,将返回一个按照零时加上毫秒数的新的日期对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>JavaScript 将日期存储为自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。</p>
<p>零时间是 1970 年 1 月 1 日 00:00:00 UTC。</p>
<p>4、传入时间字符串会返回一个新的日期对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"October 13, 2014 11:13:00"</span>);<br></code></pre></td></tr></table></figure>

<h3 id="日期的获取方法"><a href="#日期的获取方法" class="headerlink" title="日期的获取方法"></a>日期的获取方法</h3><img src="/2020/08/17/8-17Date函数/2.png">

<h3 id="关于-new-Date"><a href="#关于-new-Date" class="headerlink" title="关于+new Date()"></a>关于+new Date()</h3><p>这个操作是将日期函数转换类型</p>
<img src="/2020/08/17/8-17Date函数/1.png">

<p>以毫秒显示</p>
<p>对时间进行格式化,后端提供以秒为单位的时间数据</p>
<p>将其转换为00:00:00（小时：分钟：秒），并且位数为一位数时，进行补0，避免出现3:20这样的时间应该显示为03:20。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">formateTime(seconds) &#123;<br>      <span class="hljs-keyword">if</span> (seconds &lt; <span class="hljs-number">60</span>) &#123;<br>        <span class="hljs-keyword">return</span> seconds.toString().padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (seconds &lt; <span class="hljs-number">3600</span>) &#123;<br>        <span class="hljs-keyword">const</span> m = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>(seconds / <span class="hljs-number">60</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>        <span class="hljs-keyword">const</span> s = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>(seconds % <span class="hljs-number">60</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;m&#125;</span>:<span class="hljs-subst">$&#123;s&#125;</span>`</span><br>      &#125;<br>      <span class="hljs-keyword">const</span> h = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>(seconds / <span class="hljs-number">3600</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>      <span class="hljs-keyword">const</span> m = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>((seconds % <span class="hljs-number">3600</span>) / <span class="hljs-number">60</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>      <span class="hljs-keyword">const</span> s = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>((seconds % <span class="hljs-number">3600</span>) % <span class="hljs-number">60</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;h&#125;</span>:<span class="hljs-subst">$&#123;m&#125;</span>:<span class="hljs-subst">$&#123;s&#125;</span>`</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="时间戳转换"><a href="#时间戳转换" class="headerlink" title="时间戳转换"></a>时间戳转换</h3><p>new Date(1598338225474)，如果是秒为单位需要乘1000</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Date对象</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器Iterator</title>
    <url>/2020/08/26/8-26%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator/</url>
    <content><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署Iterator接口，就可以完成遍历操作。</p>
<p>1、ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of循环使用</p>
<p>2、原生具备Iterator接口的数据可使用for of遍历</p>
<a id="more"></a>

<p>生成一个数组使用for…of遍历</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>       <span class="hljs-keyword">const</span> Arr = [<span class="hljs-string">'唐僧'</span>, <span class="hljs-string">'猪八戒'</span>, <span class="hljs-string">'孙悟空'</span>, <span class="hljs-string">'沙僧'</span>]<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> Arr) &#123;<br>           <span class="hljs-built_in">console</span>.log(i)<span class="hljs-comment">//唐僧 猪八戒 孙悟空 沙僧</span><br>       &#125;<br>   &lt;<span class="hljs-regexp">/script&gt;</span><br></code></pre></td></tr></table></figure>

<p>生成一个数组使用for…in遍历</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Arr = [<span class="hljs-string">'唐僧'</span>, <span class="hljs-string">'猪八戒'</span>, <span class="hljs-string">'孙悟空'</span>, <span class="hljs-string">'沙僧'</span>]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> Arr) &#123;<br>            <span class="hljs-built_in">console</span>.log(i)<br>        &#125;<br></code></pre></td></tr></table></figure>

<img src="/2020/08/26/8-26迭代器Iterator/2.png">

<p><strong>for in循环保存的是键名，而for of保存的是键值</strong></p>
<h2 id="谁可以使用"><a href="#谁可以使用" class="headerlink" title="谁可以使用"></a>谁可以使用</h2><p>可以看到在该数组的方法中有一个<code>Symbol(Symbol.iterator)</code>方法</p>
<img src="/2020/08/26/8-26迭代器Iterator/3.png">

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> iterator = Arr[<span class="hljs-built_in">Symbol</span>.iterator]()<br>        <span class="hljs-built_in">console</span>.log(iterator)<br></code></pre></td></tr></table></figure>

{% asset_img 4.png %}

<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol>
<li>创建一个指针对象，指向当前数据结构的起始位置</li>
<li>第一次调用对象<code>next</code>方法，指针自动指向数据结构的第一个成员</li>
<li>接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员</li>
<li>每调用next方法返回一个包含value和done属性的对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Arr = [<span class="hljs-string">'唐僧'</span>, <span class="hljs-string">'猪八戒'</span>, <span class="hljs-string">'孙悟空'</span>, <span class="hljs-string">'沙僧'</span>]<br>        <span class="hljs-keyword">let</span> iterator = Arr[<span class="hljs-built_in">Symbol</span>.iterator]()<br>        <span class="hljs-built_in">console</span>.log(iterator.next())<br>        <span class="hljs-built_in">console</span>.log(iterator.next())<br>        <span class="hljs-built_in">console</span>.log(iterator.next())<br>        <span class="hljs-built_in">console</span>.log(iterator.next())<br>        <span class="hljs-built_in">console</span>.log(iterator.next())<br></code></pre></td></tr></table></figure>

<img src="/2020/08/26/8-26迭代器Iterator/5.png">

<p>当<code>done</code>为true时，表示循环已经完成</p>
<h2 id="自定义遍历数据"><a href="#自定义遍历数据" class="headerlink" title="自定义遍历数据"></a>自定义遍历数据</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> banji = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">"终极一班"</span>,<br>        <span class="hljs-attr">stus</span>: [<br>            <span class="hljs-string">'xiaoming'</span>,<br>            <span class="hljs-string">'xiaobai'</span>,<br>            <span class="hljs-string">'xiaohei'</span>,<br>            <span class="hljs-string">'xiaoli'</span>,<br>            <span class="hljs-string">'xiaoning'</span><br>        ],<br>        [<span class="hljs-built_in">Symbol</span>.iterator]()&#123;<br>            <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>                    <span class="hljs-keyword">if</span>(index&lt; <span class="hljs-keyword">this</span>.stus.length)&#123;<br>                        <span class="hljs-keyword">const</span> result = &#123;<span class="hljs-attr">value</span>: <span class="hljs-keyword">this</span>.stus[index], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br>                        index++<br>                        <span class="hljs-keyword">return</span> result<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;<br>                    &#125;<br>                    <br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> banji) &#123;<br>        <span class="hljs-built_in">console</span>.log(v)<br>    &#125;<br><span class="hljs-comment">//其中的if判断可以优化</span><br><span class="hljs-comment">//优化</span><br>       index &lt; <span class="hljs-keyword">this</span>.stus.length ? <br>       &#123;<span class="hljs-attr">value</span>: <span class="hljs-keyword">this</span>.stus[index++], <span class="hljs-attr">done</span>:<span class="hljs-literal">false</span>&#125; : <br>       &#123;<span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;<br><span class="hljs-comment">//再优化</span><br><span class="hljs-keyword">let</span> _this = <span class="hljs-keyword">this</span><br><span class="hljs-keyword">return</span> index &lt; _this.stus.length ?<br>&#123;<span class="hljs-attr">value</span>: _this.stus[index++]&#125; :<br>&#123;<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>记this的指向</title>
    <url>/2020/08/01/8-1%E8%AE%B0this%E7%9A%84%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p>this的指向在函数的定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，所以this的最终指向的是调用它的对象（理论上）</p>
<p>第一个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">app</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> user = <span class="hljs-string">"bpp"</span>; <br>    <span class="hljs-built_in">console</span>.log(user);<span class="hljs-comment">//undefined</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//window</span><br>&#125;<br>app()在全局作用域<span class="hljs-built_in">window</span>中调用app()<br></code></pre></td></tr></table></figure>

<p>此时this最终指向的是调用它的对象window，相当于<code>window.app()</code></p>
<a id="more"></a>

<p>第二个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> temp = &#123;<br>    <span class="hljs-attr">user</span>: <span class="hljs-string">'name'</span>,<br>    <span class="hljs-attr">fn</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.user);<span class="hljs-comment">//name</span><br>    &#125;<br>&#125;<br>temp.fn()<br></code></pre></td></tr></table></figure>

<p>此时因为是对象temp调用了fn，所以this指向它的调用者temp</p>
<p>例子三证明了我们的this指向它的调用者是一个理论上的说法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> temp = &#123;<br>    <span class="hljs-attr">user</span>: <span class="hljs-string">'name'</span>,<br>    <span class="hljs-attr">fn</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.user);<span class="hljs-comment">//name</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">window</span>.temp.fn()<br></code></pre></td></tr></table></figure>

<p><strong>通过window调用发现this没有指向window</strong></p>
<p>例子四</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs undefined">var <span class="hljs-keyword">temp</span> = &#123;<br><span class="hljs-keyword">user</span>:<span class="hljs-string">'yy'</span><br>temp2：&#123;<br> <span class="hljs-keyword">user</span>: <span class="hljs-string">'name'</span>,<br>    fn:<span class="hljs-keyword">function</span>()&#123;<br>        console.log(this.<span class="hljs-keyword">user</span>);//<span class="hljs-type">name</span><br>  &#125;<br> &#125;  <br>&#125;<br><span class="hljs-keyword">temp</span>.temp2.fn()<br></code></pre></td></tr></table></figure>

<p>这里的temp2是通过temp点出来的，this同样没有指向它说明</p>
<ol>
<li>如果一个函数中有this没有通过上一级对象调用，那么它指向window</li>
<li>如果有上一级对象调用，那么this指向它的上一级对象</li>
<li>如果这个函数被多个对象嵌套，那么尽管这个函数被最外层的对象调用，this也指向它的上一级对象。</li>
</ol>
<p><strong>特殊情况</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> temp1 = &#123;<br>    <span class="hljs-attr">b</span>:&#123;<br>        a = <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">fn</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a);<span class="hljs-comment">//undefined</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//window</span><br>  &#125;<br>   &#125;<br>  <br>&#125;<br><span class="hljs-keyword">var</span> j = temp1.b.fn;<br>j()<br></code></pre></td></tr></table></figure>

<p>此时的this没有指向最后调用它的b，因为在fn赋值给变量j的时候函数并没有运行，最终指向的是window</p>
<p>构造函数的this</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">this</span>.user= <span class="hljs-string">"aaa"</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.log(a.user);<span class="hljs-comment">//aaa</span><br></code></pre></td></tr></table></figure>

<p>这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a，为什么我说a是对象，因为用了new关键字就是创建一个对象实例，理解这句话可以想想我们的例子3，我们这里用变量a创建了一个Fn的实例（相当于复制了一份Fn到对象a里面），此时仅仅只是创建，并没有执行，而调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象a中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。</p>
<p>　　除了上面的这些以外，我们还可以自行改变this的指向，关于自行改变this的指向请看<a href="http://www.cnblogs.com/pssp/p/5215621.html" target="_blank" rel="noopener">JavaScript中call,apply,bind方法的总结</a>这篇文章，详细的说明了我们如何手动更改this的指向。</p>
<p>当this碰到return时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">this</span>.uer=<span class="hljs-string">"aaa"</span>;<br>    <span class="hljs-keyword">return</span> &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.log(a.user); <span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)  <br></span>&#123;  <br>    <span class="hljs-keyword">this</span>.user = <span class="hljs-string">'aaaa'</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn;  <br><span class="hljs-built_in">console</span>.log(a.user); <span class="hljs-comment">//aaaa</span><br></code></pre></td></tr></table></figure>

<p><strong>如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</strong></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在严格模式中默认的this不再时window，而是undefined</p>
<p>new操作符会改变this的指向问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">this</span>.user= <span class="hljs-string">"aaa"</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.log(a.user);<span class="hljs-comment">//aaa</span><br></code></pre></td></tr></table></figure>

<p>为什么this会指向a？首先new关键字会创建一个空的对象，然后会自动调用一个函数（比如apply）方法，将this指向这个空对象，这样的化函数内部的this就会被这个空的对象替代</p>
<h2 id="Vue中的this"><a href="#Vue中的this" class="headerlink" title="Vue中的this"></a>Vue中的this</h2><p>我们可以看到在vue的组件中，我们调用了某个ui组件，使用的使用都会用到this，并且在获取数据的时候也会用到this</p>
<img src="/2020/08/01/8-1记this的指向/1.png">

<p>获取用户列表数据</p>
<img src="/2020/08/01/8-1记this的指向/2.png">

<p>使用elementui框架的弹框组件</p>
<p>Vue中的this指向当前组件的实例</p>
<p>使用箭头函数没有自己的this，所以指向组件当前的实例</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2020/08/27/8-27Promise/</url>
    <content><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise 是异步编程的解决方案，比传统的解决方案–回调函数和事件–更合理和强大。</p>
<h2 id="回调异步"><a href="#回调异步" class="headerlink" title="回调异步"></a>回调异步</h2><p>在JS中的异步处理，第一时间想到的就是利用回调函数</p>
<a id="more"></a>

<p>通过回调实现x+y运算</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//利用回调函数的异步处理</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">getX, getY, cb</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x, y;<br>  getX(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xVal</span>)</span>&#123;<br>    x = xVal;<br>    <span class="hljs-comment">//去判断是否有值</span><br>    <span class="hljs-keyword">if</span>(y != <span class="hljs-literal">undefined</span>) &#123;<br>      cb(x + y);<br>    &#125;<br>  &#125;);<br>  getY(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">yVal</span>)</span>&#123;<br>    y = yVal;<br>    <span class="hljs-comment">//去判断是否有值</span><br>    <span class="hljs-keyword">if</span>(x != <span class="hljs-literal">undefined</span>) &#123;<br>      cb(x + y);<br>    &#125;<br>  &#125;);<br>&#125;<br>add(fetchX, fetchY, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sum</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(sum)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>我们将x和y作为未来值，进行了一个运算add()</p>
<p>回调多了会出现层层嵌套，可读性变差，调试困难</p>
<p>一旦有所松动就会牵一发而动全身</p>
<p>当回调函数嵌套过多时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">doA(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  doB();<br>  doC(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    doD();<br>  &#125;)<br>  doE()<br>&#125;)<br>doF()<br></code></pre></td></tr></table></figure>

<p>尽管你能够正确的确定实际的运行顺序，但是，这一眼看上去确实比较复杂</p>
<p>实际的运行顺序</p>
<ul>
<li>doA()</li>
<li>doF()</li>
<li>doB()</li>
<li>doC()</li>
<li>doE()</li>
<li>doD()</li>
</ul>
<p>这还只是简易模式，真正的异步JavaScript程序代码要混乱的多，使这种追踪难度成倍增加</p>
<p>回调的函数优美度不足，同时缺少信任度</p>
<p>尽管我们的大脑能够以顺序的方式（这个，然后这个，然后这个）计划一系列任务，但大脑运作的事件化的本质使得控制流的恢复/重试/复制几乎不费什么力气。如果你出外办事的时候发现把购物清单落在了家里，那么这一天并不会因为你没有预知到这一点就成为世界末日了。你的大脑很容易就能针对这个小意外做出计划：回家拿清单，然后立刻返回商店就是了。</p>
<p>但是，手工硬编码（即使包含了硬编码的出错处理）回调的脆弱本性可就远没有这么优雅了。一旦你指定（也就是预先计划）了所有的可能事件和路径，代码就会变得非常复杂，以至于无法维护和更新。这才是回调地狱的真正问题所在！嵌套和缩进基本上只是转移注意力的枝节而已。</p>
<p>用Promise实现x+y</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">xPromise, yPromise</span>) </span>&#123;<br>  <span class="hljs-comment">//.all方法接受一个promise数组并返回一个新的promise，这个新的promise等待数组中的所有promise完成</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all([xPromise, yPromise])<br>  <span class="hljs-comment">//promise决议之后，将取得x和y的值并加在一起</span><br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;<br>    <span class="hljs-comment">//value是来自于之前决议的promise的数组</span><br>    <span class="hljs-keyword">return</span> values[<span class="hljs-number">0</span>] + value[<span class="hljs-number">1</span>]<br>  &#125;)<br>&#125;<br>add(fetchX(), fetchY())<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sum</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(sum)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><code>Promise</code>将类似的异步处理对象和处理规则规范化，并按照统一的接口编写，采取了规定之外的写法会报错</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">//待处理的异步逻辑</span><br>  <span class="hljs-comment">//处理结束后，调用resolve或者reject方法</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>promise实例有三种状态：</p>
<ol>
<li>pending：初始状态，位履行或者拒绝</li>
<li>fulfilled： 意味着操作成功完成</li>
<li>rejected： 操作失败</li>
</ol>
<p>当promise从pending状态进行决议转为fulfilled或者出现某种异常信息导致转为reject，当其中任一一种情况出现时，Promise对象的then方法绑定的处理方法（handles）就会被调用，<code>then</code>方法分别指定成功与失败状态的<code>resolve</code>方法和<code>reject</code>方法的回调函数</p>
<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>   fs.readFile(<span class="hljs-string">'./hello.md'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">er,data</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span>(err)&#123;<br>        reject(err)<span class="hljs-comment">//如果请求失败状态转为rejected</span><br>      &#125;<br>     resolve(data)<span class="hljs-comment">//如果请求成功状态转为fulfilled</span><br>   &#125;)<br>&#125;)<br><span class="hljs-comment">//promise状态确定时调用then方法,包含两种状态的回调函数</span><br>p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(value.data)<span class="hljs-comment">//第一个函数为成功时的回调</span><br>&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'读取失败'</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>使用Promise封装ajax</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> getJSON = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.readyState !== <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-number">200</span>) &#123;<br>        resolve(<span class="hljs-keyword">this</span>.response);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-keyword">this</span>.statusText));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    client.open(<span class="hljs-string">"GET"</span>, url);<br>    client.onreadystatechange = handler;<br>    client.responseType = <span class="hljs-string">"json"</span>;<br>    client.setRequestHeader(<span class="hljs-string">"Accept"</span>, <span class="hljs-string">"application/json"</span>);<br>    client.send();<br><br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> promise;<br>&#125;;<br><br>getJSON(<span class="hljs-string">"/posts.json"</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Contents: '</span> + json);<br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'出错了'</span>, error);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  resolve(p1);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>p1与p2都是Promise的实例，但是p2的resolve方法将作为p1的参数，如果调用的时候p1的状态时pending，那么p2的回调函数就会等待p1的状态的改变，如果p1的状态已经确定那么p2的回调函数就会立刻执行。</p>
<h2 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h2><p>Promise可以使用链式操作的原因是因为Promise.prototype.then方法返回的是一个新的Promise对象，因此可以采用链式写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">getJSON(<span class="hljs-string">'1.json'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> json.name<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-comment">//proceed</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>上述代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<h2 id="关于async函数"><a href="#关于async函数" class="headerlink" title="关于async函数"></a>关于async函数</h2><p>只要函数名之前加上async关键字，就表明该函数内部有异步操作。该异步操作应该返回一个Promise对象，前面用await关键字注明。当函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStockPrice</span>(<span class="hljs-params">symbol, currency</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> price = <span class="hljs-keyword">await</span> getStockPrice(symbol);<br>    <span class="hljs-keyword">return</span> convert(price, currency);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数将返回一个Promise对象。调用该函数时，当遇到await关键字，立即返回它后面的表达式（getStockPrice函数）产生的Promise对象，不再执行函数体内后面的语句。等到getStockPrice完成，再自动回到函数体内，执行剩下的语句。</p>
<p>另一个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    setTimeout(resolve, ms);<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncValue</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> timeout(<span class="hljs-number">50</span>);<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中，asyncvalue函数前面有async关键字，表明函数体内有异步操作。执行的时候，遇到await语句就会先返回，等到timeout函数执行完毕再喊回value</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax</title>
    <url>/2019/08/02/Ajax/</url>
    <content><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>Ajax = Asynchronous JavaScript and XML（异步的JavaScript和XML）</p>
<p>在浏览器中，我们可以在不刷新页面的情况下，通过ajax的方式去获取一些新的内容</p>
<a id="more"></a>

<h2 id="发送Ajax请求的五个步骤"><a href="#发送Ajax请求的五个步骤" class="headerlink" title="发送Ajax请求的五个步骤"></a>发送Ajax请求的五个步骤</h2><ul>
<li>创建异步对象。即XMLHttpRequest对象。</li>
<li>使用open方法设置请求的参数。open(method,url,async)</li>
<li>发送请求</li>
<li>注册事件。注册onreadystatechange事件，状态改变时就会调用。</li>
<li>获取返回的数据</li>
</ul>
<h2 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方法：ajax get 五部曲</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax_get</span>(<span class="hljs-params">url,data</span>) </span>&#123;<br>	<span class="hljs-comment">// 异步对象</span><br>	<span class="hljs-keyword">var</span> ajax = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><br>	<span class="hljs-comment">// url 方法</span><br>	<span class="hljs-comment">// 如果是get发送数据 发送的格式为 xxx.php?name=jack&amp;age=18</span><br>	<span class="hljs-comment">// 所以 这里 需要拼接 url</span><br>	<span class="hljs-keyword">if</span> (data) &#123;<br>		<span class="hljs-comment">// 如果有值 需要拼接字符串</span><br>		<span class="hljs-comment">// 拼接为xxx.php?name=jack&amp;age=18</span><br>		url+=<span class="hljs-string">'?'</span>;<br>		url+=data;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>	&#125;<br><br>	ajax.open(<span class="hljs-string">'get'</span>,url);<br>	<span class="hljs-comment">// 发送</span><br>	ajax.send();<br><br>	<span class="hljs-comment">// 注册事件</span><br>	ajax.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>		<span class="hljs-comment">// 在事件中 获取数据 并修改界面显示</span><br>		<span class="hljs-keyword">if</span> (ajax.readyState==<span class="hljs-number">4</span>&amp;&amp; ajax.status==<span class="hljs-number">200</span>) &#123;<br>			<span class="hljs-built_in">console</span>.log(ajax.responseText);<br>		&#125;<br>	&#125;<br>&#125;<br><br><br><span class="hljs-comment">// 方法：ajax_post五部曲</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax_post</span>(<span class="hljs-params">url,data</span>) </span>&#123;<br>	<span class="hljs-comment">// 异步对象</span><br>	<span class="hljs-keyword">var</span> ajax = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><br>	<span class="hljs-comment">// url 方法</span><br>	ajax.open(<span class="hljs-string">'post'</span>,url);<br><br>	<span class="hljs-comment">// 设置 请求报文</span><br>	ajax.setRequestHeader(<span class="hljs-string">"Content-type"</span>,<span class="hljs-string">"application/x-www-form-urlencoded"</span>);<br><br>	<span class="hljs-comment">// 发送</span><br>	<span class="hljs-keyword">if</span> (data) &#123;<br>		<span class="hljs-comment">// 如果 有值 post请求 是在 send中 发送给服务器</span><br>		ajax.send(data);<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		ajax.send();<br>	&#125;<br><br><br>	<span class="hljs-comment">// 注册事件</span><br>	ajax.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>		<span class="hljs-comment">// 在事件中 获取数据 并修改界面显示</span><br>		<span class="hljs-keyword">if</span> (ajax.readyState==<span class="hljs-number">4</span>&amp;&amp;ajax.status==<span class="hljs-number">200</span>) &#123;<br>			<span class="hljs-built_in">console</span>.log(ajax.responseText);<br>		&#125;<br>	&#125;<br><br>&#125;<br><br><br><span class="hljs-comment">// 方法：将 get 跟post 封装到一起</span><br><span class="hljs-comment">/*<br>	参数1:url<br>	参数2:数据<br>	参数3:请求的方法<br>	参数4:数据成功获取以后，调用的方法<br>*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax_tool</span>(<span class="hljs-params">url,data,method,success</span>) </span>&#123;<br>	<span class="hljs-comment">// 异步对象</span><br>	<span class="hljs-keyword">var</span> ajax = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><br>	<span class="hljs-comment">// get 跟post  需要分别写不同的代码</span><br>	<span class="hljs-keyword">if</span> (method==<span class="hljs-string">'get'</span>) &#123;<br>		<span class="hljs-comment">// get请求</span><br>		<span class="hljs-keyword">if</span> (data) &#123;<br>			<span class="hljs-comment">// 如果有值</span><br>			url+=<span class="hljs-string">'?'</span>;<br>			url+=data;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br><br>		&#125;<br>		<span class="hljs-comment">// 设置 方法 以及 url</span><br>		ajax.open(method,url);<br><br>		<span class="hljs-comment">// send即可</span><br>		ajax.send();<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-comment">// post请求</span><br>		<span class="hljs-comment">// post请求 url 是不需要改变</span><br>		ajax.open(method,url);<br><br>		<span class="hljs-comment">// 需要设置请求报文</span><br>		ajax.setRequestHeader(<span class="hljs-string">"Content-type"</span>,<span class="hljs-string">"application/x-www-form-urlencoded"</span>);<br><br>		<span class="hljs-comment">// 判断data send发送数据</span><br>		<span class="hljs-keyword">if</span> (data) &#123;<br>			<span class="hljs-comment">// 如果有值 从send发送</span><br>			ajax.send(data);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-comment">// 木有值 直接发送即可</span><br>			ajax.send();<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// 注册事件</span><br>	ajax.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>		<span class="hljs-comment">// 在事件中 获取数据 并修改界面显示</span><br>		<span class="hljs-keyword">if</span> (ajax.readyState==<span class="hljs-number">4</span>&amp;&amp;ajax.status==<span class="hljs-number">200</span>) &#123;<br>			<span class="hljs-comment">// console.log(ajax.responseText);</span><br><br>			<span class="hljs-comment">// 将 数据 让 外面可以使用</span><br>			<span class="hljs-comment">// return ajax.responseText;</span><br><br>			<span class="hljs-comment">// 当 onreadystatechange 调用时 说明 数据回来了</span><br>			<span class="hljs-comment">// ajax.responseText;</span><br><br>			<span class="hljs-comment">// 数据成功获取以后，执行方法success()。</span><br>			<span class="hljs-comment">//我们把获取的数据作为 success()的参数，意思是：</span><br>			<span class="hljs-comment">//success方法是外面的，数据是里面给的。那数据就变相地传递到了外面去【重要】</span><br>			success(ajax.responseText);<br>		&#125;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>bootstrap</title>
    <url>/2019/08/27/8-27bootstrap/</url>
    <content><![CDATA[<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><h2 id="Bootstrap-是最受欢迎的-HTML、CSS-和-JS-框架，用于开发响应式布局、移动设备优先的-WEB-项目。"><a href="#Bootstrap-是最受欢迎的-HTML、CSS-和-JS-框架，用于开发响应式布局、移动设备优先的-WEB-项目。" class="headerlink" title="Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。"></a>Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。</h2><a id="more"></a>

<p><strong>Bootstrap插件 全部依赖JQuery，因此JQuery必须在Bootstrap之前引入，这是一个基本模板</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Bootstrap 101 Template<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Bootstrap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;</span><br>    <span class="hljs-comment">&lt;!--[if lt IE 9]&gt;<br>      &lt;script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"&gt;&lt;/script&gt;<br>      &lt;script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"&gt;&lt;/script&gt;<br>    &lt;![endif]--&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>你好，世界！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol>
<li><p>Compatible</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span><br>//设置浏览器的兼容模式版本。表示如果在IE浏览器下则使用最新的标准渲染当前文档<br></code></pre></td></tr></table></figure>
</li>
<li><p>viewport视口：为了确保适当的绘制和触屏缩放</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span>&gt;</span><br>//声明当前网页在移动端浏览器中展示的相关设置。视口的作用：在移动浏览器中，当页面宽度超出设备，浏览器内部虚拟的一个页面容器，将页面容器缩放到设备这么大，然后展示<br></code></pre></td></tr></table></figure>

<p>属性解释：</p>
<ul>
<li>width:设置viewport的宽度。</li>
<li>initial-scale:初始化缩放比例。</li>
<li>minimum-scale：最小缩放比例。</li>
<li>maximum-scale：最大缩放比例。</li>
<li>user-scalable：是否允许用户手动缩放（yes/no,也可以写成1/0）</li>
</ul>
<p><strong>如果设置了不允许用户手动缩放，那么最小缩放和最大缩放就没有意义了。</strong></p>
<h3 id="使用Bootstrap搭建项目"><a href="#使用Bootstrap搭建项目" class="headerlink" title="使用Bootstrap搭建项目"></a>使用Bootstrap搭建项目</h3><ol>
<li>工程文件的目录结构</li>
</ol>
</li>
</ol>
<figure class="highlight crystal"><table><tr><td class="code"><pre><code class="hljs undefined">├─ Demo ·························· 项目所在目录<br>└─┬─ /css/ ······················· 我们自己的CSS文件<br>  ├─ /font/ ······················ 使用到的字体文件<br>  ├─ /img/ ······················· 使用到的图片文件<br>  ├─ /js/ ························ 自己写的JS脚步<br>  ├─ /<span class="hljs-class"><span class="hljs-keyword">lib</span>/ ······················· 从第三方下载回来的库【只用不改】</span><br>  ├─ /favicon.ico ················ 站点图标<br>  └─ /index.html ················· 入口文件<br></code></pre></td></tr></table></figure>

<p><a href="https://github.com/aFarkas/html5shiv" target="_blank" rel="noopener">html5shiv</a>让浏览器可以识别 HTML5 的新标签。如header、footer、section等。</p>
<p><a href="https://github.com/scottjehl/Respond" target="_blank" rel="noopener">respond.js</a>让低版本浏览器可以使用css3的媒体查询</p>
<p>JQuery：Bootstrap框架中的所有js组件都依赖于jquery实现。</p>
<p>我们可以把上面这三个库文件拷贝到lib文件夹中</p>
<h3 id="布局容器：container类"><a href="#布局容器：container类" class="headerlink" title="布局容器：container类"></a>布局容器：container类</h3><p>Bootstrap需要为页面内容和栅格系统包裹一个<code>.container</code>容器。由于<code>padding</code>等属性的原因，这两种容器不能相互嵌套。</p>
<p><code>container</code>类用于固定宽度并支持响应式布局的容器</p>
<p><code>container-fluid</code>类用于100%宽度，占据全部视口（viewport）的容器，又称流体容器</p>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>在栅格系统中，我们在less文件中使用以下媒体查询来创建关键的分界点</p>
<figure class="highlight HTML"><table><tr><td class="code"><pre><code class="hljs HTML">/* 超小屏幕（手机，小于 768px） */<br>/* 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） */<br><br>/* 小屏幕（平板，大于等于 768px） */<br>@media (min-width: @screen-sm-min) &#123; ... &#125;<br><br>/* 中等屏幕（桌面显示器，大于等于 992px） */<br>@media (min-width: @screen-md-min) &#123; ... &#125;<br><br>/* 大屏幕（大桌面显示器，大于等于 1200px） */<br>@media (min-width: @screen-lg-min) &#123; ... &#125;<br></code></pre></td></tr></table></figure>

{% asset_img 6.png %}

<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>一个按钮称之为样式；两个按钮在一起，就可以称之为组件</p>
<p>js组件在官网有介绍</p>
<h3 id="bootstrap源码分析"><a href="#bootstrap源码分析" class="headerlink" title="bootstrap源码分析"></a>bootstrap源码分析</h3><p>固定容器</p>
<table>
<thead>
<tr>
<th>阈值</th>
<th align="center">width</th>
</tr>
</thead>
<tbody><tr>
<td>大于等于1200（lg   大屏pc）</td>
<td align="center">1170</td>
</tr>
<tr>
<td>大于等于992（md   中屏pc）小于1200</td>
<td align="center">970</td>
</tr>
<tr>
<td>大于等于768（sm  平板）</td>
<td align="center">750</td>
</tr>
<tr>
<td>小于768（xs   移动手机）</td>
<td align="center">auto</td>
</tr>
</tbody></table>
<h4 id="less根目录下的grid-less"><a href="#less根目录下的grid-less" class="headerlink" title="less根目录下的grid.less"></a>less根目录下的grid.less</h4><figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//固定容器</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-comment">//在mixin文件夹下grid.less的公用样式</span><br>  <span class="hljs-selector-class">.container-fixed</span>();<br><span class="hljs-comment">//媒体查询</span><br>  <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-variable">@screen-sm-min</span>) &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-variable">@container-sm</span>;<br>  &#125;<br>  <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-variable">@screen-md-min</span>) &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-variable">@container-md</span>;<br>  &#125;<br>  <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-variable">@screen-lg-min</span>) &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-variable">@container-lg</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// Fluid container流体容器</span><br><span class="hljs-selector-class">.container-fluid</span> &#123;<br>  <span class="hljs-selector-class">.container-fixed</span>();<br>&#125;<br><span class="hljs-comment">// Row行的定义</span><br><span class="hljs-selector-class">.row</span> &#123;<br>  <span class="hljs-selector-class">.make-row</span>();<br>&#125;<br><span class="hljs-comment">// Columns列的定义</span><br><span class="hljs-selector-class">.make-grid-columns</span>();<br><span class="hljs-selector-class">.make-grid</span>(xs);<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-variable">@screen-sm-min</span>) &#123;<br>  <span class="hljs-selector-class">.make-grid</span>(sm);<br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-variable">@screen-md-min</span>) &#123;<br>  <span class="hljs-selector-class">.make-grid</span>(md);<br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-variable">@screen-lg-min</span>) &#123;<br>  <span class="hljs-selector-class">.make-grid</span>(lg);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="grid-framework-less"><a href="#grid-framework-less" class="headerlink" title="grid-framework.less"></a>grid-framework.less</h4><figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs undefined">行偏移与列偏移<br><span class="hljs-selector-tag">calc-grid-column</span>(<span class="hljs-variable">@index</span>, <span class="hljs-variable">@class</span>, <span class="hljs-variable">@type</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@type</span> = width) <span class="hljs-keyword">and</span> (<span class="hljs-variable">@index</span> &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-selector-class">.col-</span><span class="hljs-variable">@&#123;class&#125;</span><span class="hljs-selector-tag">-</span><span class="hljs-variable">@&#123;index&#125;</span> &#123;<br>    <span class="hljs-attribute">width</span>: percentage((<span class="hljs-variable">@index</span> / <span class="hljs-variable">@grid-columns</span>));<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.calc-grid-column</span>(<span class="hljs-variable">@index</span>, <span class="hljs-variable">@class</span>, <span class="hljs-variable">@type</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@type</span> = push) <span class="hljs-keyword">and</span> (<span class="hljs-variable">@index</span> &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-selector-class">.col-</span><span class="hljs-variable">@&#123;class&#125;</span><span class="hljs-selector-tag">-push-</span><span class="hljs-variable">@&#123;index&#125;</span> &#123;<br>    <span class="hljs-attribute">left</span>: percentage((<span class="hljs-variable">@index</span> / <span class="hljs-variable">@grid-columns</span>));<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.calc-grid-column</span>(<span class="hljs-variable">@index</span>, <span class="hljs-variable">@class</span>, <span class="hljs-variable">@type</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@type</span> = push) <span class="hljs-keyword">and</span> (<span class="hljs-variable">@index</span> = <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-selector-class">.col-</span><span class="hljs-variable">@&#123;class&#125;</span><span class="hljs-selector-tag">-push-0</span> &#123;<br>    <span class="hljs-attribute">left</span>: auto;<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.calc-grid-column</span>(<span class="hljs-variable">@index</span>, <span class="hljs-variable">@class</span>, <span class="hljs-variable">@type</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@type</span> = pull) <span class="hljs-keyword">and</span> (<span class="hljs-variable">@index</span> &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-selector-class">.col-</span><span class="hljs-variable">@&#123;class&#125;</span><span class="hljs-selector-tag">-pull-</span><span class="hljs-variable">@&#123;index&#125;</span> &#123;<br>    <span class="hljs-attribute">right</span>: percentage((<span class="hljs-variable">@index</span> / <span class="hljs-variable">@grid-columns</span>));<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.calc-grid-column</span>(<span class="hljs-variable">@index</span>, <span class="hljs-variable">@class</span>, <span class="hljs-variable">@type</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@type</span> = pull) <span class="hljs-keyword">and</span> (<span class="hljs-variable">@index</span> = <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-selector-class">.col-</span><span class="hljs-variable">@&#123;class&#125;</span><span class="hljs-selector-tag">-pull-0</span> &#123;<br>    <span class="hljs-attribute">right</span>: auto;<br>  &#125;<br>&#125;<br><span class="hljs-selector-class">.calc-grid-column</span>(<span class="hljs-variable">@index</span>, <span class="hljs-variable">@class</span>, <span class="hljs-variable">@type</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@type</span> = offset) &#123;<br>  <span class="hljs-selector-class">.col-</span><span class="hljs-variable">@&#123;class&#125;</span><span class="hljs-selector-tag">-offset-</span><span class="hljs-variable">@&#123;index&#125;</span> &#123;<br>    <span class="hljs-attribute">margin-left</span>: percentage((<span class="hljs-variable">@index</span> / <span class="hljs-variable">@grid-columns</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="mixin文件夹下的grid-less"><a href="#mixin文件夹下的grid-less" class="headerlink" title="mixin文件夹下的grid.less"></a>mixin文件夹下的grid.less</h4><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs less">/ Grid system固定容器和流体容器的公告样式<br>//@grid-gutter-width槽宽  30px<br>.container-fixed(@gutter: @grid-gutter-width) &#123;<br>  margin-right: auto;<br>  margin-left: auto;<br>  padding-left:  floor((@gutter / 2));<br>  padding-right: ceil((@gutter / 2));<br>  &amp;:extend(.clearfix all);<br>&#125;<br><br>// Creates a wrapper for a series of columns<br>.make-row(@gutter: @grid-gutter-width) &#123;<br>  margin-left:  ceil((@gutter / -2));<br>  margin-right: floor((@gutter / -2));<br>  &amp;:extend(.clearfix all);<br>&#125;<br><br>// Generate the extra small columns<br>.make-xs-column(@columns; @gutter: @grid-gutter-width) &#123;<br>  position: relative;<br>  float: left;<br>  width: percentage((@columns / @grid-columns));<br>  min-height: 1px;<br>  padding-left:  (@gutter / 2);<br>  padding-right: (@gutter / 2);<br>&#125;<br>.make-xs-column-offset(@columns) &#123;<br>  margin-left: percentage((@columns / @grid-columns));<br>&#125;<br>.make-xs-column-push(@columns) &#123;<br>  left: percentage((@columns / @grid-columns));<br>&#125;<br>.make-xs-column-pull(@columns) &#123;<br>  right: percentage((@columns / @grid-columns));<br>&#125;<br><br>// Generate the small columns<br>.make-sm-column(@columns; @gutter: @grid-gutter-width) &#123;<br>  position: relative;<br>  min-height: 1px;<br>  padding-left:  (@gutter / 2);<br>  padding-right: (@gutter / 2);<br><br>  @media (min-width: @screen-sm-min) &#123;<br>    float: left;<br>    width: percentage((@columns / @grid-columns));<br>  &#125;<br>&#125;<br>.make-sm-column-offset(@columns) &#123;<br>  @media (min-width: @screen-sm-min) &#123;<br>    margin-left: percentage((@columns / @grid-columns));<br>  &#125;<br>&#125;<br>.make-sm-column-push(@columns) &#123;<br>  @media (min-width: @screen-sm-min) &#123;<br>    left: percentage((@columns / @grid-columns));<br>  &#125;<br>&#125;<br>.make-sm-column-pull(@columns) &#123;<br>  @media (min-width: @screen-sm-min) &#123;<br>    right: percentage((@columns / @grid-columns));<br>  &#125;<br>&#125;<br><br>// Generate the medium columns<br>.make-md-column(@columns; @gutter: @grid-gutter-width) &#123;<br>  position: relative;<br>  min-height: 1px;<br>  padding-left:  (@gutter / 2);<br>  padding-right: (@gutter / 2);<br><br>  @media (min-width: @screen-md-min) &#123;<br>    float: left;<br>    width: percentage((@columns / @grid-columns));<br>  &#125;<br>&#125;<br>.make-md-column-offset(@columns) &#123;<br>  @media (min-width: @screen-md-min) &#123;<br>    margin-left: percentage((@columns / @grid-columns));<br>  &#125;<br>&#125;<br>.make-md-column-push(@columns) &#123;<br>  @media (min-width: @screen-md-min) &#123;<br>    left: percentage((@columns / @grid-columns));<br>  &#125;<br>&#125;<br>.make-md-column-pull(@columns) &#123;<br>  @media (min-width: @screen-md-min) &#123;<br>    right: percentage((@columns / @grid-columns));<br>  &#125;<br>&#125;<br><br>// Generate the large columns<br>.make-lg-column(@columns; @gutter: @grid-gutter-width) &#123;<br>  position: relative;<br>  min-height: 1px;<br>  padding-left:  (@gutter / 2);<br>  padding-right: (@gutter / 2);<br><br>  @media (min-width: @screen-lg-min) &#123;<br>    float: left;<br>    width: percentage((@columns / @grid-columns));<br>  &#125;<br>&#125;<br>.make-lg-column-offset(@columns) &#123;<br>  @media (min-width: @screen-lg-min) &#123;<br>    margin-left: percentage((@columns / @grid-columns));<br>  &#125;<br>&#125;<br>.make-lg-column-push(@columns) &#123;<br>  @media (min-width: @screen-lg-min) &#123;<br>    left: percentage((@columns / @grid-columns));<br>  &#125;<br>&#125;<br>.make-lg-column-pull(@columns) &#123;<br>  @media (min-width: @screen-lg-min) &#123;<br>    right: percentage((@columns / @grid-columns));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>Bootstrap</category>
      </categories>
      <tags>
        <tag>UI 框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax3-jquery</title>
    <url>/2020/07/24/Ajax3-jquery/</url>
    <content><![CDATA[<h1 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h1><h2 id="封装Ajax"><a href="#封装Ajax" class="headerlink" title="封装Ajax"></a>封装Ajax</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAjax</span>(<span class="hljs-params">httpUrl,callbackFn</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    <span class="hljs-comment">// 设置请求方法和路径</span><br>    xhr.open(<span class="hljs-string">'GET'</span>,httpUrl);<br>    <span class="hljs-comment">// 发送数据</span><br>    xhr.send()<br>    <span class="hljs-comment">// 监听后台是否返回数据</span><br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(xhr.status==<span class="hljs-number">200</span>&amp;&amp;xhr.readyState ==<span class="hljs-number">4</span>)&#123;<br>           callbackFn(xhr)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="调用Ajax"><a href="#调用Ajax" class="headerlink" title="调用Ajax"></a>调用Ajax</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">getAjax(httpUrl,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(xhr)<br>        <span class="hljs-keyword">var</span> dataObj = <span class="hljs-built_in">JSON</span>.parse(xhr.response)<br>        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'body'</span>).append(<span class="hljs-string">`&lt;h1&gt;<span class="hljs-subst">$&#123;res.title&#125;</span>&lt;/h1&gt;`</span>)<br>    &#125;)<br></code></pre></td></tr></table></figure>

<p>加上url后，使用异步的回调函数将JSON数据进行解析</p>
<h2 id="使用jQueryAjax"><a href="#使用jQueryAjax" class="headerlink" title="使用jQueryAjax"></a>使用jQueryAjax</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$.<span class="hljs-keyword">get</span>(httpUrl,function (res) &#123;<br>        <span class="hljs-built_in">console</span>.log(res)<br>        $(<span class="hljs-string">'body'</span>).append(<span class="hljs-string">`&lt;h1&gt;<span class="hljs-subst">$&#123;res.title&#125;</span>&lt;/h1&gt;`</span>)<br>    &#125;)<br></code></pre></td></tr></table></figure>

<p>不需要再对JSON进行解析</p>
<h2 id="其它写法"><a href="#其它写法" class="headerlink" title="其它写法"></a>其它写法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 请求段子地址</span><br>    <span class="hljs-keyword">var</span> httpUrl1 = <span class="hljs-string">"https://api.apiopen.top/getJoke?page=1&amp;count10&amp;type=video"</span><br>    $.<span class="hljs-keyword">get</span>(httpUrl1).then(function (res) &#123;<br>        <span class="hljs-built_in">console</span>.log(res)<br>    &#125;)<br><span class="hljs-comment">//使用.then()并且将参数作为对象传入</span><br>    <span class="hljs-keyword">var</span> httpUrl2 = <span class="hljs-string">"https://api.apiopen.top/getJoke"</span><br>    <span class="hljs-keyword">var</span> options = &#123;<br>        <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">"image"</span><br>    &#125;<br>    $.<span class="hljs-keyword">get</span>(httpUrl2, options).then(function (res) &#123;<br>        <span class="hljs-built_in">console</span>.log(res)<br>        res.result.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, i</span>) </span>&#123;<br>            $(<span class="hljs-string">'body'</span>).append(<span class="hljs-string">`&lt;img src="<span class="hljs-subst">$&#123;item.images&#125;</span>"&gt;`</span>)<br>        &#125;)<br>    &#125;)<br></code></pre></td></tr></table></figure>

<h2 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax"></a>$.ajax</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$.ajax(&#123;<br>        <span class="hljs-attr">url</span>: httpUrl2,<br>        <span class="hljs-attr">data</span>: <span class="hljs-string">"options"</span>,<span class="hljs-comment">//地址后面的参数</span><br>        <span class="hljs-attr">method</span>: <span class="hljs-string">"GET"</span>,<br>        <span class="hljs-comment">//成功执行的函数</span><br>        <span class="hljs-comment">// success:function () &#123;</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// &#125;,</span><br>        <span class="hljs-comment">// // 失败执行的函数</span><br>        <span class="hljs-comment">// fail:function () &#123;</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// &#125;,</span><br>        <span class="hljs-comment">//不管成功还是失败都会执行的函数</span><br>        <span class="hljs-attr">complete</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(res)<br>            <span class="hljs-keyword">var</span> res = res.responseJSON;<br>            res.result.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, i</span>) </span>&#123;<br>                $(<span class="hljs-string">'body'</span>).append(<span class="hljs-string">`&lt;img src="<span class="hljs-subst">$&#123;item.images&#125;</span>"&gt;`</span>)<br>            &#125;)<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure>

<p><strong>$.ajax()方法是jQuery最底层的Ajax实现</strong></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax2</title>
    <url>/2020/07/23/Ajax2/</url>
    <content><![CDATA[<h1 id="关于Ajax"><a href="#关于Ajax" class="headerlink" title="关于Ajax"></a>关于Ajax</h1><p>对于在学习Ajax过程中，再看了各种教程，或者视频讲解时，粗略了解到我们可以在不刷新页面的情况下，通过Ajax的方式区获取新的内容</p>
<a id="more"></a>

<h2 id="发送Ajax请求的五个步骤"><a href="#发送Ajax请求的五个步骤" class="headerlink" title="发送Ajax请求的五个步骤"></a>发送Ajax请求的五个步骤</h2><ul>
<li>创建异步对象。即XMLHttpRequest对象。</li>
<li>使用open方法设置请求的参数。open(method,url,async)</li>
<li>发送请求</li>
<li>注册事件。注册onreadystatechange事件，状态改变时就会调用。</li>
<li>获取返回的数据</li>
</ul>
<p>并且对Ajax的五个步骤进行封装，将url和将要执行的请求方法或者回调函数进行封装复用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAjax</span>(<span class="hljs-params">httpUrl,data,callbackFn</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    <span class="hljs-comment">// 设置请求方法和路径</span><br>    xhr.open(<span class="hljs-string">'GET'</span>,httpUrl+parseData(data));<br>    <span class="hljs-comment">// 发送数据</span><br>    xhr.send()<br>    <span class="hljs-comment">// 监听后台是否返回数据</span><br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(xhr.status==<span class="hljs-number">200</span>&amp;&amp;xhr.readyState ==<span class="hljs-number">4</span>)&#123;<br>           callbackFn(xhr)<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseData</span>(<span class="hljs-params">data</span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> str = <span class="hljs-string">"?"</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> data)&#123;<br>            str = str + key + <span class="hljs-string">"="</span> + data[key]+ <span class="hljs-string">"&amp;"</span>;<br>        &#125;<br>        str.substr(<span class="hljs-number">0</span>,str.length<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> str<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><p>在大都数教程中会告诉我们，通过设置url就可以将数据进行返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> httpUrl = <span class="hljs-string">"https://api.apiopen.top/getJoke"</span><br>    <span class="hljs-keyword">var</span> data = &#123;<br>        <span class="hljs-attr">page</span>:<span class="hljs-number">1</span>,<br>        <span class="hljs-attr">count</span>:<span class="hljs-number">10</span>,<br>        <span class="hljs-attr">type</span>:<span class="hljs-string">"video"</span><br>    &#125;<br>    getAjax(httpUrl,data,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(xhr)<br>        <span class="hljs-keyword">var</span> datiObj = <span class="hljs-built_in">JSON</span>.parse(xhr.response)<br>        <span class="hljs-built_in">console</span>.log(datiObj)<br>    &#125;)<br></code></pre></td></tr></table></figure>

<img src="/2020/07/23/Ajax2/1.png">

<p>这样就请求到了数据，但是还是不清楚我们请求到的数据要做什么，在实际的项目中ajax是怎么操作的</p>
<p>一直保持懵懂的了解基本api 的程度</p>
<h2 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h2><p>通过练习一个段子项目渲染页面来熟悉ajax操作</p>
<img src="/2020/07/23/Ajax2/2.png">

<p>通过查看易点租的页面发现内部的商品结构全部是由js进行dom节点插入，我们实现一个类似今日头条的视频页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"videoList"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"videoItem"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"videoTop"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"img"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">'background-image: url("http://wimg.spriteapp.cn/picture/2020/0713/5f0c04f33bf50_wpd.jpg")'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>无知者无畏。。。看好自家小孩，以免酿成悲剧<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"num"</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>次播放<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"videoBottom"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://thirdwx.qlogo.cn/mmopen/vi_32/rlIeDLHvqo1MpvibllRxg4K4pBJ8CxRkN8Vtv5TpJjicdeetpuJtqqibAHEHC1IKibAHqaQ5DQKDBg9XOPib76HlIicA/132"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"headerImg"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"author"</span>&gt;</span>老朽姓何<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>根据页面结构设置好视频列表的布局，然后我们需要编辑该盒子CSS样式，这个时候的图片素材是我们直接在结构中写的已知的链接，</p>
<p>接下来编写ajax请求数据获取所有的图片等资源</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> httpUrl = <span class="hljs-string">"https://api.apiopen.top/getJoke?page=1&amp;count10&amp;type=video"</span>;<br>    getAjax(httpUrl, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) </span>&#123;<br>        <span class="hljs-comment">//var resultObj = "数据获取不到"</span><br>        <span class="hljs-keyword">var</span> resultObj = <span class="hljs-built_in">JSON</span>.parse(xhr.response);<br>        <span class="hljs-built_in">console</span>.log(resultObj);<br>    &#125;)<br></code></pre></td></tr></table></figure>

<p><strong>getAjax()函数是我们引入的已经封装好的Ajax文件</strong></p>
<h3 id="那么接下来是我们如何将页面动态的渲染"><a href="#那么接下来是我们如何将页面动态的渲染" class="headerlink" title="那么接下来是我们如何将页面动态的渲染"></a>那么接下来是我们如何将页面动态的渲染</h3><ol>
<li>首先加载好了数据</li>
<li>我们要通过获取的数据渲染出视频列表，那么就需要进行循环的创建</li>
</ol>
<p><strong>将上方写好的videoItem注释掉</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> httpUrl = <span class="hljs-string">"https://api.apiopen.top/getJoke?page=1&amp;count10&amp;type=video"</span>;<br>  getAjax(httpUrl, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">xhr</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> resultObj = <span class="hljs-string">"数据获取不到"</span><br>      <span class="hljs-keyword">var</span> resultObj = <span class="hljs-built_in">JSON</span>.parse(xhr.response);<br>      <span class="hljs-built_in">console</span>.log(resultObj);<br>      <span class="hljs-comment">//将请求的结果赋值给videolist</span><br>      <span class="hljs-keyword">var</span> videoList = resultObj.result;<br>      renderVideoList(videoList);<br>  &#125;)<br>  <span class="hljs-comment">//编写渲染函数</span><br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderVideoList</span>(<span class="hljs-params">videoList</span>) </span>&#123;<br>       <span class="hljs-comment">//循环创建内部节点</span><br>      videoList.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index</span>) </span>&#123;<br>          <span class="hljs-comment">//创建内部节点并添加类名</span><br>          <span class="hljs-keyword">var</span> videoItem = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>)<br>          <span class="hljs-comment">//添加类名以便获取CSS样式</span><br>          videoItem.className = <span class="hljs-string">"videoItem"</span><br>          videoItem.innerHTML = <span class="hljs-string">`&lt;div class="videoTop"&gt;<br>              &lt;div class="img" style='background-image: url(<span class="hljs-subst">$&#123;item.thumbnail&#125;</span>)'&gt;&lt;/div&gt;<br>              &lt;button type="button"&gt;&lt;/button&gt;<br>              &lt;h3 class="title"&gt;<span class="hljs-subst">$&#123;item.text&#125;</span>&lt;/h3&gt;<br>              &lt;p&gt;&lt;span class="icon yanjing"&gt;&lt;/span&gt; &lt;span class="num"&gt;<span class="hljs-subst">$&#123;item.up&#125;</span>&lt;/span&gt;次播放&lt;/p&gt;<br>          &lt;/div&gt;`</span><br>          <span class="hljs-keyword">var</span> videoListDom = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".videoList"</span>)<br>          videoListDom.appendChild(videoItem)<br>      &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure>

<img src="/2020/07/23/Ajax2/4.png">

<p>我们可以看到js渲染的页面全部获取到了ajax请求到的数据，包括每个栏目的图片、标题、观看量等。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6rest参数和拓展运算符</title>
    <url>/2020/08/19/ES6rest%E5%8F%82%E6%95%B0%E5%92%8C%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h1><p>在ES5中传入参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//ES5中通过arguments获取参数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">data</span>(<span class="hljs-params"></span>) </span>&#123;<br>  consloe.log(<span class="hljs-built_in">arguments</span>)<br>&#125;<br>data(<span class="hljs-string">'v'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'r'</span>)<span class="hljs-comment">//Arguments(3) ["v","a","r"]</span><br></code></pre></td></tr></table></figure>

<a id="more"></a>

<p>有了 rest参数后获取参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">data</span>(<span class="hljs-params">..args</span>) </span>&#123;<br>  consloe.log(args) <span class="hljs-comment">//(3)["v","a","r"]</span><br>&#125;<br>data(<span class="hljs-string">'v'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'r'</span>)<br></code></pre></td></tr></table></figure>

<p>rest参数必须放在最后,</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, ...args, b</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(a)<br>            <span class="hljs-built_in">console</span>.log(b)<br>            <span class="hljs-built_in">console</span>.log(args)<br>        &#125;<br> fn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<span class="hljs-comment">//Uncaught SyntaxError: Rest parameter must be last formal parameter</span><br></code></pre></td></tr></table></figure>

<p>这样是不允许的</p>
<h1 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h1><p>[…] 拓展运算符能将【数组】转换为逗号分隔的【参数序列】</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//声明一个数组</span><br><span class="hljs-keyword">const</span> tfboys = [<span class="hljs-string">'易洋千玺'</span>, <span class="hljs-string">'王源'</span>, <span class="hljs-string">'王俊凯'</span>]<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  consloe.log(<span class="hljs-built_in">arguments</span>)<br>&#125;<br>fn(...tfboys) = fn(<span class="hljs-string">'易洋千玺'</span>, <span class="hljs-string">'王源'</span>, <span class="hljs-string">'王俊凯'</span>)<br></code></pre></td></tr></table></figure>

<p>虽然他们都是用三个点表示，rest参数是放在了函数声明的形参中，而拓展运算符是在函数调用的实参中使用</p>
<p>拓展运算符的应用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//数组的克隆</span><br><br>​        <span class="hljs-keyword">const</span> sanzhihua = [<span class="hljs-string">'E'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'M'</span>]<br><br>​        <span class="hljs-keyword">const</span> clone = [...sanzhihua]<br><br>​        <span class="hljs-built_in">console</span>.log(clone)<span class="hljs-comment">//['E', 'G', 'M']</span><br><br>​        <span class="hljs-comment">//将伪数组转为真正的数组，假设页面中有三个div</span><br><br>​        <span class="hljs-keyword">const</span> divs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'div'</span>)<br><br>​        <span class="hljs-built_in">console</span>.log(divs)<span class="hljs-comment">//Object</span><br><br>​        <span class="hljs-keyword">const</span> divArr = [...divs]<span class="hljs-comment">//[div,div,div]</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript ES6 拓展运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>LESS</title>
    <url>/2019/03/11/LESS/</url>
    <content><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><a id="more"></a>

<p>特点：延迟执行</p>
<ol>
<li><p>值变量</p>
<p>定义：@变量名：属性值；</p>
<p>调用：@变量名</p>
</li>
<li><p>选择器变量</p>
<p>定义：@变量名：选择器名</p>
<p>调用：@{变量名}：{} </p>
</li>
<li><p>属性变量：</p>
<p>语法同上，不仅可存选择器属性名，也可存取其部分名称</p>
</li>
<li><p>url变量（）</p>
<p>定义：@变量名：‘../images’;</p>
<p>调用：@{url}</p>
</li>
<li><p>声明变量：在一个变量中声明一组样式：***声明：@变量名：{样式集合}；调用：@变量名（）；</p>
</li>
<li><p>变量运算：</p>
<p>数值：<em>减法操作时，减号前后要加空格</em>；</p>
<p>颜色：是否书写#，返回结果不同；</p>
<p>字符串：声明变量时建议用‘  ‘ 调用时间’{}‘ ；</p>
<p>用变量定义变量：</p>
<p>用第二个变量值定义第一个变量名，可实现传递变量值</p>
<h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><ul>
<li><p>外层元素{</p>
<p>​    子元素1{}</p>
<p>​    子元素2{</p>
<p>​          孙子元素{}</p>
<p>​       }</p>
<p>}</p>
<p>&amp;符的作用：代表上层元素的名字</p>
<p>1.用于连接伪类</p>
<p>2.用于交集选择器</p>
<p>3.用于动态统一命名&amp;前不可用其它符号</p>
<h2 id="3-样式混合（Minxin）"><a href="#3-样式混合（Minxin）" class="headerlink" title="3.样式混合（Minxin）"></a>3.样式混合（Minxin）</h2><p>与@变量名：{}；类似，该功能类似于函数，特点 ：一次定义可任意调用，声明混合样式时，可用（）代表默认不执行，调用同：.box1===.box();</p>
<h2 id="4-参数混合"><a href="#4-参数混合" class="headerlink" title="4.参数混合"></a>4.参数混合</h2><p>类名参数:默认值（）{样式}</p>
<p>例：<code>.b1(){</code></p>
<p><code>border:@w solid red;</code></p>
<p><code>}</code></p>
<h2 id="5-模式匹配"><a href="#5-模式匹配" class="headerlink" title="5.模式匹配"></a>5.模式匹配</h2><p>1.根据参数个数匹配方法（根据变量匹配）</p>
<p>2.根据常量名称进行方法的匹配</p>
<p>note：常量参数可以被变量参数接受</p>
<h2 id="6-变量作用域"><a href="#6-变量作用域" class="headerlink" title="6.变量作用域"></a>6.变量作用域</h2><p>note：就近原则，如同层次没定义，向上册寻找</p>
<h2 id="7-命名空间"><a href="#7-命名空间" class="headerlink" title="7.命名空间"></a>7.命名空间</h2><p>1.方法的集合，且方法各自独立</p>
<p>2.调用时只能通过子代关系进行调用</p>
<p>3.调用路径中，父层方法不能用括号</p>
<p>4.如需使用父层变量，该变量要在激活状态</p>
<p>5.参数的初始化不等于变量定义，变量作用域只是一种方法，方法内应用，命名空间是被第三方调用准备的</p>
</li>
</ul>
</li>
</ol>
<h2 id="8-补充案例：变量与方法结合使用"><a href="#8-补充案例：变量与方法结合使用" class="headerlink" title="8.补充案例：变量与方法结合使用"></a>8.补充案例：变量与方法结合使用</h2><p>   在自定义方法中，表达式的运算结果可直接赋值给变量；可在全局使用；</p>
   <figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.avg</span>(<span class="hljs-variable">@a</span>, <span class="hljs-variable">@b</span>) &#123;<br><br>    <span class="hljs-variable">@avger:</span>(<span class="hljs-variable">@a</span>+<span class="hljs-variable">@b</span>)/<span class="hljs-number">2</span>;<br><br>    <br><br>&#125;<br><br><span class="hljs-selector-id">#wrap</span>&#123;<br><br>    <span class="hljs-selector-class">.avg</span>(<span class="hljs-number">20px</span>, <span class="hljs-number">46px</span>);<br><br>    <span class="hljs-attribute">width</span>: <span class="hljs-variable">@avger</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="9-条件表达式"><a href="#9-条件表达式" class="headerlink" title="9.条件表达式"></a>9.条件表达式</h2><p>   方法名(参数集合) when(条件表达式){</p>
<p>   …………}</p>
<p>   例：</p>
   <figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.bd</span>(<span class="hljs-variable">@a</span>) <span class="hljs-keyword">when</span>(<span class="hljs-variable">@a</span>&gt;=<span class="hljs-number">50</span>)&#123;<br><br>    <span class="hljs-attribute">border</span>: <span class="hljs-variable">@a</span> solid red;<br><br>&#125;<br><br><span class="hljs-selector-class">.box1</span>&#123;<br><br>    <span class="hljs-selector-class">.bd</span>(<span class="hljs-number">51px</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>   注意：条件中的数值单位，以实参单位为准，进行模糊匹配；</p>
<p>   @a&gt;=50 50可以是50px，50%，50pt,50em</p>
<p>   只有true关键字，才可以做为真值；</p>
<p>   运算符:</p>
<p>   比较类 &gt;  &lt;  &gt;=  =&lt;  =</p>
<p>   逻辑类:</p>
<p>   与：1 and 2</p>
<p>   或：1 or 2             1,  2</p>
<p>   非： not  1</p>
   <figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-selector-class">.bd</span>(<span class="hljs-variable">@a</span>,<span class="hljs-variable">@b</span>) <span class="hljs-keyword">when</span>(<span class="hljs-variable">@a</span>&gt;=<span class="hljs-number">50</span>) <span class="hljs-keyword">and</span> (<span class="hljs-variable">@b</span>=solid)&#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-variable">@a</span> <span class="hljs-variable">@b</span> red;<br>&#125;<br><span class="hljs-selector-class">.box1</span>&#123;<br>    <span class="hljs-selector-class">.bd</span>(<span class="hljs-number">51px</span>,solid);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="循环：less中没有任何循环关键字：如for-while"><a href="#循环：less中没有任何循环关键字：如for-while" class="headerlink" title="循环：less中没有任何循环关键字：如for while"></a>循环：less中没有任何循环关键字：如for while</h2><p>   可通过调用自身来完成（迭代关系）；</p>
<p>   方法名(参数集合) when(条件表达式){</p>
<p>   }</p>
<h2 id="10-属性（值）拼接"><a href="#10-属性（值）拼接" class="headerlink" title="10.属性（值）拼接"></a>10.属性（值）拼接</h2><p>1.属性名+：属性值：追加以逗号分隔的属性值；</p>
<p>2.属性名+_：属性值   追加以空格分割的属性值;</p>
<h2 id="11-权重（！important）"><a href="#11-权重（！important）" class="headerlink" title="11.权重（！important）"></a>11.权重（！important）</h2><p>note：less中，可将！imoprtant追回给方法，方法中所有属性都被声明</p>
<h2 id="12-外部加载less（-import）"><a href="#12-外部加载less（-import）" class="headerlink" title="12.外部加载less（@import）"></a>12.外部加载less（@import）</h2><p>@import：可实现html与css关联，也可实现css与css关联</p>
<p>语法：</p>
<p>@import    [{关键字}]   “less或css文件路径”</p>
<p>1.once：加载多个同名文件时，只编译一次；也为默认方式</p>
<p>2.multiple：同名文件，可多次编译</p>
<p>3.reference：只引用不编译；（重点）</p>
<p>note：如变量相同，延迟执行，可引用less在任意位置；</p>
<h2 id="13-继承（重点）：是less中的一个伪类"><a href="#13-继承（重点）：是less中的一个伪类" class="headerlink" title="13.继承（重点）：是less中的一个伪类"></a>13.继承（重点）：是less中的一个伪类</h2><p>：extend</p>
<p>语法：</p>
<p>1.选择器{</p>
<p>​         &amp;：extend（被继承元素 [all]）；  </p>
<p> }</p>
<p>2.选择器：extend（被继承元素 all）{}</p>
<p>all:继承指定选择器的属性及其子选择器名和属性</p>
<h2 id="14内置函数"><a href="#14内置函数" class="headerlink" title="14内置函数"></a>14内置函数</h2><p>isnumber():isnumber(#ff0);</p>
<p>​    iscolor();</p>
<p>​    isurl();</p>
<p>​    颜色函数</p>
<p>​    saturate(@color，10%)：增加一定数值的颜色饱和度</p>
<p>​    lighten(@color,10%):增加一定数值的颜色亮度</p>
<p>​    darken(@color,10%):降低一定数值的颜色亮度</p>
<p>​    fade(@color,10%):给颜色设定一定熟知的透明度</p>
<p>​    fadein(@color,10%):给颜色增加透明度</p>
<p>​    fadeout(@color,10%):给颜色降低透明度</p>
<p>​    mix(@color1,@color2):根据比例混合两种颜色</p>
<p>​    hue(@color):提取颜色色调值</p>
<p>​    saturation(@color):提取饱和度</p>
<p>​    lightness(@color)：提取亮度</p>
<p>​    数学函数</p>
<p>​    ceil:向上取整</p>
<p>   fllor:向下取整</p>
<p>​    percentage:将浮点数转化为百分比字符串</p>
<p>​    round：四舍五入</p>
<p>​    sqrt：计算一个数的平方根</p>
<p>​    abs：计算一个数的平方根</p>
<p>​    pow：计算一个数个乘方</p>
<p>note：arguments:接收全部参数</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS LESS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue02-组件</title>
    <url>/2020/05/14/Vue02/</url>
    <content><![CDATA[<h2 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h2><p>从概念上说，组件可以拓展HTML元素，封装复用性高的代码。组件是我们自定义的元素，Vue为其添加 了特殊的功能。在特殊情况下，组件也可以是原生的元素。</p>
<h3 id="为什么使用组件"><a href="#为什么使用组件" class="headerlink" title="为什么使用组件"></a>为什么使用组件</h3><p>input是一个简单常用的搜索框，很多项目会多次使用，通常情况下，复制粘贴会更加简单，这需要了粘一个那需要了，粘一个，但当需要为这些搜索框添加一个Enter事件或添加一个类时，工作量会非常大，若是使用组件，只需要修改一次。</p>
<p>组件的目的就是<strong>让代码复用更强</strong>，通过多种组件的组合形式完整的功能，同时功能的存在不需要额外增加多余的代码。</p>
<a id="more"></a>

<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><p>父组件向子组件传值</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs js">&lt;div id="app"&gt;<br>  &lt;son v-bind:parentsmsg="msg"&gt;&lt;/son&gt;<br>&lt;/div&gt;<br>//js<br>data:&#123;<br>    msg:"父亲的数据"<br>&#125;<br>components:&#123;<br>    son:&#123;<br>        template:'&lt;h1&gt;子组件数据++&#123;&#123; parentsmsg&#125;&#125;&lt;/h1&gt;',<br>        props:['parentsmsg']<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用props传来的值可以直接使用，props的数据传输是单向的，也就是说，父组件给子组件传值，子组件只能调用不能修改。</p>
<p>如果必须要修改，可以使用以下两个方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1.在组件内部定义数据</span><br><span class="hljs-attr">props</span>:[<span class="hljs-string">'title'</span>],<br>data()&#123;<br><span class="hljs-keyword">return</span>&#123;<br>  <span class="hljs-attr">local_title</span>:<span class="hljs-keyword">this</span>.title<br>     &#125;<br>&#125;<br><span class="hljs-comment">//2.使用计算属性</span><br><span class="hljs-attr">props</span>:[<span class="hljs-string">'title'</span>],<br><span class="hljs-attr">computed</span>:&#123;<br>    <span class="hljs-attr">local_title</span>:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.title.trim(<span class="hljs-string">``</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="子组件向父组件传值使用自定义事件"><a href="#子组件向父组件传值使用自定义事件" class="headerlink" title="子组件向父组件传值使用自定义事件"></a>子组件向父组件传值使用自定义事件</h4><figure class="highlight HTML"><table><tr><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app1"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        &#123;&#123; new data&#125;&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">son</span> @<span class="hljs-attr">event1</span>=<span class="hljs-string">"change($event)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">son</span>&gt;</span><br>        //event为<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> son = &#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">"#temp1"</span>,<br>    data()&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">data1</span>:<span class="hljs-string">'子组件中的数据'</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>:&#123;<br>        <span class="hljs-attr">toparents</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'event1'</span>,<span class="hljs-keyword">this</span>.data1)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//event1为要触发的事件，this.data1是传的值</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">"#app"</span>,<br>    data()&#123;<br>        <span class="hljs-keyword">return</span>&#123;<br>            <span class="hljs-keyword">this</span>.newdata = data;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">components</span>:&#123;<br>        son<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>首先在父组件调用子组件时将函数绑定，之后在子组件中使用$emit调用函数，并且可以传参，完成子组件向父组件的通信。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>框架</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>apply与call、bind的区别</title>
    <url>/2019/07/04/apply%E4%B8%8Ecall%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="apply和call"><a href="#apply和call" class="headerlink" title="apply和call()"></a>apply和call()</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>作用都可以改变this对象的指向</li>
<li>第一个参数都是this要指向的对象(thisArg//函数执行时this的指向,args//传入的实参)</li>
</ul>
<a id="more"></a>

<h2 id="call与apply的区别"><a href="#call与apply的区别" class="headerlink" title="call与apply的区别"></a>call与apply的区别</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">x,y</span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"结果："</span>+(x+y)+<span class="hljs-keyword">this</span>);<br>&#125;<br>f1(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br>obj=&#123;<br>    name=<span class="hljs-string">"小米"</span>,<br>    age=<span class="hljs-number">20</span><br>&#125;<br>f1.apply(obj,[<span class="hljs-number">10</span>,<span class="hljs-number">20</span>]);<br>f1.call(obj,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure>

<p> <code>apply()</code>与<code>call()</code>方法都可以将实参在对象之后传递，但是<code>apply()</code>方法需要将实参封装到一个数组中统一转递，即使只有一个实参。</p>
<p>简单理解</p>
<ol>
<li><code>apply()</code>把参数打包成<code>Array</code>再传入</li>
<li><code>call()</code>把参数按顺序传入</li>
</ol>
<h2 id="第一个参数的传递"><a href="#第一个参数的传递" class="headerlink" title="第一个参数的传递"></a>第一个参数的传递</h2><ol>
<li>thisObj不传或者为null，undefined时，函数中的this会指向window对象（非严格模式）</li>
<li>传递一个别的函数名时，函数中的this将指向这个函数的引用</li>
<li>传递的值为数字、布尔、字符串时，this会指向这些基本类型的包装对象Number、Boolean、String</li>
<li>传递一个对象时，函数中的this将指向传递的这个对象。</li>
</ol>
<h3 id="call-和apply-并不在实例对象中，那么对象是如何调用的"><a href="#call-和apply-并不在实例对象中，那么对象是如何调用的" class="headerlink" title="call()和apply()并不在实例对象中，那么对象是如何调用的"></a><code>call()</code>和<code>apply()</code>并不在实例对象中，那么对象是如何调用的</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>+<span class="hljs-string">":被调用了"</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(f1.__proto__==<span class="hljs-built_in">Function</span>.prototype);<span class="hljs-comment">//true</span><br>&lt;<span class="hljs-regexp">/script&gt;</span><br></code></pre></td></tr></table></figure>

<p>可以看到<code>apply()</code>和<code>call()</code>不在实例对象中，而在对象的原型中</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><ul>
<li>可以改变this的指向</li>
<li><code>call()</code>和<code>apply()</code>在调用函数时改变</li>
<li>bind是将函数返回，相当于复制了一份。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>VueRouter1</title>
    <url>/2020/07/21/VueRouter/</url>
    <content><![CDATA[<h1 id="Vue路由"><a href="#Vue路由" class="headerlink" title="Vue路由"></a>Vue路由</h1><h2 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h2><p><code>vue-router</code>默认是hash模式，使用这种模式后端不需要额外的处理，前端路由主要通过URL中的hash(#号)来实现不同页面之间的切换，并不会向后端发送请求，并且HTTP请求中不会包含hash相关的内容，</p>
<p>但是使用默认模式会url会出现一个#号，比较丑，所以可以使用history模式，这种模式充分利用 <code>history.pushState</code> API 来完成 URL 跳转而无须重新加载页面。</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">'history'</span>,<br>  <span class="hljs-attr">routes</span>: [...]<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>使用了history模式URL就会像正常的url，但是使用这种方式需要在后端进行配置，Vue官方有相对于Apache服务器，nginx，Nodejs等相关配置说明。甚至于使用Express框架时有相关的中间件配置。只需引用即可</p>
<h2 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h2><p>1、创建路由实例，参数为一个对象，这个配置对象中有一个属性：<code>routes</code>表示<strong>路由匹配规则</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> router = <span class="hljs-keyword">new</span> Router(&#123;<br>    <span class="hljs-attr">routes</span> : [<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/home'</span>, <span class="hljs-attr">component</span>: Home &#125;, <span class="hljs-comment">//当地址为/home时，显示Home组件</span><br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/goods'</span>, <span class="hljs-attr">component</span>: Goods &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/users'</span>, <span class="hljs-attr">component</span>: Users &#125;<br>    ]<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>routes属性是一个数组，数组中的每一项都是匹配规则。</p>
<p>每一个规则都是一个对象，这个对象中有两个必须的属性</p>
<p><strong>path</strong>:表示监听的路由地址</p>
<p><strong>component</strong>：表示如果路由匹配到path，则展示相关的组件；</p>
<p>2、将路由规则对象router注册到vue实例中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">"#app"</span>,<br>  <span class="hljs-comment">// 将路由对象注册到vue实例</span><br>  router<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>3、一旦路由规则匹配成功，就会在vue-router提供的标签<strong><code>&lt;router-view&gt;</code></strong>上显示出来，这个标签就代表匹配成功后的component组件的显示位置</p>
<h2 id="router-link属性"><a href="#router-link属性" class="headerlink" title="router-link属性"></a>router-link属性</h2><p>我们之前的超链接使用a标签，在vue-router官方为我们提供了<code>router-link</code>的属性实现链接跳转</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;p&gt;<br>   &lt;!-- 使用 router-link 组件来导航. --&gt;<br>   &lt;!-- 通过传入 <span class="hljs-string">`to`</span> 属性指定链接. --&gt;<br>   &lt;!-- <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span>&gt;</span> 默认会被渲染成一个 `<span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>` 标签 --&gt;<br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/foo"</span>&gt;</span>Go to Foo<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/bar"</span>&gt;</span>Go to Bar<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>并且我们也可以通过tag属性，tag=”span”，将默认的a标签转换成span标签。</p>
<h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>编程式导航就是通过js来实现页面跳转（之前都是通过标签router-link来跳转的），比如如果用户登录成功跳转道首页，这个判断的功能只能通过js来实现。</p>
<p>我在app.html添加一个按钮：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">'goHome'</span>&gt;</span>跳转到首页<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后在app.js里面实现点击事件：</p>
<p>通过<code>父组件.$router.push(&#39;路由地址&#39;)</code> 或者是<code>父组件.$router.push({name:&#39;路由别名&#39;})</code>的方式进行跳转。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">methods: &#123;<br>    goHome() &#123;<br>        <span class="hljs-keyword">this</span>.$router.push(<span class="hljs-string">'/home'</span>);<br>        <span class="hljs-keyword">this</span>.$router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'h'</span> &#125;);<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure>

<p><code>this.$router.push</code>和<code>this.$router.replace</code>的区别:</p>
<p>push会保留跳转前的地址，而replace不会。通过名字也可以看出端倪。</p>
<p>还有<code>this.$router.go(1)</code> 执行浏览指针的前进或者后退次数。</p>
<h2 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h2><p>我们现在想在/home路径下再接子路由a和b，形成嵌套路由/home/a或者/home/b形式的路由。</p>
<p>在路由配置规则数组中使用 <code>children</code> 属性，实现子路由功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> router = <span class="hljs-keyword">new</span> Router(&#123;<br>    <span class="hljs-attr">routes</span>: [<br>        <span class="hljs-comment">// 路由重定向</span><br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">'/home'</span> &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">'/home'</span>,<br>            <span class="hljs-attr">component</span>: Home,<br>            <span class="hljs-comment">// 使用children实现子路由</span><br>            <span class="hljs-attr">children</span>: [<br>                &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">component</span>: A &#125;,<br>                &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">component</span>: B &#125;<br>            ]<br>        &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/goods'</span>, <span class="hljs-attr">component</span>: Goods &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/users'</span>, <span class="hljs-attr">component</span>: Users &#125;<br>    ]<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>注意：子路由的匹配规则前面不要加/</strong></p>
<h3 id="当路由特别长的时候我们可以给路由起别名"><a href="#当路由特别长的时候我们可以给路由起别名" class="headerlink" title="当路由特别长的时候我们可以给路由起别名"></a>当路由特别长的时候我们可以给路由起别名</h3><p>起别名的方式就是往路由匹配规则加个<code>name</code>属性即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> router = <span class="hljs-keyword">new</span> Router(&#123;<br>    <span class="hljs-attr">routes</span>: [<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">'/home'</span> &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">'/home'</span>,<br>            <span class="hljs-attr">component</span>: Home,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">'h'</span>,<br>            <span class="hljs-attr">children</span>: [<br>                &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">component</span>: A, <span class="hljs-attr">name</span>: <span class="hljs-string">'a'</span> &#125;,<br>                &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'b'</span>, <span class="hljs-attr">component</span>: B, <span class="hljs-attr">name</span>: <span class="hljs-string">'b'</span> &#125;<br>            ]<br>        &#125;, <span class="hljs-comment">//当地址为/home时，显示Home组件</span><br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/goods'</span>, <span class="hljs-attr">component</span>: Goods, <span class="hljs-attr">name</span>: <span class="hljs-string">'g'</span> &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/users'</span>, <span class="hljs-attr">component</span>: Users, <span class="hljs-attr">name</span>: <span class="hljs-string">'u'</span> &#125;<br>    ]<br>&#125;);<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie与session</title>
    <url>/2020/07/13/cookie%E4%B8%8Esession/</url>
    <content><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/HTTP/Overview%23HTTP_is_stateless_but_not_sessionless" target="_blank" rel="noopener">无状态</a>的HTTP协议记录稳定的状态信息成为了可能。</p>
<a id="more"></a>

<p>客户端浏览器会将Cookie存储起来，当再次请求该网站时，浏览器将请求地址和Cookie一同交给服务器，服务器检查Cookie来辨认用户的状态。</p>
<p>如果没有Cookie，那么在我们购物时会出现这样的场景。</p>
<p>输入用户名和密码，跳转到主页<br>C：点击添加购物车<br>B：不好意思，你是谁阿？这个添加购物车的按钮，需要获得登录权限之后才能使用<br>C：于是很憋屈地再次输入用户名和密码，打算再点击添加购物车的按钮<br>B：不好意思，你是谁阿？这个添加购物车的按钮，需要获得登录权限之后才能使用<br>C：…….</p>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session是另一种记录服务器和客户端会话状态的机制。</p>
<p>当第一次请求时服务器会创建Session返回SessionID给浏览器，当第二次请求时，浏览器会将SessionID传递给服务器进行验证。</p>
<p><strong>Cookie是客户端保存的用户信息的一种机制，用来记录 用户信息，可以说它是实现Session的一种方式。</strong></p>
<h2 id="session的实现方式"><a href="#session的实现方式" class="headerlink" title="session的实现方式"></a>session的实现方式</h2><p>1、借助Cookie的sessionId发送的方式</p>
<p>2、通过LocalStorage的方式</p>
<p>3、URL回写的方式，这是客户端禁止接收Cookie之后的方法。</p>
<p>4、隐藏表单字段（hidden）</p>
<h2 id="Cookie与session的区别"><a href="#Cookie与session的区别" class="headerlink" title="Cookie与session的区别"></a>Cookie与session的区别</h2><ul>
<li><strong>安全性：</strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li>
<li><strong>存取值的类型不同</strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li>
<li><strong>有效期不同：</strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li>
<li><strong>存储大小不同：</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3布局模式</title>
    <url>/2019/04/16/css%E5%B8%83%E5%B1%80%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="CSS3新布局模式"><a href="#CSS3新布局模式" class="headerlink" title="CSS3新布局模式"></a>CSS3新布局模式</h1><h1 id="一、多列布局"><a href="#一、多列布局" class="headerlink" title="一、多列布局"></a>一、多列布局</h1><p>适用：</p>
<ol>
<li>针对文字排版</li>
<li>针对瀑布流</li>
</ol>
<p>补充：(横向布局方法)</p>
<ol>
<li>display:table/table-row/table-cell<br>以表格特征显示/以表格行特征显示/以单元格特征显示</li>
<li>min-width/min-height:最小宽度/最小高度</li>
<li>display:inline-block;</li>
<li>浮动方式:比较复杂，不便于文字排版维护<br>涉及属性：</li>
</ol>
<p><strong>1.column-width:每一列的列宽</strong><br><strong>2.column-count:强调列数，可单独使用，指定劣势，列宽自动分配。</strong></p>
<a id="more"></a>

<p>==note：当与其他属性配合使用时，其不再代表具体的值，而代表一个范围，如下：向下取整==<br>if((列宽<em>列数)&lt;(可用区域-间隔)){<br>按指定列数显示<br>按指定间隔显示<br>列宽自动分配<br>}else{<br>按指定列宽“可用”最大列数（列数小于指定列数）显示，列宽值自动分配，且&gt;=指定列宽<br>}<br>*</em>3.column-gap:列间隔**<br><strong>4.column-rule:间隔线，使用同：border</strong><br><strong>5.column-span:跨列显示，值为all，该属性火狐不支持</strong><br><strong>6.column-fill:auto/balance,但所有浏览器暂不支持</strong><br>http:// dummy images.com</p>
<h1 id="二、伸缩盒布局"><a href="#二、伸缩盒布局" class="headerlink" title="二、伸缩盒布局"></a>二、伸缩盒布局</h1><p>作用：解决子盒子的位置关系与规格计算，合理利用剩余空间</p>
<p>设置方法：display:box;</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box</span>&#123;<br><span class="hljs-attribute">display</span>:-webkit-box;<br><span class="hljs-attribute">display</span>:-moz-box;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>note:</strong></p>
<ol>
<li>强调私有属性值写法:display:-webkit-box;</li>
<li>块元素默认横向排列，且宽度丢失，高度参照外层容器；</li>
<li>兼容性中display的兼容代码在冒号后面</li>
</ol>
<h2 id="1-显示方向控制"><a href="#1-显示方向控制" class="headerlink" title="1.显示方向控制:"></a>1.显示方向控制:</h2><p>==box-orient:horizeontal(横向) / vertical(纵向)要加前缀==</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#box</span>&#123;<br><span class="hljs-attribute">-webkit-box-orient</span>:vertical;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-宽度控制："><a href="#2-宽度控制：" class="headerlink" title="2.宽度控制："></a>2.宽度控制：</h2><p>如果不设宽，以最小内容宽或最大父层宽为参照;</p>
<h3 id="弹性布局："><a href="#弹性布局：" class="headerlink" title="弹性布局："></a>弹性布局：</h3><p>==为子盒子指定box-flex,值至少为1，==可具备自动伸缩功能，瓜分伸缩容器剩余空间；</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">-webkit-box-flex</span>: 1;<br><span class="hljs-selector-tag">-moz-box-flex</span><span class="hljs-selector-pseudo">:1</span>;<br></code></pre></td></tr></table></figure>

<p>如有内容，按内容多少决定；</p>
<h3 id="问题1如果忽略内容，强制按比例分配？"><a href="#问题1如果忽略内容，强制按比例分配？" class="headerlink" title="问题1如果忽略内容，强制按比例分配？"></a>问题1如果忽略内容，强制按比例分配？</h3><p>为子盒子指定width：0；</p>
<p>默认状态下：<br>子盒大小=上层大小*当前子盒的box-flex值/所有子盒box-flex之和</p>
<h3 id="问题2：弹性与固定混用"><a href="#问题2：弹性与固定混用" class="headerlink" title="问题2：弹性与固定混用"></a>问题2：弹性与固定混用</h3><p>子盒宽=width+（父层宽-width）/所有子盒box-flex之和*自身flex值</p>
<h2 id="3-高度控制"><a href="#3-高度控制" class="headerlink" title="3.高度控制"></a>3.高度控制</h2><ol>
<li>默认以内容高为准</li>
<li>box-flex可实现比例分配</li>
<li>固定与比例混用</li>
<li>如果使用侧轴对齐时，高度变为最小高度<h2 id="4-顺序控制："><a href="#4-顺序控制：" class="headerlink" title="4.顺序控制："></a>4.顺序控制：</h2>box-ordinal-group:后面跟的数值；数值越小越优先进行显示，不接受负值。<br>优点：不破坏html结构<br>box-direction:强调所有子元素正序或倒序显示。使用外层容器。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">-webkit-box-direction</span>:<br></code></pre></td></tr></table></figure>

<h2 id="5-对齐控制："><a href="#5-对齐控制：" class="headerlink" title="5.对齐控制："></a>5.对齐控制：</h2><p>（横）box-pack：start起点对齐；/end终点对齐/center/居中对齐/justify<br>（纵）box-align：start/end/center/baseline基线对齐/stretch纵向伸展对齐<br>baseline:基线对齐，是子元素第一行内容的底部；<br>stretch:尽可能与外层容器等高；</p>
<h1 id="三、弹性盒布局"><a href="#三、弹性盒布局" class="headerlink" title="三、弹性盒布局"></a>三、弹性盒布局</h1><p>特性：<br>是CSS3中BOX升级后的布局，display:box–flexbox–flex</p>
<ol>
<li>组成：一个伸缩容器与多个伸缩项目（子元素）</li>
<li>定义方法：display:flex; display:-webkit-flex；  display：flex；</li>
<li>android:支持box</li>
<li>safir：box flex</li>
<li>moz：flex<br>声明后特性：columns/floa/clear/vertical-aligh均无效果<br>项数量：任意；<br>影响：对容器外和项目内均无影响；<br>行个数：只能有一个；<br>显示顺序：左到右上到下；<h3 id="box、flex与column区别？"><a href="#box、flex与column区别？" class="headerlink" title="box、flex与column区别？"></a>box、flex与column区别？</h3>column：列宽统一，列间统一；没有对齐属性<br>box/flex:列宽自定义，间距可调，对齐属性全面<h2 id="3-定义伸缩方向"><a href="#3-定义伸缩方向" class="headerlink" title="3.定义伸缩方向"></a>3.定义伸缩方向</h2>作用：创建主轴<br>属性及值：flex-direction：row 横向；/row-reverse 横逆向/ column：纵向   /   column-reverse：纵逆向<br>与box对应关系<br>flex-direction==box-orient+box-direction<h2 id="4-定义行数（是否换行及换行方式）"><a href="#4-定义行数（是否换行及换行方式）" class="headerlink" title="4.定义行数（是否换行及换行方式）"></a>4.定义行数（是否换行及换行方式）</h2>（box下只有单行）<br>属性及值：flex-wrap<br>nowrap:默认值，强制不换行<br>wrap-reverse：反向换行<br>note：简写</li>
</ol>
<p><strong>flex-flow：方向     换行；例：flex-flow：row-reverse  wrap-reverse；</strong></p>
<h2 id="5-定义对齐方式"><a href="#5-定义对齐方式" class="headerlink" title="5.定义对齐方式"></a>5.定义对齐方式</h2><p>适用对象与作用：适用于伸缩容器，用于在多余空间上的位置分配。</p>
<ol>
<li>主轴对齐(水平对齐)：justifiy-content：flex-start/flex-end/center/space-between/space-around；<br>参数说明如下：<br>flex-start<br>弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。<br>flex-end<br>弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。<br>center<br>弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。<br>space-between<br>弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。<br>space-around<br>弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）</li>
<li>侧轴对齐（垂直对齐）：align-items：flex-end/flex-strat/center/baseline/stretch</li>
<li>伸缩行对齐（多行元素的垂直对齐关系）：</li>
<li>align-content:flex-start/flx-end/center/stretch/space-between/space-around<br>———以下属性为单独项目的控制属性<h2 id="6-定义伸缩项目"><a href="#6-定义伸缩项目" class="headerlink" title="6.定义伸缩项目"></a>6.定义伸缩项目</h2>适用对象：适用于伸缩项目（子元素）</li>
<li>显示位置：oreder：无单位属性值 =box-ordinal-group <strong>order：1//第一个显示</strong></li>
<li>伸缩空间（如何瓜分）：flex-grow：1无单位取值，强调份数，</li>
<li>收缩空间（如何压缩）：flex-shrink:1</li>
<li>伸缩基准值：flex-basis:100px(数值加单位)该属性与宽度冲突，会覆盖原有宽度值。所有缩放动作以该属性值为基础。与先后顺序无关。</li>
<li>对齐方式（垂直方向）：对象为单独子元素<br>align-self<h1 id="四、媒体查询"><a href="#四、媒体查询" class="headerlink" title="四、媒体查询"></a>四、媒体查询</h1>重点：</li>
<li>了解CSS3设备类型</li>
<li>如何使用媒体查询规则</li>
<li>设计并制作响应式页面<h2 id="一、了解媒体查询"><a href="#一、了解媒体查询" class="headerlink" title="一、了解媒体查询"></a>一、了解媒体查询</h2></li>
<li>CSS2时代：媒体类型(media type)<br>作用：针对指定媒体类型进行css开发<br>note：常用媒体类型<br>all 所有设备   screen  电脑屏幕  tv     电视    projection   投影设备     print  打印设备<br>handheld   手持设备        braille   触摸设备    speech   语音设备<h2 id="CSS3时代：针对不同媒体，精确匹配条件自动附加相关样式-medai-queries"><a href="#CSS3时代：针对不同媒体，精确匹配条件自动附加相关样式-medai-queries" class="headerlink" title="CSS3时代：针对不同媒体，精确匹配条件自动附加相关样式(medai queries)"></a>CSS3时代：针对不同媒体，精确匹配条件自动附加相关样式(medai queries)</h2>@media screen and (min-width:800px){}<h2 id="二、媒体查询规则"><a href="#二、媒体查询规则" class="headerlink" title="二、媒体查询规则"></a>二、媒体查询规则</h2>使用方法：<br>@media [not|only] 媒体类型 [and 查询规则…]{CSS代码}<h2 id="note："><a href="#note：" class="headerlink" title="note："></a>note：</h2></li>
<li>not and (only)</li>
<li>部分接受min 与max，代表大于等于或小于等于，避免使用&amp;lt；&amp;gt；</li>
<li>not 只能针对它所在的整个查询进行取反</li>
<li>media语句中包含一种媒体类型，如果媒体类型没有指定，则<h2 id="常用媒体规则："><a href="#常用媒体规则：" class="headerlink" title="常用媒体规则："></a>常用媒体规则：</h2>width：显示宽<br>height：显示高<br>device-width：设备宽度<br>deviece-height：设备高度<br>orientation：横屏|纵屏  （landspace| protrait）<br>color：彩色设备<br>aspect-ratio：显示宽高比<br>device-asepect-ratio：设备宽高比<br>resolution：分辨率</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery03选择器</title>
    <url>/2020/07/15/jQuery03%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="jQuery中的选择器"><a href="#jQuery中的选择器" class="headerlink" title="jQuery中的选择器"></a>jQuery中的选择器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">id选择器   $(<span class="hljs-string">"#dev"</span>);<br>标签选择器  $(<span class="hljs-string">"p"</span>);<br>类选择器    $(<span class="hljs-string">".cls"</span>);<br><span class="hljs-comment">//层次选择器</span><br>$(<span class="hljs-string">"#dv span"</span>);  <span class="hljs-comment">//div这个父级元素中所有的span标签</span><br>$(<span class="hljs-string">"#dv&gt;span"</span>)   <span class="hljs-comment">//div这个父级元素的所有**直接子元素**span标签</span><br>$(<span class="hljs-string">"#dv~span"</span>)   <span class="hljs-comment">//div这个父级元素后面的兄弟元素</span><br></code></pre></td></tr></table></figure>

<p>原生方式封装$</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> $ = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>)</span>&#123;<br>    <span class="hljs-comment">//传入的选择器通过querySelector查找到赋值给domList</span><br>    <span class="hljs-keyword">var</span> domList = <span class="hljs-built_in">document</span>.querySelectorAll(selector);<br>    <span class="hljs-comment">//将选择器domList进行遍历</span><br>    domList.__proto__.html = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;<br>        domList.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item,i</span>)</span>&#123;<br>            item.innerHTML = value;<br>        &#125;)<br>    &#125;<br>    <span class="hljs-keyword">return</span> domList;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="基本过滤选择器"><a href="#基本过滤选择器" class="headerlink" title="基本过滤选择器"></a>基本过滤选择器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// :odd奇数选择</span><br>$(<span class="hljs-string">"li:odd"</span>).css(<span class="hljs-string">"background"</span>, <span class="hljs-string">"red"</span>);<br><br><span class="hljs-comment">// :even偶数选择</span><br>$(<span class="hljs-string">"li:even"</span>).css(<span class="hljs-string">"background"</span>, <span class="hljs-string">"green"</span>);<br><br><span class="hljs-comment">// :eq(index)索引选择器</span><br>$(<span class="hljs-string">"ul li:eq(3)"</span>).css(<span class="hljs-string">"font-size"</span>, <span class="hljs-string">"30px"</span>);<span class="hljs-comment">//设置第四个li的字体</span><br><br><span class="hljs-comment">// :lt(index)小于索引</span><br>$(<span class="hljs-string">"li:lt(6)"</span>).css(<span class="hljs-string">"font-size"</span>, <span class="hljs-string">"30px"</span>);<br><br><span class="hljs-comment">// :gt(index)大于该索引</span><br>$(<span class="hljs-string">".ulList1 li:gt(7)"</span>).css(<span class="hljs-string">"font-size"</span>, <span class="hljs-string">"40px"</span>);<br><br><span class="hljs-comment">// :first第一个</span><br>$(<span class="hljs-string">".ulList li:first"</span>).css(<span class="hljs-string">"font-size"</span>, <span class="hljs-string">"40px"</span>);<br><br><span class="hljs-comment">// :last最后一个</span><br>$(<span class="hljs-string">"li:last"</span>).css(<span class="hljs-string">"font-size"</span>, <span class="hljs-string">"40px"</span>);<br></code></pre></td></tr></table></figure>

<h3 id="筛选选择器"><a href="#筛选选择器" class="headerlink" title="筛选选择器"></a>筛选选择器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">.prev();      该元素前一个兄弟元素<br>.prevAll();   该元素前面所有兄弟元素<br>.next();      该元素后一个兄弟元素<br>.nextAll();   该元素后面所有兄弟元素<br>.parnet();    该元素的父级元素<br>.find();      后代寻找选择器（要指定参数）例：<br>jqul.find(<span class="hljs-string">"li"</span>).css(<span class="hljs-string">"background"</span>, <span class="hljs-string">"pink"</span>);<br>.sibling();   该元素所有兄弟元素<br></code></pre></td></tr></table></figure>

<h3 id="通过jQuery选择器来实现一个tab切换组件"><a href="#通过jQuery选择器来实现一个tab切换组件" class="headerlink" title="通过jQuery选择器来实现一个tab切换组件"></a>通过jQuery选择器来实现一个tab切换组件</h3><img src="/2020/07/15/jQuery03选择器/1.png">

<p>点击不同按钮切换显示不同的内容：</p>
<p>设置三个内容隐藏，当点击对应按钮时为按钮和对应的内容添加active样式。</p>
<img src="/2020/07/15/jQuery03选择器/2.png">

<p>使用jquery仅需两行代码即可实现，选中元素样式的添加和兄弟元素的样式删除。</p>
<h2 id="jquery的样式操作"><a href="#jquery的样式操作" class="headerlink" title="jquery的样式操作"></a>jquery的样式操作</h2><figure class="highlight mel"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-comment">//设置在元素属性上，优先级高</span><br>    $(<span class="hljs-string">'h1'</span>).css(<span class="hljs-string">'background'</span>,<span class="hljs-string">'skyblue'</span>);<br>    <span class="hljs-comment">//一次性设置多个样式,传入一个对象。</span><br>    $(<span class="hljs-string">'h1'</span>).css(&#123;<br>        <span class="hljs-keyword">color</span>:<span class="hljs-string">'red'</span>,<br>        border:<span class="hljs-string">'3px solid #ccc'</span>,<br>        borderRadius:<span class="hljs-string">'10px'</span><span class="hljs-comment">//使用驼峰命名方式，如果要使用border-radius方式需加引号</span><br>    &#125;)<br></code></pre></td></tr></table></figure>

<p>通过.css()方法设置元素的样式</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs js">  &lt;style&gt;<br>        .d1&#123;<br>            width: 400px;background-color: skyblue;height: 400px;opacity: 0;<br>        &#125;<br>        .d1.active&#123;opacity: 1&#125;<br>    &lt;/style&gt;<br>    &lt;script src="jquery-1.12.1.min.js"&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div class="d1"&gt;&lt;/div&gt;<br>&lt;button&gt;切换显示d1&lt;/button&gt;<br>&lt;script&gt;<br>    $('button').click(function () &#123;<br>        if($('.d1').hasClass('active'))&#123;<br>            $('.d1').removeClass('active')<br>        &#125;else&#123;<br>            $('.d1').addClass('active')<br>        &#125;<br>        // $('.d1').toggleClass('active')<br>    &#125;)<br></code></pre></td></tr></table></figure>

<p>.hasClass()判断元素是否含有此样式</p>
<p>.addClass()为元素增加类样式</p>
<p>.removeClass()为元素删除类样式</p>
<p>.toggleClass()当元素有此样式时删除，没有时增加</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>jQuery</tag>
        <tag>选择器</tag>
        <tag>样式</tag>
      </tags>
  </entry>
  <entry>
    <title>jquery04操作DOM</title>
    <url>/2020/07/18/jquery04%E6%93%8D%E4%BD%9CDOM/</url>
    <content><![CDATA[<h1 id="DOM操作的分三个方面"><a href="#DOM操作的分三个方面" class="headerlink" title="DOM操作的分三个方面"></a>DOM操作的分三个方面</h1><p>DOM Core（核心）、HTML-DOM和CSS-DOM</p>
<ol>
<li><p><strong>DOM Core</strong>JavaScript中的getElementById()、getElementsByTagName()、getAttribute()、setAttribute()等方法，都是DOM Core的组成部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用DOM Core获取表单：</span><br><span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'form'</span>);<br><span class="hljs-comment">//使用DOM Core获取某元素的src属性方法：</span><br>element.getAttribute(<span class="hljs-string">'src'</span>)<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>HTML-DOM</strong>提供一些简明的记号来描述各种HTML元素的属性</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用HTML-DOM来获取表单对象的方法：</span><br><span class="hljs-built_in">document</span>.forms;<br><span class="hljs-comment">//使用HTML-DOM来获取某元素的src属性的方法：</span><br>element.src<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>CSS-DOM</strong>是针对CSS的操作，主要是获取和设置style对象的各种属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//设置某元素style对象字体颜色的方法；</span><br>element.style.color = <span class="hljs-string">"red"</span><br></code></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="jquery中的DOM操作"><a href="#jquery中的DOM操作" class="headerlink" title="jquery中的DOM操作"></a>jquery中的DOM操作</h2><h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//查找元素节点</span><br><span class="hljs-keyword">var</span> $li = $(<span class="hljs-string">'ul li'</span>);<span class="hljs-comment">//查找li;</span><br><span class="hljs-comment">//查找属性节点,利用选择器找到元素后，通过attr()方法来获取他的各种属性的值。</span><br><span class="hljs-keyword">var</span> p_txt = $(<span class="hljs-string">'p'</span>).attr(<span class="hljs-string">'title'</span>);<br><span class="hljs-comment">//attr();接收两个参数，一个参数为获取属性，两个参数为设置属性</span><br></code></pre></td></tr></table></figure>

<h3 id="创建节点-amp-插入节点"><a href="#创建节点-amp-插入节点" class="headerlink" title="创建节点&amp;插入节点"></a>创建节点&amp;插入节点</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//通过设置html来创建内容(推荐)</span><br>    $(<span class="hljs-string">'div'</span>).html(<span class="hljs-string">'&lt;h2&gt;hello  world&lt;/h2&gt;'</span>);<br>    <span class="hljs-comment">//append追加</span><br>    $(<span class="hljs-string">'div'</span>).append(h1);<br>    <span class="hljs-comment">//写法与append相反</span><br>    h3.appendTo(<span class="hljs-string">'div'</span>);<br>    $(<span class="hljs-string">'div'</span>).prepend(<span class="hljs-string">'&lt;h4&gt;前面追加&lt;/h4&gt;'</span>);<br><span class="hljs-comment">//在元素的后面插入节点</span><br>    $(<span class="hljs-string">'div'</span>).after(<span class="hljs-string">'&lt;p&gt;123&lt;/p&gt;'</span>);<br></code></pre></td></tr></table></figure>

<h3 id="使用删除节点"><a href="#使用删除节点" class="headerlink" title="使用删除节点"></a>使用删除节点</h3><p>1、<strong>remove()</strong>当某个节点用remove()方法删除后，该节点所包含的所有后代节点将同时被删除。这个方法的返回值是一个指向已被删除的节点的引用，因此可以在以后再使用这些元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//删除元素</span><br>   <span class="hljs-keyword">var</span> $(<span class="hljs-string">'li'</span>) = $(<span class="hljs-string">'ul li:eq(1)'</span>).remove();将ul中的第二个li删除<br>   $(<span class="hljs-string">'li'</span>).appendTo(<span class="hljs-string">"ul"</span>);<span class="hljs-comment">//再将删除的元素重新插入</span><br></code></pre></td></tr></table></figure>

<p>2、<strong>detach()</strong>方法和remove()方法类似，但是所有绑定的事件、附加的数据都会保留下来</p>
<p>3、<strong>empty()方法</strong>不是删除节点，而是清空节点</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs undefined">$(<span class="hljs-string">'div'</span>).empty();<span class="hljs-comment">//清空div内所有节点</span><br></code></pre></td></tr></table></figure>

<h3 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h3><p>使用replaceWith()和replaceAll()将匹配的元素替换成指定的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">"p"</span>).replaceWith(<span class="hljs-string">"&lt;strong&gt;你喜欢的&lt;/strong&gt;"</span>);<br>$(<span class="hljs-string">"&lt;strong&gt;你喜欢的&lt;/strong&gt;"</span>).replaceAll(<span class="hljs-string">"p"</span>)<br></code></pre></td></tr></table></figure>

<h3 id="获取属性和设置属性"><a href="#获取属性和设置属性" class="headerlink" title="获取属性和设置属性"></a>获取属性和设置属性</h3><p> 想要替换p的title属性</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs undefined">$(<span class="hljs-string">"p"</span>).attr(<span class="hljs-string">"title"</span>,<span class="hljs-string">"change title"</span>)<br></code></pre></td></tr></table></figure>

<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><p>removeAttr()删除元素的属性</p>
<h2 id="设置和获取HTML、文本和值"><a href="#设置和获取HTML、文本和值" class="headerlink" title="设置和获取HTML、文本和值"></a>设置和获取HTML、文本和值</h2><ol>
<li>.html()类似JavaScript中的innerHTML属性，可以用来读取或者设置某个元素中的HTML内容。</li>
<li>.text()类似innerText属性</li>
<li>val()方法</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>jQuery</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>js创建对象的几种方式</title>
    <url>/2019/03/13/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="字面量方式"><a href="#字面量方式" class="headerlink" title="字面量方式"></a>字面量方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">var</span> obj=&#123;&#125;;<br><br>obj.name=<span class="hljs-string">"小黑"</span>;<br><br>obj.age=<span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//优化：</span><br><br><span class="hljs-keyword">var</span> obj2=&#123;<br><br>    <span class="hljs-attr">name</span>:<span class="hljs-string">"小小"</span>,<br><br>    <span class="hljs-attr">age</span>:<span class="hljs-number">10</span>,<br><br>    <span class="hljs-attr">sayHi</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello"</span>);<br><br>    &#125;<br><br>&#125;;<br><span class="hljs-comment">//缺陷：一次性对象，更改属性需要修改源代码</span><br></code></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="构造函数方式创建"><a href="#构造函数方式创建" class="headerlink" title="构造函数方式创建"></a>构造函数方式创建</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">var</span> smallDog = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br>            smallDog.eat = <span class="hljs-string">"吃骨头"</span>;<br><br>            smallDog.walk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">"不想走路"</span>);<br><br>            &#125;<br></code></pre></td></tr></table></figure>

<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObject</span>(<span class="hljs-params">name,age</span>) </span>&#123;<br><br>            <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br>            o.name = name;<br><br>            o.age = age;<br><br>            o.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br>                alert(<span class="hljs-string">"this.name"</span>);<br><br>            &#125;;<br><br>            <span class="hljs-keyword">return</span> o;<br><br>        &#125;<br><br> <br><br>            <span class="hljs-keyword">var</span> person1 = createObject(<span class="hljs-string">"小刘"</span>,<span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure>

<p>函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象，可以无数次的调用这个函数，而它每次都会返回一个包含两个属性一个方法的对象，虽然解决了创建多个相似对象的问题，但仍没有解决对象的识别问题。</p>
<h2 id="自定义构造函数模式"><a href="#自定义构造函数模式" class="headerlink" title="自定义构造函数模式"></a>自定义构造函数模式</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span><span class="hljs-params">(name,age)</span> </span>&#123;<br><br>            <span class="hljs-keyword">this</span>.name = name;<br><br>            <span class="hljs-keyword">this</span>.age = age;<br>            <span class="hljs-keyword">this</span>.sayName = sayName;<br>            <br>        &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayName</span><span class="hljs-params">()</span></span>&#123;<br>            alert(<span class="hljs-keyword">this</span>.name);<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> obj=<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"小刘"</span>,<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure>

<p>构造函数首字母要大写，这样其他程序员一看就会明白这是构造函数是创建对象的。</p>
<p><strong>同时我将sayName函数放到了构造函数外部,而在内部将属性设置成等于全局变量的sayName函数，这样解决了两个函数做同一件事的问题，但新的问题是如果对象需要定义很多方法，那么就要定义很多个全局函数，这样这个自定义函数的引用类型就丝毫没有封装性可言。这些问题可以通过原型模式来解决。</strong></p>
<p>只要创建了一个新函数，就会为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法</p>
<img src="/2019/03/13/js创建对象的几种方式/12.png">

<p>构造函数的prototype属性指向原型对象</p>
<p>原型对象的constructor属性又指回构造函数</p>
<p>通过构造函数创建的实例指向原型对象，可以当没有指定相关方法时会调用原型对象中的方法。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue后台管理系统</title>
    <url>/2020/07/16/vue%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="使用VueElementUI-thinkJS搭建后台管理系统"><a href="#使用VueElementUI-thinkJS搭建后台管理系统" class="headerlink" title="使用VueElementUI+thinkJS搭建后台管理系统"></a>使用VueElementUI+thinkJS搭建后台管理系统</h2><p>后台的核心就是提供数据，封装操作数据库的接口提供给前端调用。使用了Vue-element-admin的模板加thinkJS+Mysql快速的搭建起项目,</p>
<p>主要练习前端登录验证，数据列表，获取用户信息和elementUi组件。</p>
<a id="more"></a>

<h3 id="前端的登录过程"><a href="#前端的登录过程" class="headerlink" title="前端的登录过程"></a>前端的登录过程</h3><h4 id="首先在后台创建接口来处理前端的登录的相关请求。"><a href="#首先在后台创建接口来处理前端的登录的相关请求。" class="headerlink" title="首先在后台创建接口来处理前端的登录的相关请求。"></a>首先在后台创建接口来处理前端的登录的相关请求。</h4><p>1、创建登录接口</p>
<img src="/2020/07/16/vue后台管理系统/1.png">

<p>2、使用JWT保持用户的登录状态，可以实现跨域的身份验证</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//在config中配置jwt的加密和cookie</span><br><span class="hljs-attr">jwt</span>:&#123;<br>    <span class="hljs-attr">secret</span>:<span class="hljs-string">"passwordss"</span>,<br>    <span class="hljs-attr">cookie</span>:<span class="hljs-string">'jwt-token'</span>,<span class="hljs-comment">//cookie中字段的设置</span><br>    <span class="hljs-attr">expire</span>:<span class="hljs-number">3000</span><span class="hljs-comment">//秒，口令的有效时间</span><br>  &#125;,<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><br>checkAuth()&#123;<br>    <span class="hljs-keyword">let</span> token = <span class="hljs-keyword">this</span>.ctx.headers[<span class="hljs-string">'x-token'</span>];<br>    <span class="hljs-comment">//sercet加密，exipre时间，this.config('jwt')获取config中的jwt配置</span><br>    <span class="hljs-keyword">const</span> &#123;secret,cookie,exipre&#125; = <span class="hljs-keyword">this</span>.config(<span class="hljs-string">'jwt'</span>)<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">var</span> tokenObj = token ? jsonwebtoken.verify(token,secret):&#123;&#125;;<br>      <span class="hljs-keyword">this</span>.ctx.state.username = tokenObj.name;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authFail()<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(!tokenObj.name)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authFail()<br>    &#125;<br><br>    <span class="hljs-keyword">this</span>.updateAuth(token.name)<br>  &#125;<br><span class="hljs-comment">//更新token</span><br>  updateAuth(userName)&#123;<br>    <span class="hljs-keyword">const</span> userInfo = &#123;<br>      <span class="hljs-attr">name</span>:userName<br>    &#125;;<br>    <span class="hljs-comment">// 获取jwt的配置信息</span><br>    <span class="hljs-keyword">const</span> &#123;secret,cookie,expire&#125; = <span class="hljs-keyword">this</span>.config(<span class="hljs-string">'jwt'</span>)<br>    <span class="hljs-keyword">const</span> token = jsonwebtoken.sign(userInfo,secret,&#123;<span class="hljs-attr">expiresIn</span>:expire&#125;);<br>    <span class="hljs-keyword">this</span>.cookie(cookie,token);<br> <span class="hljs-comment">//客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</span><br><span class="hljs-comment">//此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。</span><br>    <span class="hljs-keyword">this</span>.header(<span class="hljs-string">'authoriztion'</span>,token);<br>    <span class="hljs-keyword">return</span> token;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 失败处理</span><br>  authFail()&#123;<br>    <span class="hljs-keyword">this</span>.json(&#123;<span class="hljs-attr">error</span>:<span class="hljs-string">"JWT校验失败"</span>&#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>随后在中间件中引入jwt</p>
<h5 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h5><p>JWT的原理是，服务器认证以后生成一个JSON对象，发回给用户，</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">"姓名"</span>: <span class="hljs-string">"小刘"</span>,<br>    <span class="hljs-attr">"角色"</span>: <span class="hljs-string">"管理员"</span>,<br>    <span class="hljs-attr">"到期时间"</span>: <span class="hljs-string">"2020年8月1日0点0分"</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名；</p>
<p>JWT的三个部分依次如下。</p>
<p>Header(头部)、Payload(负载)、Signature(签名)</p>
<p>Header.payload.Signature</p>
<h5 id="JWT的使用方式"><a href="#JWT的使用方式" class="headerlink" title="JWT的使用方式"></a>JWT的使用方式</h5><p>客户端收到服务器返回的JWT，可以存储在Cookie里面，也可以存储在localStorage。</p>
<p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-symbol">Authorization:</span>Bearer<span class="hljs-params">&lt;token&gt;</span><br></code></pre></td></tr></table></figure>

<p>另一种方式是，在跨域的时候，JWT就放在POST请求的数据体里面</p>
<h4 id="进入前端的登录逻辑"><a href="#进入前端的登录逻辑" class="headerlink" title="进入前端的登录逻辑"></a>进入前端的登录逻辑</h4><p>1、在login.vue中修改路由并在router中修改路由，在根目录时跳转到login页</p>
<p>2、前端中封装axios请求，同时设置baseurl,并设置跨域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">baseURL: process.env.VUE_APP_BASE_API, <span class="hljs-comment">// url = base url + request url</span><br><span class="hljs-comment">//在.env.development中将base设置</span><br>VUE_APP_BASE_API = <span class="hljs-string">'/api'</span><br><span class="hljs-comment">//在vue.config.js中设置代理服务器</span><br><span class="hljs-attr">proxy</span>:&#123;<br>      <span class="hljs-string">'/api'</span>:&#123;<br>        <span class="hljs-attr">target</span>:<span class="hljs-string">'http://127.0.0.1:8360'</span>,<br>        <span class="hljs-attr">pathRewrite</span>:&#123;<br>          <span class="hljs-string">'^/api'</span>:<span class="hljs-string">""</span><br>        &#125;<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>3、编写登录请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">login</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> request(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">'/user/login/login'</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">'post'</span>,<br>    data<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInfo</span>(<span class="hljs-params">token</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> request(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">'/admin/index/userInfo'</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>4、Vuex编写获取用户信息函数在数据库中获取用户名头像等</p>
<p>5、登出仅需删除token</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// user logout</span><br>logout(&#123; commit, state &#125;) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><br>      removeToken() <span class="hljs-comment">// must remove  token  first</span><br>      resetRouter()<br>      commit(<span class="hljs-string">'RESET_STATE'</span>)<br>      resolve()<br><br>  &#125;)<br>&#125;,<br></code></pre></td></tr></table></figure>

<h3 id="用户管理获取用户列表删除修改增加等"><a href="#用户管理获取用户列表删除修改增加等" class="headerlink" title="用户管理获取用户列表删除修改增加等"></a>用户管理获取用户列表删除修改增加等</h3><h4 id="后台创建用户管理接口"><a href="#后台创建用户管理接口" class="headerlink" title="后台创建用户管理接口"></a>后台创建用户管理接口</h4>{% asset_img 2.png %}

<p>编写从数据库获取用户列表和删除列表等接口</p>
<h4 id="前端用户列表增删改查"><a href="#前端用户列表增删改查" class="headerlink" title="前端用户列表增删改查"></a>前端用户列表增删改查</h4><p>用户列表使用table组件，模板中匹配对应数据，在点击增加用户时设置跳转路由，跳转到对应增加信息的页面。</p>
<h4 id="列表分页操作"><a href="#列表分页操作" class="headerlink" title="列表分页操作"></a>列表分页操作</h4><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;el-pagination<br>      background<br>      layout="prev, pager, next"<br>      :total="total" @current-change="getPageUsers"&gt;<br>    &lt;/el-pagination&gt;<br>//total总条数从后端获取<br>//下一页<br>getPageUsers(page) &#123;<br>        console.log(page);<br>        userlist(&#123;page&#125;).then(response =&gt; &#123;<br>          this.list = response.userlist;<br>          this.total = response.total;<br>          console.log(this.list)<br>          this.listLoading = false<br>        &#125;)<br>      &#125;,<br></code></pre></td></tr></table></figure>

<h4 id="在删除时通过弹框提示"><a href="#在删除时通过弹框提示" class="headerlink" title="在删除时通过弹框提示"></a>在删除时通过弹框提示</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> del(id) &#123;<br>        <span class="hljs-comment">//弹框</span><br>        <span class="hljs-keyword">this</span>.$confirm(<span class="hljs-string">'是否需要删除$&#123;id&#125;的用户?, 确认删除'</span>, <span class="hljs-string">'提示'</span>, &#123;<br>          <span class="hljs-attr">confirmButtonText</span>: <span class="hljs-string">'确定'</span>,<br>          <span class="hljs-attr">cancelButtonText</span>: <span class="hljs-string">'取消'</span>,<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">'warning'</span><br>        &#125;).then(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>          <span class="hljs-keyword">this</span>.listLoading = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> deluser(&#123;id&#125;);<br>          <span class="hljs-keyword">this</span>.listLoading = <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">this</span>.fetchData()<br>          &#125;);<br>      &#125;<br></code></pre></td></tr></table></figure>

<h4 id="添加权限操作"><a href="#添加权限操作" class="headerlink" title="添加权限操作"></a>添加权限操作</h4><p>后台编写添加权限接口</p>
{% asset_img 3.png %}

<p>前台导出调用后台接口的请求给页面调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addrule</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> request(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">'/admin/rule/addrule'</span>,<br>    <span class="hljs-attr">method</span>:<span class="hljs-string">'post'</span>,<br>    <span class="hljs-attr">data</span>:data<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>addrule页面中调用方法，当提交表单时</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">methods: &#123;<br>      onSubmit() &#123;<br>        <span class="hljs-keyword">this</span>.$message(<span class="hljs-string">'submit!'</span>)<br>        addrule(<span class="hljs-keyword">this</span>.form)<br>        <span class="hljs-keyword">this</span>.$router.push(<span class="hljs-string">'/user/rulelist'</span>)<br>      &#125;,<br>      onCancel() &#123;<br>        <span class="hljs-keyword">this</span>.$message(&#123;<br>          <span class="hljs-attr">message</span>: <span class="hljs-string">'cancel!'</span>,<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">'warning'</span><br>        &#125;)<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>thinkJS</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序</title>
    <url>/2020/05/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<ol>
<li><p>x小程序没有DOM对象，一切基于组件化</p>
</li>
<li><p>小程序的4个重要文件</p>
<p>wxml—&gt;view结构—&gt; 类似HTML</p>
<p>wxss—&gt;view样式—-&gt; 类似CSS</p>
<p>js</p>
<p>json—&gt;数据—–&gt;json文件</p>
<a id="more"></a>
</li>
<li><p>需要储备的知识</p>
<p>理解事件机制</p>
<p>组件化</p>
<p>数据绑定</p>
<p>Flex布局</p>
<p>移动端适配</p>
</li>
</ol>
<p>根目录下的App()表示注册一个小程序 必须在app.js中调用且只能调用一次</p>
<p>根目录下的app.json文件用来对微信小程序进行全局配置，包含文件的路径，底部tab栏，默认窗口表现等。</p>
<p>根目录下的app.wxss中可以看到采用了flex布局。</p>
<h2 id="微信中的事件"><a href="#微信中的事件" class="headerlink" title="微信中的事件"></a>微信中的事件</h2><p>事件分为冒泡事件和非冒泡事件：</p>
<ol>
<li>冒泡事件：使用<code>bind</code>当一个组件上的事件被触发后，该事件会向父节点传递。</li>
<li>非冒泡事件：使用<code>catch</code>当一个组件上的事件被触发后，该事件不会向父节点传递。</li>
</ol>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs js">&lt;block wx:for="&#123;&#123;content&#125;&#125;" wx:key="index"&gt;<br>	&lt;view class="content"&gt;<br>		&lt;view class="name"&gt;姓名：&#123;&#123;item.name&#125;&#125;&lt;/view&gt;<br>		&lt;view class="phone"&gt;手机号：&#123;&#123;item.phone&#125;&#125;&lt;/view&gt;<br>	&lt;/view&gt;<br>&lt;/block&gt;<br>//设置通信列表数据，content为列表名，name和phone为json数据的一个key<br>data: &#123;<br>    //设置通信列表数据<br>    content:[<br>      &#123;name:"qi", phone:"12344444"&#125;,<br>      &#123;name:"qi1", phone:"12344444"&#125;,<br>      &#123;name:"qi2", phone:"12344444"&#125;,<br>      &#123;name:"qi3", phone:"12344444"&#125;,<br>      &#123;name:"qi4", phone:"12344444"&#125;,<br>    ]<br>  &#125;,<br></code></pre></td></tr></table></figure>

<ul>
<li><p>页面跳转：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs undefined"><span class="hljs-selector-tag">wx</span><span class="hljs-selector-class">.navigateTo</span>(&#123;<br>  <span class="hljs-attribute">url</span>:<span class="hljs-string">'test/'</span>,<br>  events:&#123;&#125;,<br>  <span class="hljs-selector-tag">success</span>: <span class="hljs-selector-tag">function</span>(<span class="hljs-selector-tag">data</span>)&#123;<br>    <br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
</li>
<li><p>swiper组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">swiper</span> <span class="hljs-attr">indicator-dots</span>=<span class="hljs-string">"&#123;&#123;indicatorDots&#125;&#125;"</span><span class="hljs-attr">autoplay</span>=<span class="hljs-string">"&#123;&#123;autoplay&#125;&#125;"</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">"&#123;&#123;interval&#125;&#125;"</span> <span class="hljs-attr">duration</span>=<span class="hljs-string">"&#123;&#123;duration&#125;&#125;"</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">"&#123;&#123;background&#125;&#125;"</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">"index"</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"&#123;&#123;item&#125;&#125;"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"swiper-item"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span><br>			<span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">swiper</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs css">、.container&#123;<br>  justify-content: start;<br>    //发现swiper一直在container中居中显示，是container有一个padding200rpx的样式<br>  padding: 0;<br>&#125;<br>swiper&#123;<br>  width: 100%;<br>  height: 400rpx;<br>&#125;<br>.swiper-item&#123;<br>  width: 100%;<br>  height: 100%;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>列表循环</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">"&#123;&#123;array&#125;&#125;"</span>&gt;</span><br>  &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>//使用wx:for-item 可以指定数组当前元素的变量名<br>//使用 wx:for-index 可以指定数组当前下标的变量名<br></code></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目问题</title>
    <url>/2020/06/01/vue%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="vue踩坑"><a href="#vue踩坑" class="headerlink" title="vue踩坑"></a>vue踩坑</h2><p>今天在执行项目时碰到这样的问题首先是项目</p>
<img src="/2020/06/01/vue项目问题/7.png">

<a id="more"></a>

<p>这是一个点歌系统，后端node+express那么这个表单在上传文件时也就是歌曲时。</p>
<img src="/2020/06/01/vue项目问题/3.png">

<p>报了这样一个错，检查跨域并没有问题，项目本身也不会有问题，毕竟早就完美运行过了</p>
<p>更换浏览器发现同样错误</p>
<img src="/2020/06/01/vue项目问题/8.png">

<p>当发送请求时</p>
<img src="/2020/06/01/vue项目问题/88.png">

<p>这个fs引起了注意，最终发现谷歌浏览器最近的MP3压缩格式后缀改成了mpeg。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>框架</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>更改github用户名导致hexo博客无法更新</title>
    <url>/2020/02/20/%E6%9B%B4%E6%94%B9github%E7%94%A8%E6%88%B7%E5%90%8D/</url>
    <content><![CDATA[<p>1 关于Github更改用户名字的问题，一直以来感觉自己的github名字起的比较幼稚，所以今天看着弹出来的一堆警告狠下心来改掉了用户名。</p>
<a id="more"></a>

<p>那么现在更改名字过后本地的库还存在但是需要手动更改所有项目的远程地址，我们可以通过以下途径看到他们：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs git">git remote -v<br></code></pre></td></tr></table></figure>

<p>之后删除掉旧的远程地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs git">git remote rm git@github.com:old_account/res.git<br></code></pre></td></tr></table></figure>

<p>最后，添加新的远程地址</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs undefined">git remote <span class="hljs-built_in">add</span> origin git@github.<span class="hljs-keyword">com</span>:new_account/<span class="hljs-keyword">res</span>.git<br></code></pre></td></tr></table></figure>

<h2 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h2><p>更改过后发现通过hexo搭建的博客无法更新的问题，找来找去发现了问题</p>




<p>需要将hexo中的配置地址更改，并且远程库的名字也要更改为新的名字</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝与浅拷贝</title>
    <url>/2020/08/20/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>提到深拷贝与浅拷贝就要探讨js中的数据类型，基本类型例如，<code>Number</code>,<code>String</code>等，他们的值是不可变的，动态的修改了基本数据类型的值它的原始值也是不会改变的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">"abc"</span><br><span class="hljs-built_in">console</span>.log(st[<span class="hljs-number">1</span>]=<span class="hljs-string">"d"</span>)<br><span class="hljs-built_in">console</span>.log(s)<span class="hljs-comment">//abc</span><br></code></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型是存放在堆内存中的，变量实际上存放着一个放在栈内存的指针，引用类型可以直接改变它的值</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝是将原对象或数组的引用直接赋给新对象，新数组它们只是原对象的一个引用</p>
<p>首先我们通过赋值复制一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = &#123;<br>       <span class="hljs-string">'name'</span> : <span class="hljs-string">'zhangsan'</span>,<br>       <span class="hljs-string">'age'</span> :  <span class="hljs-string">'18'</span>,<br>       <span class="hljs-string">'language'</span> : [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]],<br>   &#125;;<br><br>   <span class="hljs-keyword">var</span> obj2 = obj1;<br><br><br>   <span class="hljs-keyword">var</span> obj3 = shallowCopy(obj1);<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowCopy</span>(<span class="hljs-params">src</span>) </span>&#123;<br>       <span class="hljs-keyword">var</span> dst = &#123;&#125;;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> src) &#123;<br>           <span class="hljs-keyword">if</span> (src.hasOwnProperty(prop)) &#123;<br>               dst[prop] = src[prop];<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dst;<br>   &#125;<br><br>   obj2.name = <span class="hljs-string">"lisi"</span>;<br>   obj3.age = <span class="hljs-string">"20"</span>;<br><br>   obj2.language[<span class="hljs-number">1</span>] = [<span class="hljs-string">"二"</span>,<span class="hljs-string">"三"</span>];<br>   obj3.language[<span class="hljs-number">2</span>] = [<span class="hljs-string">"四"</span>,<span class="hljs-string">"五"</span>];<br><br>   <span class="hljs-built_in">console</span>.log(obj1);  <br>   <span class="hljs-comment">//obj1 = &#123;</span><br>   <span class="hljs-comment">//    'name' : 'lisi',</span><br>   <span class="hljs-comment">//    'age' :  '18',</span><br>   <span class="hljs-comment">//    'language' : [1,["二","三"],["四","五"]],</span><br>   <span class="hljs-comment">//&#125;;</span><br><br>   <span class="hljs-built_in">console</span>.log(obj2);<br>   <span class="hljs-comment">//obj2 = &#123;</span><br>   <span class="hljs-comment">//    'name' : 'lisi',</span><br>   <span class="hljs-comment">//    'age' :  '18',</span><br>   <span class="hljs-comment">//    'language' : [1,["二","三"],["四","五"]],</span><br>   <span class="hljs-comment">//&#125;;</span><br><br>   <span class="hljs-built_in">console</span>.log(obj3);<br>   <span class="hljs-comment">//obj3 = &#123;</span><br>   <span class="hljs-comment">//    'name' : 'zhangsan',</span><br>   <span class="hljs-comment">//    'age' :  '20',</span><br>   <span class="hljs-comment">//    'language' : [1,["二","三"],["四","五"]],</span><br>   <span class="hljs-comment">//&#125;;</span><br></code></pre></td></tr></table></figure>

<p>如果属性是基本数据类型，拷贝的就是基本类型的值，如果属性是引用类型拷贝的就是内存地址，所以如果其中一个对像改变了，这个引用类型的属性或者说是地就会影响到另一个对像。</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>创建一个新的对像和数组，将原对象的各个属性的值（数组的所有元素）拷贝过来，<strong>是值而不是引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> array = [<br>    &#123; <span class="hljs-attr">number</span>: <span class="hljs-number">1</span> &#125;,<br>    &#123; <span class="hljs-attr">number</span>: <span class="hljs-number">2</span> &#125;,<br>    &#123; <span class="hljs-attr">number</span>: <span class="hljs-number">3</span> &#125;<br>];<br><span class="hljs-keyword">var</span> copyArray = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(array))<br>copyArray[<span class="hljs-number">0</span>].number = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">//  [&#123;number: 1&#125;, &#123; number: 2 &#125;, &#123; number: 3 &#125;]</span><br><span class="hljs-built_in">console</span>.log(copyArray); <span class="hljs-comment">// [&#123;number: 100&#125;, &#123; number: 2 &#125;, &#123; number: 3 &#125;]</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
