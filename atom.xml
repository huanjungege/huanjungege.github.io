<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yo_huanjun</title>
  
  <subtitle>Practice makes perfect.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lhjailj.top/"/>
  <updated>2021-04-08T14:16:40.686Z</updated>
  <id>http://www.lhjailj.top/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线性表</title>
    <link href="http://www.lhjailj.top/2021/04/08/2021-4-8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://www.lhjailj.top/2021/04/08/2021-4-8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2021-04-08T13:40:48.000Z</published>
    <updated>2021-04-08T14:16:40.686Z</updated>
    
    <content type="html"><![CDATA[<p>线性表的联想：当学校组织外出旅游，班级的人数很多，那么我们怎么记住每一个同学并区分，这不是件容易的事，所以老师想到一个办法，热昂同学们按照一个约定好的方式排成一队，以后大家只要记住自己前面的同学，这样老师也可以很快的清点人数，万一有人走丢也可以很快的发现，因为只需要哪位同学告诉老师他前面的同学不见了即可。</p><p>关于线性表的定义：<strong>由零个或多个数据元素组成的有序数列</strong></p><ol><li>首先它是一个序列，也就是元素之前有先来后到</li><li>若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继</li><li>另外线性表强调是有限的，事实上计算机发展至今它处理的元素都是有限的。无限的概念只存在于数学的理论中。</li></ol><a id="more"></a><h2 id="关于数据类型"><a href="#关于数据类型" class="headerlink" title="关于数据类型"></a>关于数据类型</h2><p>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</p><p>看不懂，官方定义</p><p>例如很多编程语言的整型，浮点型，字符型这些指的就是数据类型。那么设计计算机语言的人为什么会考虑到数据类型呢？</p><p>因为在计算机中，内存也不是无限大的，要计算1+1=2这样的整型数字加减乘除运算显然不需要开辟很大的内存空间，而计算1.234455+2.24324这样的带大量小数的浮点型肯定需要开辟比较大的内存空间。</p><p>通过数据类型牵引出<strong>抽象数据类型</strong></p><p>抽象是相对于具体来说的，当你看到一个美女，你说哇哦，美女！那么一堆女生会回头看你，因为你给出的概念是抽象的，大家都认为自己是美女，当你说哇，美女范冰冰，那么只有范冰冰会转过来。</p><p>抽象是指抽取出事物具有的普遍性的本质，他要求指出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节。它的意义在于数据类型的数学抽象特征。</p><p>我们对已有的数据类型进行抽象，就有了抽象数据类型（Abstract Data Type , ADT）是指一个数学模型及定义在该模型上的一组操作。</p><p>待续….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性表的联想：当学校组织外出旅游，班级的人数很多，那么我们怎么记住每一个同学并区分，这不是件容易的事，所以老师想到一个办法，热昂同学们按照一个约定好的方式排成一队，以后大家只要记住自己前面的同学，这样老师也可以很快的清点人数，万一有人走丢也可以很快的发现，因为只需要哪位同学告诉老师他前面的同学不见了即可。&lt;/p&gt;
&lt;p&gt;关于线性表的定义：&lt;strong&gt;由零个或多个数据元素组成的有序数列&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先它是一个序列，也就是元素之前有先来后到&lt;/li&gt;
&lt;li&gt;若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继&lt;/li&gt;
&lt;li&gt;另外线性表强调是有限的，事实上计算机发展至今它处理的元素都是有限的。无限的概念只存在于数学的理论中。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.lhjailj.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="http://www.lhjailj.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="javaScript" scheme="http://www.lhjailj.top/tags/javaScript/"/>
    
      <category term="线性表" scheme="http://www.lhjailj.top/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>原型链与继承</title>
    <link href="http://www.lhjailj.top/2021/03/31/2021-03-31-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://www.lhjailj.top/2021/03/31/2021-03-31-%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2021-03-31T07:09:28.000Z</published>
    <updated>2021-04-08T02:13:29.497Z</updated>
    
    <content type="html"><![CDATA[<p><code>JS</code>中创建一个构造函数后就会有一个<code>property</code>属性指向构造函数的原型对象，原型对象通过<code>constructor</code>属性指回构造函数。（构造函数与原型对象互相指），此时通过构造函数创建的对象可以访问构造函数原型对象的属性，所以在访问这个新对象的属性的时候如果在自身搜索不到，JS会通过这条链去原型对象中搜索，上一层原型对象搜索不到还会继续层层向上搜索，比如每个对象的上层都有一个<code>Object</code>对象。</p><p>实际上所有引用类型都继承自Object，也是通过原型链实现的，这意味着这个实例有一个内部指针指向<code>Object.prototype</code>,这也是自定义类型能否继承包括<code>toString()</code>、<code>valueOf()</code>这些方法的原因</p><p>同时通过构造函数创建一个对象实例，实例内部指针指向原型对象，我们给这个原型对象起名为原型A，那么如果原型A是构造函数B的实例，那么原型A的内部指针就会指向构造函数b的原型对象B，</p><img src="/2021/03/31/2021-03-31-原型链/1.png"><a id="more"></a><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 声明构造函数A</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.Aname = <span class="hljs-string">'aaaa'</span><br>&#125;<br><span class="hljs-comment">// 定义函数A的原型方法</span><br>A.prototype.getAValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.Aname<br>&#125;<br><span class="hljs-comment">// 定义函数B</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.Bname = <span class="hljs-string">'b'</span><br>&#125;<br><span class="hljs-comment">//这里构造函数B本来有自己的原型对象，但是我们将构造函数A的实例赋值给B的原型，相当于重写了函数B的原型</span><br>B.prototype = <span class="hljs-keyword">new</span> A()<br><span class="hljs-comment">// new一个函数B的实例对象C</span><br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> B()<br><br><span class="hljs-built_in">console</span>.log(c.getAValue()) <span class="hljs-comment">// aaa 构造函数A的原型方法与构造函数A的属性</span><br><span class="hljs-built_in">console</span>.log(c.Bname) <span class="hljs-comment">// b</span><br><span class="hljs-built_in">console</span>.log(c.Aname) <span class="hljs-comment">// aaa</span><br><span class="hljs-comment">// 我们通过instanceof 来观察c是否出现在以下构造函数的原型链上</span><br><span class="hljs-built_in">console</span>.log(c <span class="hljs-keyword">instanceof</span> A) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(c <span class="hljs-keyword">instanceof</span> B) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(c <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>​        此时实例c不仅能访问B的bName属性也能访问A的属性甚至是方法，因为他们已经通过原型链连接了，在通过<code>instanceof</code>检查c是否在A或B的原型链上，果然返回的结果是true</p><p>​        构造函数B没有使用自身的默认原型，而是替换了一个新的对象，这个对象恰好是A的实例，这样一来B的实例不仅能从A的实例中获取属性和方法，还和A的原型对象挂上了钩。</p><p>上述例子的原型链结构</p><p>c(B的实例）此时指向—–&gt;B的原型对象此时等于 ——&gt;A的实例—&gt;(同时A的实例指向)—–〉A的原型对象</p><p>这个例子是实现继承的关键，</p><p><strong>默认原型</strong></p><p><strong>原型对象继承的问题</strong></p><p>原型对象很强大，但是也有问题，出现在原型对象包含引用值的时候，一个原型对象，它的所有实例都会<strong>共享它的属性</strong>，这也是为什么属性通常在构造函数中定义而不会定义在原型上的原因。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//这里构造函数B本来有自己的原型对象，但是我们将构造函数A的实例赋值给B的原型，相当于重写了函数B的原型</span><br>B.prototype = <span class="hljs-keyword">new</span> A()<br></code></pre></td></tr></table></figure><p>可以看下上方的代码，原本B的原型对象现在却变成了A的实例，那么原本构造函数A中的实例属性A.name现在变成了原型属性，那么会产生什么问题呢</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'pink'</span>]<br>&#125;<br><br>A.prototype.getAValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.colors<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.Bname = <span class="hljs-string">'b'</span><br>&#125;<br><br>B.prototype = <span class="hljs-keyword">new</span> A()<br><br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> B()<br>c.colors.push(<span class="hljs-string">'black'</span>)<br><span class="hljs-built_in">console</span>.log(c.getAValue()) <span class="hljs-comment">// [ 'red', 'blue', 'pink', 'black' ]</span><br><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> B()<br><span class="hljs-built_in">console</span>.log(d.getAValue()) <span class="hljs-comment">// [ 'red', 'blue', 'pink', 'black' ]</span><br></code></pre></td></tr></table></figure><p>由于此时B.property 变成了A的实例，因此也获得了自己的colors属性，这相当于所有B的实例都共享着一个A实例中的colors，那么修改了c的colors。d的colors也会改变</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h2><p>为了解决原型包含引用值时导致的继承问题，通过call在继承的实例中再次执行构造函数A，这样c与d继承来自两个独立的A实例，这种方式称为<code>盗用构造函数继承</code></p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'pink'</span>]<br>&#125;<br>A.prototype.getAValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.colors<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 运行函数A，拥有了colors属性</span><br>  A.call(<span class="hljs-keyword">this</span>)<br>&#125;<br>B.prototype = <span class="hljs-keyword">new</span> A()<br><span class="hljs-comment">// new B()的同时调用内部的A函数，创建了一个A的新实例</span><br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> B()<br>c.colors.push(<span class="hljs-string">'black'</span>)<br><span class="hljs-built_in">console</span>.log(c.getAValue())<span class="hljs-comment">// [ 'red', 'blue', 'pink', 'black' ]</span><br><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> B()<br><span class="hljs-built_in">console</span>.log(d.getAValue())<span class="hljs-comment">// [ 'red', 'blue', 'pink']</span><br></code></pre></td></tr></table></figure><p><code>盗用构造函数继承的问题</code>也是使用构造函数模式自定义类型的问题，必须在构造函数中定义方法，这样函数不能重用，</p><h3 id="将两者结合组合式继承"><a href="#将两者结合组合式继承" class="headerlink" title="将两者结合组合式继承"></a><strong>将两者结合</strong><code>组合式继承</code></h3><p>解决了两者的不足</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name<br>  <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'pink'</span>]<br>&#125;<br>A.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Im <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span>`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  A.call(<span class="hljs-keyword">this</span>, name)<br>  <span class="hljs-keyword">this</span>.age = age<br>&#125;<br><br><br>B.prototype = <span class="hljs-keyword">new</span> A()<br>B.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age<br>&#125;<br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> B(<span class="hljs-string">'jess'</span>, <span class="hljs-number">23</span>)<br>c.colors.push(<span class="hljs-string">'black'</span>)<br><span class="hljs-built_in">console</span>.log(c.name) <span class="hljs-comment">// jess</span><br><span class="hljs-built_in">console</span>.log(c.colors) <span class="hljs-comment">// [ 'red', 'blue', 'pink', 'black' ]</span><br><span class="hljs-built_in">console</span>.log(c.sayName()) <span class="hljs-comment">//Im jess</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B(<span class="hljs-string">'wangfei'</span>, <span class="hljs-number">25</span>)<br><span class="hljs-built_in">console</span>.log(b.colors) <span class="hljs-comment">// [ 'red', 'blue', 'pink' ]</span><br><span class="hljs-built_in">console</span>.log(b.sayName()) <span class="hljs-comment">//Im wangfei</span><br><span class="hljs-built_in">console</span>.log(b.sayAge()) <span class="hljs-comment">//25</span><br></code></pre></td></tr></table></figure><p>组合继承，构造函数A中定义了两个属性，name和colors，在原型上定义了方法sayName，在B中调用A构造函数，并且将非引用属性name作为参数传递，又定义了自己的属性，然后我们创建了自己的实例c，d，他们不仅有自己的属性，还共享着相同的方法</p><p>目前组合式继承是JavaScript中使用最多的继承模式，而且也保留了<code>instanceOf</code>、和<code>isPrototypeOf()</code>方法识别合成对象的能力</p><p><strong>### 原型式继承</strong></p><p>一种不涉及严格意义上构造函数的继承方法，出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// People函数会创建一个临时构造函数，将传入的独享赋值给这个构造函数的原型，然后返回这个临时类型的一个实例，实际上是对传入的对象执行了一次浅复制</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">o</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  F.prototype = o<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()<br>&#125;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nick'</span>,<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-string">'Shelly'</span>, <span class="hljs-string">'Court'</span>, <span class="hljs-string">'Van'</span>]<br>&#125;<br><span class="hljs-keyword">let</span> anotherPeople = People(person)<br>anotherPeople.friends.push(<span class="hljs-string">'Jess'</span>)<br><span class="hljs-built_in">console</span>.log(anotherPeople.friends) <span class="hljs-comment">// [ 'Shelly', 'Court', 'Van', 'Jess' ]</span><br><span class="hljs-keyword">let</span> yetAnotherPeople = People(person)<br>yetAnotherPeople.name = <span class="hljs-string">'Linda'</span><br><span class="hljs-built_in">console</span>.log(yetAnotherPeople.name) <span class="hljs-comment">// Linda</span><br>yetAnotherPeople.friends.push(<span class="hljs-string">'Barbie'</span>) <br><span class="hljs-built_in">console</span>.log(anotherPeople.friends) <span class="hljs-comment">//[ 'Shelly', 'Court', 'Van', 'Jess', 'Barbie' ]</span><br><br><span class="hljs-keyword">let</span> another = <span class="hljs-built_in">Object</span>.create(person, &#123;<br>  <span class="hljs-attr">name</span>: &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">'Greg'</span><br>  &#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(another.friends) <span class="hljs-comment">// //[ 'Shelly', 'Court', 'Van', 'Jess', 'Barbie' ]</span><br><span class="hljs-built_in">console</span>.log(another.name) <span class="hljs-comment">// Greg</span><br></code></pre></td></tr></table></figure><p>当我们有一个对象，想再它的基础上再创建一个新对象的时候，适合使用这种方式</p><p>并且：在es5中，将原型式继承的概念规范化了，这个方法接收两个参数如上方，<code>another</code>对象。在只有一个参数的时候，<code>Object.create()</code>与我们创建的<code>People()</code>方法相同，</p><p>第二个参数与<code>Object.defineProperties()</code>的第二个参数一样，每增加一个属性都通过各自的描述符来描述，<strong>这种方式添加的属性会遮蔽原型对象上的同名属性</strong></p><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承与原型式继承比较接近，思路类似于寄生构造函数和工厂模式，比原型式继承多了一步增强对象，为对象添加一些方法</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">o</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  F.prototype = o<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnotherObject</span>(<span class="hljs-params">original</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> clone = People(original)<br>  clone.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 增强对象，为对象增加方法</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hi'</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> clone<br>&#125;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">'Nicholas'</span>,<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-string">'Shelby'</span>, <span class="hljs-string">'Court'</span>, <span class="hljs-string">'Van'</span>]<br>&#125;<br><br><span class="hljs-keyword">let</span> anotherPerson = createAnotherObject(person)<br>anotherPerson.sayHi()<br></code></pre></td></tr></table></figure><p>在这段代码中，createAnother函数会接收一个参数，就是新对象的基准对象，这个对象original会被传给People函数，然后返回的新对象赋值给clone，接着给clone添加一个新的方法，sayHi，最后返回这个新的对象</p><p><strong>通过寄生式继承，给对象添加函数会导致函数难以重用，与构造函数模式类似。</strong></p><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>组合继承存在着效率问题，主要是父类构造函数始终会被调用两次，一次是在创建子类原型时调用，另一次是在子类构造函数中调用，本质上子类原型最终时要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name<br>  <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'orange'</span>]<br>&#125;<br><br>A.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  A.call(<span class="hljs-keyword">this</span>, name) <span class="hljs-comment">// 第二次调用A</span><br>  <span class="hljs-keyword">this</span>.age = age<br>&#125;<br><br>B.prototype = <span class="hljs-keyword">new</span> A() <span class="hljs-comment">// 第一次调用A</span><br>B.prototype.constructor = B<br></code></pre></td></tr></table></figure><p>上方时组合继承的例子，调用了两次构造函数A</p><p>而4寄生式组合继承通过盗用构造函数的属性，但是使用混合时原型链继承方法，思路是不通过父类构造函数给子构造函数原型赋值(<code>B.prototype = new A()</code>),而是取得父类原型的一个副本，说到底就是使用寄生式继承来继承父类原型</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name<br>  <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'orange'</span>]<br>&#125;<br><br>A.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  A.call(<span class="hljs-keyword">this</span>, name) <span class="hljs-comment">// 第二次调用A</span><br>  <span class="hljs-keyword">this</span>.age = age<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">Child, Parent</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>    <span class="hljs-comment">// 把F的原型指向Parent.prototype</span><br>    F.prototype = Parent.prototype;<br>    <span class="hljs-comment">// 把Child的原型指向一个新的F对象，F对象的原型正好指向Parent.prototype:</span><br>    Child.prototype = <span class="hljs-keyword">new</span> F();<br>    <span class="hljs-comment">// 把Child原型的构造函数修复为Child:</span><br>    Child.prototype.constructor = Child<br>&#125;<br><br>inheritPrototype(B, A)<br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> B()<br><span class="hljs-built_in">console</span>.log(c.colors)<br><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> B()<br>d.colors.push(<span class="hljs-string">'black'</span>)<br><span class="hljs-built_in">console</span>.log(c.colors)<br></code></pre></td></tr></table></figure><p>上方代码通过<code>inheritPrototype()</code>方法接收子类构造函数和父类构造函数</p><p>第一步：创建父类构造函数的副本，</p><p>第二步：给<code>prototype</code>对象设置<code>constructor</code>属性，解决由于重写原型导致默认<code>constructor</code>属性丢失问题</p><p>第三步：将新创建的对象赋值给子类原型</p><p><strong>这里只调用了一次父类A，避免了B原型上不必要也用不到的属性，效率更高且原型链仍然保持不变，可以说寄生式组合继承可以算是引用类型继承的最佳模式</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;JS&lt;/code&gt;中创建一个构造函数后就会有一个&lt;code&gt;property&lt;/code&gt;属性指向构造函数的原型对象，原型对象通过&lt;code&gt;constructor&lt;/code&gt;属性指回构造函数。（构造函数与原型对象互相指），此时通过构造函数创建的对象可以访问构造函数原型对象的属性，所以在访问这个新对象的属性的时候如果在自身搜索不到，JS会通过这条链去原型对象中搜索，上一层原型对象搜索不到还会继续层层向上搜索，比如每个对象的上层都有一个&lt;code&gt;Object&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;实际上所有引用类型都继承自Object，也是通过原型链实现的，这意味着这个实例有一个内部指针指向&lt;code&gt;Object.prototype&lt;/code&gt;,这也是自定义类型能否继承包括&lt;code&gt;toString()&lt;/code&gt;、&lt;code&gt;valueOf()&lt;/code&gt;这些方法的原因&lt;/p&gt;
&lt;p&gt;同时通过构造函数创建一个对象实例，实例内部指针指向原型对象，我们给这个原型对象起名为原型A，那么如果原型A是构造函数B的实例，那么原型A的内部指针就会指向构造函数b的原型对象B，&lt;/p&gt;
&lt;img src=&quot;/2021/03/31/2021-03-31-原型链/1.png&quot;&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="javaScript" scheme="http://www.lhjailj.top/tags/javaScript/"/>
    
      <category term="原型" scheme="http://www.lhjailj.top/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>observer</title>
    <link href="http://www.lhjailj.top/2021/03/30/2021-3-21-observer/"/>
    <id>http://www.lhjailj.top/2021/03/30/2021-3-21-observer/</id>
    <published>2021-03-30T09:51:19.000Z</published>
    <updated>2021-03-30T12:07:35.909Z</updated>
    
    <content type="html"><![CDATA[<p><code>**MutationObserver**</code>接口提供了监视对DOM树所做更改的能力。它被设计为旧的<code>Mutation Events</code>功能的替代品</p><p><code>MutationObserver</code>的实例要通过调用构造函数，并传入一个回调函数来创建：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure><p><code>observe()</code>方法：配置实例在dom更改匹配选项时，通知回调函数开始接收通知</p><p>新创建的实例不会关联DOM的任何部分，要把这个observer与DOM关联起来，需要使用<code>observe()</code>方法，这个方法必须接受两个参数；要观察的DOM节点，以及一个MutationObserverInit对象</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'&lt;body&gt; attributes changed'</span>))<br>    observer.observe(<span class="hljs-built_in">document</span>.body, &#123;<span class="hljs-attr">attributes</span>: <span class="hljs-literal">true</span>&#125;)<br>    <span class="hljs-built_in">document</span>.body.className = <span class="hljs-string">'foo'</span> <span class="hljs-comment">// &lt;body&gt; attributes changed</span><br></code></pre></td></tr></table></figure><p><code>disconnect()</code>方法。在默认情况下，观察的元素不被垃圾回收，就会响应DOM变化时间，从而被执行，要提前终止执行回调，可以调用disconnect方法</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'&lt;body&gt; attributes changed'</span>))<br>    observer.observe(<span class="hljs-built_in">document</span>.body, &#123;<span class="hljs-attr">attributes</span>: <span class="hljs-literal">true</span>&#125;)<br>    <span class="hljs-built_in">document</span>.body.className = <span class="hljs-string">'foo'</span><br>    observer.disconnect()<br>    <span class="hljs-built_in">document</span>.body.className = <span class="hljs-string">'bvar'</span> <span class="hljs-comment">// 没有输出</span><br></code></pre></td></tr></table></figure><p><code>MutationObserverInit</code>用来控制对目标节点的观察范围，包括属性变化、文本变化和子节点变化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;**MutationObserver**&lt;/code&gt;接口提供了监视对DOM树所做更改的能力。它被设计为旧的&lt;code&gt;Mutation Events&lt;/code&gt;功能的替代品&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MutationObserver&lt;/code&gt;的实例要通过
      
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="javaScript" scheme="http://www.lhjailj.top/tags/javaScript/"/>
    
      <category term="MutationObserver" scheme="http://www.lhjailj.top/tags/MutationObserver/"/>
    
  </entry>
  
  <entry>
    <title>对象的迭代</title>
    <link href="http://www.lhjailj.top/2021/03/30/2021-3-30-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%AD%E4%BB%A3/"/>
    <id>http://www.lhjailj.top/2021/03/30/2021-3-30-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%AD%E4%BB%A3/</id>
    <published>2021-03-30T03:28:12.000Z</published>
    <updated>2021-03-30T05:44:31.427Z</updated>
    
    <content type="html"><![CDATA[<p>在JavaScript有史以来的大部分时间内，迭代对象属性都是一个难题</p><p><code>Object.entries()</code>接收一个对象，返回对象的键值对数组</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">'lhj'</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>,<br>  sayName() &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<br>  &#125;<br>&#125;<br><br>obj.sayName()<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(obj))<br><span class="hljs-comment">/*[<br>  [ 'name', 'lhj' ],<br>  [ 'age', 23 ],<br>  [ 'sayName', [Function: sayName] ]<br>]*/</span><br></code></pre></td></tr></table></figure><p><code>Obejct.values()</code>接收一个对象返回对象的值数组，不包括键</p><a id="more"></a><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">'lhj'</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>,<br>  sayName() &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.values(obj)) <span class="hljs-comment">//  [ 'lhj', 23, [Function: sayName] ]</span><br></code></pre></td></tr></table></figure><p><strong>这两个方法执行对象的浅复制，并且非字符串属性会被转化为字符串</strong></p><p><code>for in</code>以<strong>任意</strong>顺序便利对象的除<code>Symbol</code>以外的<code>可枚举</code>属性</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> txt: string = <span class="hljs-string">''</span><br><span class="hljs-keyword">let</span> person: object = &#123;<span class="hljs-attr">fname</span>: <span class="hljs-string">'Bill'</span>, <span class="hljs-attr">lname</span>: <span class="hljs-string">'Gates'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">62</span>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> person) &#123;<br>    txt += person[i] + <span class="hljs-string">' '</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(txt) <span class="hljs-comment">// Bill Gates 62</span><br></code></pre></td></tr></table></figure><p><code>**Object.keys()**</code> 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，*<em>数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 *</em>。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(arr)); <span class="hljs-comment">// console: ['0', '1', '2']</span><br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-number">0</span>: <span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>: <span class="hljs-string">'b'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'c'</span> &#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(obj)); <span class="hljs-comment">// console: ['0', '1', '2']</span><br></code></pre></td></tr></table></figure><p><code>**Object.assign()**</code> 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">const</span> target2 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;<br><span class="hljs-keyword">const</span> target3 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<br><br><span class="hljs-built_in">Object</span>.assign(target1, target2, target3)<br><span class="hljs-built_in">console</span>.log(target1) &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JavaScript有史以来的大部分时间内，迭代对象属性都是一个难题&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.entries()&lt;/code&gt;接收一个对象，返回对象的键值对数组&lt;/p&gt;
&lt;figure class=&quot;hljs highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; obj = &amp;#123;&lt;br&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&#39;lhj&#39;&lt;/span&gt;,&lt;br&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;,&lt;br&gt;  sayName() &amp;#123;&lt;br&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.name)&lt;br&gt;  &amp;#125;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;br&gt;obj.sayName()&lt;br&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.entries(obj))&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/*[&lt;br&gt;  [ &#39;name&#39;, &#39;lhj&#39; ],&lt;br&gt;  [ &#39;age&#39;, 23 ],&lt;br&gt;  [ &#39;sayName&#39;, [Function: sayName] ]&lt;br&gt;]*/&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;Obejct.values()&lt;/code&gt;接收一个对象返回对象的值数组，不包括键&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
      <category term="对象" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="javaScript" scheme="http://www.lhjailj.top/tags/javaScript/"/>
    
      <category term="Object" scheme="http://www.lhjailj.top/tags/Object/"/>
    
      <category term="迭代" scheme="http://www.lhjailj.top/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>proxy与Reflect</title>
    <link href="http://www.lhjailj.top/2021/03/26/2021-03-26-proxy%E4%B8%8EReflect/"/>
    <id>http://www.lhjailj.top/2021/03/26/2021-03-26-proxy%E4%B8%8EReflect/</id>
    <published>2021-03-26T09:31:31.000Z</published>
    <updated>2021-03-29T00:42:25.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h1><p>代理是目标对象的抽象，使用代理类似于给目标对象制作一个替身，但由完全独立于目标对象，我可以直接操作对象本身做一些事情，也可以通过代理对象进行操作。直接操作会绕过代理对象施予的一些行为。</p><h2 id="代理对象Proxy"><a href="#代理对象Proxy" class="headerlink" title="代理对象Proxy"></a>代理对象Proxy</h2><p>Proxy用来修改某些操作的默认行为，代理由构造函数创建，必须接受两个参数：<strong>被代理的目标对象，和处理程序对象</strong>，这两个参数缺少任何一个都会报错，我们也可以使用简单的对象字面量创建空代理</p><h3 id="代理操作"><a href="#代理操作" class="headerlink" title="代理操作"></a>代理操作</h3><p>为对象target创建一个代理对象</p><a id="more"></a><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">'target'</span><br>&#125;<br><br><span class="hljs-keyword">const</span> handler = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);<br><br><span class="hljs-built_in">console</span>.log(target.id) <span class="hljs-comment">// target</span><br><span class="hljs-built_in">console</span>.log(proxy.id) <span class="hljs-comment">// target</span><br><br><span class="hljs-comment">// 给代理属性赋值会反映在两个对象上，因为两个对象访问的是同一个值</span><br>proxy.name = <span class="hljs-string">'dell'</span><br><span class="hljs-built_in">console</span>.log(target.name) <span class="hljs-comment">// 'dell'</span><br></code></pre></td></tr></table></figure><h3 id="代理捕获器"><a href="#代理捕获器" class="headerlink" title="代理捕获器"></a>代理捕获器</h3><p>代理的主要目的就是定义<code>trap</code>（捕获器），就是proxy的第二个参数处理程序对象中定义的<code>基本操作拦截器</code>每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接的在代理对象上使用</p><h4 id="例如定义一个get-捕获器拦截对象属性的读取"><a href="#例如定义一个get-捕获器拦截对象属性的读取" class="headerlink" title="例如定义一个get()捕获器拦截对象属性的读取"></a>例如定义一个<code>get()</code>捕获器<strong>拦截对象属性的读取</strong></h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">const</span> target = &#123;<br>   <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span><br> &#125;<br><br> <span class="hljs-keyword">const</span> handler = &#123;<br>   <span class="hljs-keyword">get</span>() &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-string">'handle override'</span><br>   &#125;<br> &#125;<br><br> <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);<br><span class="hljs-comment">// 访问原对象属性</span><br> <span class="hljs-built_in">console</span>.log(target.foo) <span class="hljs-comment">// foo</span><br> <span class="hljs-comment">// 访问代理对象属性，被拦截</span><br> <span class="hljs-built_in">console</span>.log(proxy.foo) <span class="hljs-comment">// handle override</span><br><br><span class="hljs-comment">// get捕获器的三个参数： 目标对象，要查询的属性，代理对象实例本身</span><br> <span class="hljs-keyword">const</span> target1 = &#123;<br>   <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span><br> &#125;<br><br> <span class="hljs-keyword">const</span> handler1 = &#123;<br>   <span class="hljs-keyword">get</span>(trapTarget, property, receiver) &#123;<br>     <span class="hljs-comment">// 返回目标对象的属性</span><br>     <span class="hljs-keyword">return</span> trapTarget[property]<br>   &#125;<br> &#125;<br> <span class="hljs-keyword">const</span> proxy1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target1, handler1)<br> <span class="hljs-built_in">console</span>.log(proxy1.foo)<br></code></pre></td></tr></table></figure><p>上面代码第一次对target对象进行代理，访问target的id是target， 而proxy的代理是handle override</p><p><strong>说明要使得<code>Proxy</code>起作用必须针对proxy实例进行操作，而不是针对目标对象</strong></p><h4 id="set-方法拦截某个属性的赋值操作，可以接受四个参数：-目标对象，属性名，属性值，和proxy实例本身"><a href="#set-方法拦截某个属性的赋值操作，可以接受四个参数：-目标对象，属性名，属性值，和proxy实例本身" class="headerlink" title="set()方法拦截某个属性的赋值操作，可以接受四个参数： 目标对象，属性名，属性值，和proxy实例本身"></a><code>set()</code>方法<strong>拦截某个属性的赋值操作，可以接受四个参数： 目标对象，属性名，属性值，和proxy实例本身</strong></h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> validator = &#123;<br>  <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, prop, value</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'age'</span>) &#123;<br>      <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">20</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'the age is too young'</span>)<br>      &#125;<br>    &#125;<br>    obj[prop] = value<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, validator)<br>person.age = <span class="hljs-number">10</span><br><span class="hljs-built_in">console</span>.log(person.age) <span class="hljs-comment">// throw TypeError</span><br>person.age = <span class="hljs-number">30</span> <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><p>如下代码，当目标对象自身的某个属性不可写的时候，那么set方法将不起作用</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> validator = &#123;<br>  <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, prop, value</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'age'</span>) &#123;<br>      <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">20</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'the age is too young'</span>)<br>      &#125;<br>    &#125;<br>    obj[prop] = value<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">'lhj'</span><br>&#125;<br><br><span class="hljs-built_in">Reflect</span>.defineProperty(target, <span class="hljs-string">'age'</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">23</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br><br>&#125;)<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, validator)<br>person.age = <span class="hljs-number">30</span><br><span class="hljs-built_in">console</span>.log(person.age)<br></code></pre></td></tr></table></figure><h4 id="apply-方法拦截函数调用、call、apply操作"><a href="#apply-方法拦截函数调用、call、apply操作" class="headerlink" title="apply()方法拦截函数调用、call、apply操作"></a><code>apply()</code>方法拦截函数调用、<code>call</code>、<code>apply</code>操作</h4><p>apply接受三个参数，分别是目标对象、目标对象的上下文对象（this）、和目标对象的数组</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> target = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">'I am the target'</span><br>&#125;<br><br><span class="hljs-keyword">var</span> handler = &#123;<br>  <span class="hljs-attr">apply</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'I am the proxy'</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)<br></code></pre></td></tr></table></figure><h4 id="has-方法，用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效，典型的操作就是in操作符"><a href="#has-方法，用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效，典型的操作就是in操作符" class="headerlink" title="has()方法，用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效，典型的操作就是in操作符"></a><code>has()</code>方法，用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效，典型的操作就是<code>in</code>操作符</h4><p><code>has()</code>方法接受两个参数，分别是目标对象、需查询的属性名</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> handler = &#123;<br>  has (target, key) &#123;<br>    <span class="hljs-keyword">if</span> (key[<span class="hljs-number">0</span>] === <span class="hljs-string">'_'</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> key <span class="hljs-keyword">in</span> target<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> target  = &#123; <span class="hljs-attr">_prop</span>: <span class="hljs-string">'foo'</span>, <span class="hljs-attr">prop</span>: <span class="hljs-string">'foo'</span>&#125;<br><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);<br><span class="hljs-string">'_prop'</span> <span class="hljs-keyword">in</span> proxy <span class="hljs-comment">// fasle</span><br></code></pre></td></tr></table></figure><p>has方法对in操作符进行了拦截，将有’_’的属性隐藏，不会被<code>in</code>发现</p><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是为了ES6操作对象而提供的API。也叫反射对象</p><p><strong>反射机制：指的是程序在运行时能活够获取自身的信息</strong></p><p>设计<code>Reflect</code>对象的目的：</p><p>将<code>Object</code>对象的一些明显属于语言内部的方法（例如<code>Obejct.defineProperty()</code>）放到<code>Proxy</code>上，现在某些这些方法在两者都可以访问，未来将只部署在<code>Reflect</code>上。</p><p><code>js的for in</code> 、<code>Array.isArray/Object.getOwnPropertyDescriptor</code>甚至是<code>Obejct.keys</code>都可以归类到反射这一类中，那么我们为什么还需要Reflect呢</p><p>原始写法：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = Obejct.create(<span class="hljs-literal">null</span>)<br>myObject.hasOwnProperty === <span class="hljs-literal">undefined</span><br><span class="hljs-built_in">Object</span>.property.hasOwnProperty.call(myObject, <span class="hljs-string">'foo'</span>)<br></code></pre></td></tr></table></figure><p>使用Reflect</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = Obejct.create(<span class="hljs-literal">null</span>)<br><span class="hljs-built_in">Reflect</span>.ownKeys(myObject)<br></code></pre></td></tr></table></figure><p><code>Reflect</code>对象一共有13个静态方法，他们大部分与<code>Object</code>对象的同名方法作用是相同的，而且与`Proxy对象的方法是一一对应的</p><ul><li>Reflect.apply(target, thisArg, args)</li><li>Reflect.construct(target, args)</li><li>Reflect.get(target, name, receiver)</li><li>Reflect.set(target, name, value, receiver)</li><li>Reflect.defineProperty(target, name, desc)</li><li>Reflect.deleteProperty(target, name)</li><li>Reflect.has(target, name)</li><li>Reflect.ownKeys(target)</li><li>Reflect.isExtensible(target)</li><li>Reflect.preventExtensions(target)</li><li>Reflect.getOwnPropertyDescriptor(target, name)</li><li>Reflect.getPrototypeOf(target)</li><li>Reflect.setPrototypeOf(target, prototype)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;代理基础&quot;&gt;&lt;a href=&quot;#代理基础&quot; class=&quot;headerlink&quot; title=&quot;代理基础&quot;&gt;&lt;/a&gt;代理基础&lt;/h1&gt;&lt;p&gt;代理是目标对象的抽象，使用代理类似于给目标对象制作一个替身，但由完全独立于目标对象，我可以直接操作对象本身做一些事情，也可以通过代理对象进行操作。直接操作会绕过代理对象施予的一些行为。&lt;/p&gt;
&lt;h2 id=&quot;代理对象Proxy&quot;&gt;&lt;a href=&quot;#代理对象Proxy&quot; class=&quot;headerlink&quot; title=&quot;代理对象Proxy&quot;&gt;&lt;/a&gt;代理对象Proxy&lt;/h2&gt;&lt;p&gt;Proxy用来修改某些操作的默认行为，代理由构造函数创建，必须接受两个参数：&lt;strong&gt;被代理的目标对象，和处理程序对象&lt;/strong&gt;，这两个参数缺少任何一个都会报错，我们也可以使用简单的对象字面量创建空代理&lt;/p&gt;
&lt;h3 id=&quot;代理操作&quot;&gt;&lt;a href=&quot;#代理操作&quot; class=&quot;headerlink&quot; title=&quot;代理操作&quot;&gt;&lt;/a&gt;代理操作&lt;/h3&gt;&lt;p&gt;为对象target创建一个代理对象&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
      <category term="对象" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="javaScript" scheme="http://www.lhjailj.top/tags/javaScript/"/>
    
      <category term="Object" scheme="http://www.lhjailj.top/tags/Object/"/>
    
      <category term="proxy" scheme="http://www.lhjailj.top/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>Object.defineProperty与Reflect.definProperty</title>
    <link href="http://www.lhjailj.top/2021/03/25/2021-03-25Objedct-defineProperty/"/>
    <id>http://www.lhjailj.top/2021/03/25/2021-03-25Objedct-defineProperty/</id>
    <published>2021-03-25T05:48:53.000Z</published>
    <updated>2021-03-26T09:43:34.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript中的对象"><a href="#JavaScript中的对象" class="headerlink" title="JavaScript中的对象"></a>JavaScript中的对象</h1><p>对象是js中的一种数据类型，到目前为止引用值的示例大多使用的是<code>Obejct</code>类型，并且ECMAScript中还定义了一个最特别的对象Global对象，代码不会显式的访问它，它所针对的是不属于任何对象的属性和方法，事实上不存在全局变量与全局函数这种东西，我们在全局作用域中定义的变量和函数都会变成Global对象的属性，包括<code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>实际上都是Global对象的方法。</p><h2 id="本篇记录的方法"><a href="#本篇记录的方法" class="headerlink" title="本篇记录的方法"></a>本篇记录的方法</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。<br><span class="hljs-built_in">Reflect</span>.defineProperty()<br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor()<span class="hljs-comment">// 读取对象属性的特征</span><br></code></pre></td></tr></table></figure><a id="more"></a><h2 id="对象的属性特征"><a href="#对象的属性特征" class="headerlink" title="对象的属性特征"></a>对象的属性特征</h2><p>ECMA5中定义只有内部才用的特性<strong>attribute</strong>，描述里属性<strong>property</strong>的各种特性。ECMA中有两种属性，数据属性和访问器属性</p><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><ol><li><p>[Configurable]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，例如直接在对象上定义属性，这个特性默认为true</p></li><li><p>[Enumerable]: 表示能否通过for-in循环返回属性，默认为true</p></li><li><p>[Writable]: 表示能否修改属性值，默认为true</p></li><li><p>[Value]: 包含这个属性的数据值，读取属性值的时候从这个位置读，写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined</p></li></ol><p>下方我们通过字面的方式定义了一个<code>person</code>对象，我们可以使用Object.getOwnPropertyDescriptor()方法来看一下<code>person</code>对象的数据属性</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>name = <span class="hljs-string">'Jess'</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(Obejct.getOwnPropertyDescriptor(person, <span class="hljs-string">'name'</span>))<br><span class="hljs-comment">// &#123; value: 'Jess', writable: true, enumerable: true, configurable: true &#125;</span><br></code></pre></td></tr></table></figure><p>可以看到当我们创建了一个对象之后，<strong>前三个特性默认为true，[Value]被设置为指定的值</strong></p><h4 id="修改数据属性"><a href="#修改数据属性" class="headerlink" title="修改数据属性"></a>修改数据属性</h4><p>通常我们不需要访问对象的数据属性，要修改属性的默认特性，就必须使用Object.defineProperty()方法，这个方法接收三个参数：<strong>要添加属性的对象，属性的名称，最后一个参数及对象拥有的四个数据属性，根据需要添加</strong></p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(person, <span class="hljs-string">'age'</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">23</span><br>&#125;)<br><span class="hljs-keyword">let</span> descriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="hljs-string">'age'</span>)<br><span class="hljs-built_in">console</span>.log(descriptor)<span class="hljs-comment">// &#123; value: 23, writable: false, enumerable: false, configurable: false &#125;</span><br></code></pre></td></tr></table></figure><p>我们使用<code>defineProperty()</code>方法为person对象添加一个age属性，并打印出age属性的特性，可以看到调用<code>defineProperty()</code>方法如果不指定<code>efineProperty()</code>、<code>enumerable</code>、 <code>configurable</code>默认为false</p><h3 id="访问器属性也叫存取属性"><a href="#访问器属性也叫存取属性" class="headerlink" title="访问器属性也叫存取属性"></a>访问器属性也叫存取属性</h3><p><em>存取属性</em>是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一；不能同时是两者。</p><p><code>get()</code>获取函数，在读取属性时调用，默认值为undefined</p><p><code>set()</code>设置函数，在写入属性时调用，默认值为undefined</p><h4 id="通过defineProperty定义访问器属性"><a href="#通过defineProperty定义访问器属性" class="headerlink" title="通过defineProperty定义访问器属性"></a>通过defineProperty定义访问器属性</h4><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;<br>  <span class="hljs-attr">year_</span>: <span class="hljs-number">2017</span>,<br>  <span class="hljs-attr">edition</span>: <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-built_in">Object</span>.defineProperty(book, <span class="hljs-string">'year'</span>, &#123;<br>  <span class="hljs-keyword">get</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.year_<br>  &#125;,<br>  <span class="hljs-keyword">set</span>(newVal) &#123;<br>    <span class="hljs-keyword">if</span> (newVal &gt; <span class="hljs-number">2017</span>) &#123;<br>      <span class="hljs-keyword">this</span>.year_ = newVal;<br>      <span class="hljs-keyword">this</span>.edition = newVal - <span class="hljs-number">2017</span>;<br>    &#125;<br>  &#125;<br>&#125;) <br>book.year = <span class="hljs-number">2018</span>;<br><span class="hljs-built_in">console</span>.log(book.edition); <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="Vue2中的双向数据绑定"><a href="#Vue2中的双向数据绑定" class="headerlink" title="Vue2中的双向数据绑定"></a>Vue2中的双向数据绑定</h2><p>我们都知道vue中的双向数据绑定是通过defineProperty实现的，查看vue源码</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 可以通过for in 遍历</span><br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (Dep.target) &#123;<br>      <span class="hljs-comment">// 收集依赖</span><br>      dep.depend()<br>    &#125;<br>    <span class="hljs-keyword">return</span> value<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span> (<span class="hljs-params">newVal</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 通知视图更新</span><br>    dep.notify()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>所以vue中对象新增属性为什么不更新</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">data  () &#123;<br>  <span class="hljs-keyword">return</span>  &#123;<br>    <span class="hljs-attr">obj</span>: &#123;<br>      <span class="hljs-attr">a</span>: <span class="hljs-number">1</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-attr">methods</span>: &#123;<br>  update () &#123;<br>    <span class="hljs-keyword">this</span>.obj.b = <span class="hljs-number">2</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中我们执行update更新obj时，预期视图也要随之更新，但实际是并不会，</p><p>因为<code>vue</code>中<code>data init</code>是在生命周期<code>created</code>之前的操作，<code>init</code>时会为data对象绑定一个观察者<code>Observer</code>，之后<code>data</code>中的字段更新都会通知依赖收集器<code>Dep</code>，触发更新。</p><p>然后，<code>definePropery</code>的访问器属性是对<strong>对象的属性进行操作</strong>，而非对象本身。所以当<code>Observer data</code>时新增属性并不存在，自然也不会有 <code>getter, setter</code>也就解释了为什么视图不更新 </p><h2 id="Reflect-defineProperty"><a href="#Reflect-defineProperty" class="headerlink" title="Reflect.defineProperty"></a>Reflect.defineProperty</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyDate</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br><span class="hljs-built_in">Object</span>.defineProperty(MyDate, <span class="hljs-string">'now'</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Date</span>.now()<br>&#125;)<br><br><span class="hljs-comment">//等同于</span><br><span class="hljs-built_in">Reflect</span>.defineProperty(MyDate, <span class="hljs-string">'now'</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Date</span>.now()<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用<code>Reflect.defineProperty</code>方法时，结果会返回一个布尔值，而<code>Obejct.defineProperty</code>如果运行失败则会报错，这意味着，使用Reflect你将不必去麻烦的处理报错信息</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript中的对象&quot;&gt;&lt;a href=&quot;#JavaScript中的对象&quot; class=&quot;headerlink&quot; title=&quot;JavaScript中的对象&quot;&gt;&lt;/a&gt;JavaScript中的对象&lt;/h1&gt;&lt;p&gt;对象是js中的一种数据类型，到目前为止引用值的示例大多使用的是&lt;code&gt;Obejct&lt;/code&gt;类型，并且ECMAScript中还定义了一个最特别的对象Global对象，代码不会显式的访问它，它所针对的是不属于任何对象的属性和方法，事实上不存在全局变量与全局函数这种东西，我们在全局作用域中定义的变量和函数都会变成Global对象的属性，包括&lt;code&gt;isNaN()&lt;/code&gt;、&lt;code&gt;isFinite()&lt;/code&gt;、&lt;code&gt;parseInt()&lt;/code&gt;实际上都是Global对象的方法。&lt;/p&gt;
&lt;h2 id=&quot;本篇记录的方法&quot;&gt;&lt;a href=&quot;#本篇记录的方法&quot; class=&quot;headerlink&quot; title=&quot;本篇记录的方法&quot;&gt;&lt;/a&gt;本篇记录的方法&lt;/h2&gt;&lt;figure class=&quot;hljs highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。&lt;br&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;Reflect&lt;/span&gt;.defineProperty()&lt;br&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.getOwnPropertyDescriptor()&lt;span class=&quot;hljs-comment&quot;&gt;// 读取对象属性的特征&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
      <category term="对象" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="javaScript" scheme="http://www.lhjailj.top/tags/javaScript/"/>
    
      <category term="Object" scheme="http://www.lhjailj.top/tags/Object/"/>
    
      <category term="defineProperty" scheme="http://www.lhjailj.top/tags/defineProperty/"/>
    
  </entry>
  
  <entry>
    <title>计算机是如何读懂我们的程序的呢</title>
    <link href="http://www.lhjailj.top/2021/03/21/2021-3-21-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E8%AF%BB%E6%87%82%E6%88%91%E4%BB%AC%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%91%A2/"/>
    <id>http://www.lhjailj.top/2021/03/21/2021-3-21-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E8%AF%BB%E6%87%82%E6%88%91%E4%BB%AC%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%91%A2/</id>
    <published>2021-03-21T11:30:15.000Z</published>
    <updated>2021-03-25T07:24:41.245Z</updated>
    
    <content type="html"><![CDATA[<p>事实上当我们上第一节编程课时会了解到，我们所学的语言是高级语言，计算机并不能看懂我们的程序，我们需要编译器进行编译，计算机读取编译器编译后的结果，并完成我们想要执行的操作，但是当我们第一次使用ide当我们在文本中敲上正确的语法像这样</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">#include &lt;stdio.h&gt;<br>  <br> int main() &#123;<br>printf("Hello World!")<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们按下运行，我们的工作被保存了，结果被输出了，我们得到了实时的结果。</p><a id="more"></a><p>但是事实上计算机读取当的文件是这样的</p><p>11100101100010010100100001010101</p><p>他们供计算机读取的列表，由二进制编写，也叫做机器码，我们经常可以看到计算机只能读取0，和1，为什么计算机只能读取这样的程序呢？</p><p>涉及到计算机的核心，处理器，<code>CPU</code>，处理器已经内置了处理这些指令的电路，只有当相应的指令被输入时。正确的电路才能连接在一起，完成对应的操作。指令中的某些0和1会引起某些晶体管的打开或关闭，最终将正确的电路连接到一起。</p><p>所以一开始我们的定义变量，if条件，循环，和函数，将转变为对应的机器指令。传达给计算机，这些高阶的结果可以让我们更轻松的思考程序。</p><p>但是如何将我们的一些程序翻译成计算机可读的机器语言，我们可以举简单的例子</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> x;<br>  x = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们定义一个变量x，并对其赋值为3，它看起来有某种结构，但是对于计算机，只是毫无意义的字符序列。只是文本，将源码传入编译器。</p><p>编译器首先将文本分为单独的标记，有点像编译器在理解程序中的单词含义，接着标记被分为多层次的结构，就是所谓的解析树</p><img src="/2021/03/21/2021-3-21-计算机是如何读懂我们的程序的呢/1.png"><p>接着编译器记录程序的上下文，包括变量和函数的名字，最后一步遍历树，转译成机器码</p><p>转译成机机器码确实有点难读和解释</p><img src="/2021/03/21/2021-3-21-计算机是如何读懂我们的程序的呢/2.jpg"><p>实际上读起来还很难，将其写成汇编代码</p><img src="/2021/03/21/2021-3-21-计算机是如何读懂我们的程序的呢/3.jpg"><img src="/2021/03/21/2021-3-21-计算机是如何读懂我们的程序的呢/4.jpg"><p>这里的步骤记录了这块内存中创建了变量x，并给他赋值为3，简单的赋值语句就这样完成了，但是条件语句与循环就变得没那么简单，因为并没有等价的语句，而要用现有指令来模拟它们的行为，在if语句中让我们执行下面这块代码</p><img src="/2021/03/21/2021-3-21-计算机是如何读懂我们的程序的呢/5.jpg"><p>只有当条件为真时执行这段代码，否则跳过这段代码，在汇编中，块中代码可以正常转译，但这之前还有条件指令<code>cmpl</code>以及下面的条件跳转指令<code>jg</code>，处理器根据前一条指令的结果，知道是否应该执行此跳转，该指令在处理器中临时设置一些标志，这样就可以记住一些结果当执行到跳转时用来判断，如果不符合跳出执行，执行器就会忽略该跳出指令，条件继续符合，继续执行块中的代码</p><p>但是有一个问题，如果在一台电脑编译程序，复制到另一台电脑并尝试运行它，可能不会工作，因为不同电脑可能有不同操作系统和不同的处理器，处理器可能使用了不同的机器指令！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事实上当我们上第一节编程课时会了解到，我们所学的语言是高级语言，计算机并不能看懂我们的程序，我们需要编译器进行编译，计算机读取编译器编译后的结果，并完成我们想要执行的操作，但是当我们第一次使用ide当我们在文本中敲上正确的语法像这样&lt;/p&gt;
&lt;figure class=&quot;hljs highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs java&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;br&gt;  &lt;br&gt; int main() &amp;#123;&lt;br&gt;		printf(&quot;Hello World!&quot;)&lt;br&gt;	&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;当我们按下运行，我们的工作被保存了，结果被输出了，我们得到了实时的结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://www.lhjailj.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>理解理解Vue的mixin</title>
    <link href="http://www.lhjailj.top/2021/03/17/2021-3-17-%E7%90%86%E8%A7%A3%E7%90%86%E8%A7%A3Vue%E7%9A%84mixin/"/>
    <id>http://www.lhjailj.top/2021/03/17/2021-3-17-%E7%90%86%E8%A7%A3%E7%90%86%E8%A7%A3Vue%E7%9A%84mixin/</id>
    <published>2021-03-17T14:21:57.000Z</published>
    <updated>2021-03-17T14:52:25.677Z</updated>
    
    <content type="html"><![CDATA[<p>mixin翻译为混入，创建它时也是创建一个对象，他也有data，也有生命周期，也有methods方法，所以根据官网的说法，他可以灵活的分发Vue组件中的可复用功能，当组件使用混入对象时，所有的对象选项都将被混合进入该组件本身的选项，也就是把mixin中的data与组件实例的对象混合在一起，那么当两者之间有重复时，会以特定的方式进行合并。</p><p>如果data中的变量与mixin中的变量冲突（也就是重复），那么以data中的变量优先，如果没有在data中发现该变量，则选择mixin中的变量</p><p>生命周期将会合并为一个数组，如果发生冲突，mixin先执行，实例后执行</p><p>methods，coimponent,directives将会合并为一个对象，如果出现冲突，取组件实例中的方法</p><a id="more"></a><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMixin = &#123;<br>  <span class="hljs-attr">methods</span>: &#123;<br>    foo() &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>)<br>    &#125;,<br>    conflicting() &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'from mixin'</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;<br>  <span class="hljs-attr">mixins</span>: [myMixin],<br>  <span class="hljs-attr">methods</span>: &#123;<br>    bar() &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar'</span>)<br>    &#125;,<br>    conflicting() &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'from self'</span>)<br>    &#125;<br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">const</span> vm = app.mount(<span class="hljs-string">'#mixins-basic'</span>)<br><br>vm.foo() <span class="hljs-comment">// =&gt; "foo"</span><br>vm.bar() <span class="hljs-comment">// =&gt; "bar"</span><br>vm.conflicting() <span class="hljs-comment">// =&gt; "from self"</span><br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mixin翻译为混入，创建它时也是创建一个对象，他也有data，也有生命周期，也有methods方法，所以根据官网的说法，他可以灵活的分发Vue组件中的可复用功能，当组件使用混入对象时，所有的对象选项都将被混合进入该组件本身的选项，也就是把mixin中的data与组件实例的对象混合在一起，那么当两者之间有重复时，会以特定的方式进行合并。&lt;/p&gt;
&lt;p&gt;如果data中的变量与mixin中的变量冲突（也就是重复），那么以data中的变量优先，如果没有在data中发现该变量，则选择mixin中的变量&lt;/p&gt;
&lt;p&gt;生命周期将会合并为一个数组，如果发生冲突，mixin先执行，实例后执行&lt;/p&gt;
&lt;p&gt;methods，coimponent,directives将会合并为一个对象，如果出现冲突，取组件实例中的方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="slot" scheme="http://www.lhjailj.top/tags/slot/"/>
    
  </entry>
  
  <entry>
    <title>2021-3-14-Vueslot简析</title>
    <link href="http://www.lhjailj.top/2021/03/14/2021-3-14-Vueslot%E7%AE%80%E6%9E%90/"/>
    <id>http://www.lhjailj.top/2021/03/14/2021-3-14-Vueslot%E7%AE%80%E6%9E%90/</id>
    <published>2021-03-14T12:59:03.000Z</published>
    <updated>2021-03-22T01:44:46.299Z</updated>
    
    <content type="html"><![CDATA[<p>关于slot，在组件化的模式下，通常遇到一个会多次使用的元素，例如封装一个后台管理系统常需要用到的表格，弹窗等等组件，但是通常在复用性高的情况下又有略微的不同，例如一个弹窗，有的情况可能需要仅仅展示一个图片一个按钮，有时又需要展示出这个弹窗的标题，那么根据不同的情况，我们会在这个组件中穿插不同的元素，这个时候就需要用到插槽。</p><a id="more"></a><img src="/2021/03/14/2021-3-14-Vueslot简析/1.png"><p>例：我们定义了一个子组件<code>myform</code>，并且在父组件中调用了两次，但是第一次我们需要在input下面放上点击按钮，而第二次并不需要，这个时候slot就派上了用场</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;<br>      data() &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">needButton</span>: <span class="hljs-string">'我需要一个按钮'</span>,<br>          <span class="hljs-attr">noNeed</span>: <span class="hljs-string">'不太需要'</span><br>        &#125;<br>      &#125;,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">`<br>        &lt;myform :text="needButton"&gt;<br>          &lt;button&gt;按钮&lt;/button&gt;<br>          &lt;hr /&gt;<br>        &lt;/myform&gt;<br>        &lt;myform :text="noNeed" /&gt;<br>      `</span><br>    &#125;)<br><br>    app.component(<span class="hljs-string">'myform'</span>, &#123;<br>      <span class="hljs-attr">props</span>: [<span class="hljs-string">'text'</span>],<br>      <span class="hljs-attr">methods</span>: &#123;<br>        handleClick() &#123;<br>          alert(<span class="hljs-number">123</span>)<br>        &#125;<br>      &#125;,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;<br>        &lt;input /&gt;<br>        &lt;div @click="handleClick"&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;<br>        &lt;slot /&gt;<br>        &lt;/div&gt;`</span><br>    &#125;)<br>    <span class="hljs-keyword">const</span> vm = app.mount(<span class="hljs-string">'#root'</span>)<br></code></pre></td></tr></table></figure><p>上面我们将不太确定的具体需要什么元素的位置使用slot代替，当我们在父组件调用子组件时，插入的元素将自动被slot元素承载</p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>当子组件渲染的内容由父组件决定的时候，我们可以使用作用域插槽，父组件可以调用子组件中的item数据，</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;<br>  <span class="hljs-comment">//这里也可以使用解构&#123;slotPros.item&#125;</span><br>     <span class="hljs-comment">// &lt;list v-slot="&#123;item&#125;"&gt;</span><br>     <span class="hljs-comment">// &lt;div&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;</span><br>     <span class="hljs-comment">// &lt;/list&gt;`</span><br>      <span class="hljs-attr">template</span>: <span class="hljs-string">`<br>      &lt;list v-slot="slotProps"&gt;<br>        &lt;div&gt;&#123;&#123;slotProps.item&#125;&#125;&lt;/div&gt;<br>      &lt;/list&gt;<br>      `</span><br>    &#125;)<br><br>    app.component(<span class="hljs-string">'list'</span>, &#123;<br>      data() &#123;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">list</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;&#125;,<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">`<br>        &lt;div&gt;<br>          &lt;slot v-for="item in list" :item="item"&gt;&lt;/slot&gt;<br>        &lt;/div&gt;<br>      `</span><br>    &#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于slot，在组件化的模式下，通常遇到一个会多次使用的元素，例如封装一个后台管理系统常需要用到的表格，弹窗等等组件，但是通常在复用性高的情况下又有略微的不同，例如一个弹窗，有的情况可能需要仅仅展示一个图片一个按钮，有时又需要展示出这个弹窗的标题，那么根据不同的情况，我们会在这个组件中穿插不同的元素，这个时候就需要用到插槽。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
      <category term="slot" scheme="http://www.lhjailj.top/tags/slot/"/>
    
  </entry>
  
  <entry>
    <title>2021-3-14CSS简写</title>
    <link href="http://www.lhjailj.top/2021/03/14/2021-3-14CSS%E7%AE%80%E5%86%99/"/>
    <id>http://www.lhjailj.top/2021/03/14/2021-3-14CSS%E7%AE%80%E5%86%99/</id>
    <published>2021-03-14T11:46:40.000Z</published>
    <updated>2021-03-14T12:00:23.836Z</updated>
    
    <content type="html"><![CDATA[<p>关于合理的简写：</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">background</span>: <span class="hljs-selector-tag">blue</span>;<br><span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-tag">blue</span>;<br></code></pre></td></tr></table></figure><p>前者是简写，可以确保你得到一个蓝色的纯色背景，但是如果你使用展开式的单个属性，那么这个元素的背景最终可能显示为一个粉红色的图案，一张图片，或者其他任何东西，因为同时可能会有一条<code>background-image</code>在其作用，展开式的写法不会帮助我们清空所有其他相关的属性，<strong>你设置了一个蓝色背景，又在下面几行设置了一张背景图片，那么你永远也看不到这个蓝色的背景图片!</strong></p>{% asset_img 1.png %}<p>比如我们要实现li前面的背景图片可以设置</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CSS">background:  #badcfe url(./images/icon2.gif) no-repeat left center;<br></code></pre></td></tr></table></figure><p>但是这个是我在设置<code>list-style-image</code>无效的情况下的无奈之举</p><p>当时使用的是dl自定义列表，那么要使用</p><figure class="hljs highlight CSS"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">list-item</span>;<br><span class="hljs-selector-tag">list-style</span>: <span class="hljs-selector-tag">url</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于合理的简写：&lt;/p&gt;
&lt;figure class=&quot;hljs highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="CSS3" scheme="http://www.lhjailj.top/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>HTTP请求参数</title>
    <link href="http://www.lhjailj.top/2020/11/08/2020-01-10-%E5%85%B3%E4%BA%8EHTTP%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/"/>
    <id>http://www.lhjailj.top/2020/11/08/2020-01-10-%E5%85%B3%E4%BA%8EHTTP%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/</id>
    <published>2020-11-08T10:14:41.000Z</published>
    <updated>2021-03-10T09:32:21.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP请求参数的三种格式"><a href="#HTTP请求参数的三种格式" class="headerlink" title="HTTP请求参数的三种格式"></a>HTTP请求参数的三种格式</h2><p>记录关于<code>Query String Parameters</code>、<code>Form Data</code>、 <code>Request Payload</code>,三种格式的区别</p><h3 id="Query-String-Parameters"><a href="#Query-String-Parameters" class="headerlink" title="Query String Parameters"></a><code>Query String Parameters</code></h3><p>格式为?key=value&amp;key=value</p><p>参数通过url String的形式传递，常用在GET请求方式时使用，那么通过postman等测试工具测试接口时，要根据对应方式，对应类型去添加参数，</p><h3 id="Form-Data"><a href="#Form-Data" class="headerlink" title="Form Data"></a><code>Form Data</code></h3><p>当Content-Type为<code>application/x-www-form-urlencoded;charset=utf-8</code>时，参数以<code>Form Data</code>的形式传递给接口，但是不会显示在url上</p><h2 id="Request-Playload"><a href="#Request-Playload" class="headerlink" title="Request Playload"></a><code>Request Playload</code></h2><p>当Content-Type为<code>application/json;charset=utf-8</code>时，参数会以Request payload的形式，数据以json的形式传递给接口，并且不会显示在接口的url上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP请求参数的三种格式&quot;&gt;&lt;a href=&quot;#HTTP请求参数的三种格式&quot; class=&quot;headerlink&quot; title=&quot;HTTP请求参数的三种格式&quot;&gt;&lt;/a&gt;HTTP请求参数的三种格式&lt;/h2&gt;&lt;p&gt;记录关于&lt;code&gt;Query String Par
      
    
    </summary>
    
    
      <category term="网络" scheme="http://www.lhjailj.top/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Http" scheme="http://www.lhjailj.top/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>20201029Http</title>
    <link href="http://www.lhjailj.top/2020/10/29/2020-10-29-Http%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.lhjailj.top/2020/10/29/2020-10-29-Http%E7%AE%80%E4%BB%8B/</id>
    <published>2020-10-29T14:30:52.000Z</published>
    <updated>2021-03-10T09:34:09.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Http简介"><a href="#Http简介" class="headerlink" title="Http简介"></a>Http简介</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p><a id="more"></a><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><h2 id="http的工作方式"><a href="#http的工作方式" class="headerlink" title="http的工作方式"></a>http的工作方式</h2><p><strong>http</strong>采用请求/响应的工作方式</p><p>服务器不断监听TCP端口等待客户端发送请求，当客户端发送请求是建立TCP连接，以http请求报文的形式发送页面请求，服务器以响应报文的方式发送响应，</p><p>http的每次通信都必须包含头部信息（HTTP header），用来描述一些元数据，其他的新增功能还包括状态吗（status code）,多字符集支持、多部分发送、权限（authorization）、缓存（cache）、内容编码（content encoding）等</p><h3 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h3><figure class="hljs highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> HTTP/1.0<br><span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)<br><span class="hljs-attribute">Accept</span>: */*<br></code></pre></td></tr></table></figure><p>Accept：在发送请求的时候告诉服务器自己可以接受哪些数据格式</p><h3 id="响应格式"><a href="#响应格式" class="headerlink" title="响应格式"></a>响应格式</h3><figure class="hljs highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http">HTTP/1.0 <span class="hljs-number">200</span> OK <br><span class="hljs-attribute">Content-Type</span>: text/plain<br><span class="hljs-attribute">Content-Length</span>: 137582<br><span class="hljs-attribute">Expires</span>: Thu, 05 Dec 1997 16:00:00 GMT<br><span class="hljs-attribute">Last-Modified</span>: Wed, 5 August 1996 15:55:28 GMT<br><span class="hljs-attribute">Server</span>: Apache 0.84<br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="content-Type字段"><a href="#content-Type字段" class="headerlink" title="content Type字段"></a>content Type字段</h3><p>关于字符的编码，1.0版本规定，头部信息必须是ASCII码，后面的数据可以是任何形式，所以服务器响应的时候必须告诉客户端数据是什么格式，content Type的作用就是表明数据的格式</p><ul><li>text/plain</li><li>text/html</li><li>text/css</li><li>image/jpeg</li><li>image/png</li><li>image/svg+xml</li><li>audio/mp4</li><li>video/mp4</li><li>application/javascript</li><li>application/pdf</li><li>application/zip</li><li>application/atom+xml</li></ul><h3 id="关于http1-0的缺点"><a href="#关于http1-0的缺点" class="headerlink" title="关于http1.0的缺点"></a>关于http1.0的缺点</h3><p>每个TCP连接只能发送一个请求，发送数据完毕，连接就要关闭，如果还要请求其他资源，就必须再新建一个连接。TCP新建的成本很高，需要进行三次握手，所以当网页加载外部资源越来越多的时候，这个问题就愈发突出了</p><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p>1.1版最大的变化就是引入了持久连接，即TCP连接默认不关闭，可以被多个请求服用，不用声明Connection：keep-alive</p><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。</p><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>GET请求：请求指定页面的信息，并返回实体主体</p><p>HEAD：类似get请求，只不过返回的响应中没有具体的内容，用于获取报头</p><p>POST：像指定资源提交数据进行处理请求，（例如提交表单或上传文件，数据被包含在请求体中</p><p>PUT：从客户端向服务器传送的数据取代指定的文档的内容</p><p>DELETE：请求服务器删除指定页面</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Http简介&quot;&gt;&lt;a href=&quot;#Http简介&quot; class=&quot;headerlink&quot; title=&quot;Http简介&quot;&gt;&lt;/a&gt;Http简介&lt;/h2&gt;&lt;p&gt;HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。&lt;/p&gt;
&lt;p&gt;HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。&lt;/p&gt;
&lt;p&gt;HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://www.lhjailj.top/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Http" scheme="http://www.lhjailj.top/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>2020_1027mysql</title>
    <link href="http://www.lhjailj.top/2020/10/26/2020-10-27-mysql/"/>
    <id>http://www.lhjailj.top/2020/10/26/2020-10-27-mysql/</id>
    <published>2020-10-26T13:01:09.000Z</published>
    <updated>2021-03-10T10:16:14.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Msql数据库概述"><a href="#Msql数据库概述" class="headerlink" title="Msql数据库概述"></a>Msql数据库概述</h1><p>Msql为关系数据库，关系数据库的特点：</p><ul><li>理论基础：集合论和关系代数</li><li>具体表象：用二维表（有行和列）组织数据</li><li>编程语言：结构化查询语言（sql）</li></ul><a id="more"></a><h2 id="mac的msql启动"><a href="#mac的msql启动" class="headerlink" title="mac的msql启动"></a>mac的msql启动</h2><p>启动mySql服务:sudo /usr/local/mysql/support-files/mysql.server start，<strong>输入本机密码</strong></p><p>关闭：sudo /usr/local/mysql/support-files/mysql.server stop</p><p>连接mysql：/usr/local/MySQL/bin/mysql -u root -p   输入数据库密码：<strong><strong>**</strong></strong></p><p>退出：exit</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>查看所有数据库</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show databases;<br></code></pre></td></tr></table></figure><p>这里要注意加上<strong>分号</strong></p><p>切换到指定数据库</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysq">use mysql;<br></code></pre></td></tr></table></figure><p>查看数据库下所有的表</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show tables;<br></code></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>通常可以将SQL分为三类：DDL（数据定义语言）、DML（数据操作语言）、DCL（数据控制语言）。DDL主要用于创建（ceate）、删除（drop）、修改（alter）数据库中的对象，比如创建、删除、和修改二维表；DML主要负责插入数据（insert）、删除数据（delete）、更新数据（update）和查询（select）；DCL通常用于授予权限（grant）和召回权限（revoke）</p><ol><li><p>DDL数据定义语言</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 如果存在名为school的数据库就删除它<br>drop database if exists school;<br><br>-- 创建名为school的数据库并设置默认的字符集和排序方式<br>create database school default charset utf8;<br><br>-- 切换到school数据库上下文环境<br>use school;<br><br>-- 创建学院表<br>create table tb_college<br>(<br>collid int auto_increment comment &apos;编号&apos;,<br>collname varchar(50) not null comment &apos;名称&apos;,<br>collintro varchar(500) default &apos;&apos; comment &apos;介绍&apos;,<br>primary key (collid)<br>);<br><br>-- 创建学生表<br>create table tb_student<br>(<br>stuid int not null comment &apos;学号&apos;,<br>stuname varchar(20) not null comment &apos;姓名&apos;,<br>stusex boolean default 1 comment &apos;性别&apos;,<br>stubirth date not null comment &apos;出生日期&apos;,<br>stuaddr varchar(255) default &apos;&apos; comment &apos;籍贯&apos;,<br>collid int not null comment &apos;所属学院&apos;,<br>primary key (stuid),<br>foreign key (collid) references tb_college (collid)<br>);<br><br>-- 创建教师表<br>create table tb_teacher<br>(<br>teaid int not null comment &apos;工号&apos;,<br>teaname varchar(20) not null comment &apos;姓名&apos;,<br>teatitle varchar(10) default &apos;助教&apos; comment &apos;职称&apos;,<br>collid int not null comment &apos;所属学院&apos;,<br>primary key (teaid),<br>foreign key (collid) references tb_college (collid)<br>);<br><br>-- 创建课程表<br>create table tb_course<br>(<br>couid int not null comment &apos;编号&apos;,<br>couname varchar(50) not null comment &apos;名称&apos;,<br>coucredit int not null comment &apos;学分&apos;,<br>teaid int not null comment &apos;授课老师&apos;,<br>primary key (couid),<br>foreign key (teaid) references tb_teacher (teaid)<br>);<br><br>-- 创建选课记录表<br>create table tb_record<br>(<br>recid int auto_increment comment &apos;选课记录编号&apos;,<br>sid int not null comment &apos;选课学生&apos;,<br>cid int not null comment &apos;所选课程&apos;,<br>seldate datetime default now() comment &apos;选课时间日期&apos;,<br>score decimal(4,1) comment &apos;考试成绩&apos;,<br>primary key (recid),<br>foreign key (sid) references tb_student (stuid),<br>foreign key (cid) references tb_course (couid),<br>unique (sid, cid)<br>);<br></code></pre></td></tr></table></figure></li><li><p>DML</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 插入学院数据<br>insert into tb_college (collname, collintro) values <br>(&apos;计算机学院&apos;, &apos;计算机学院1958年设立计算机专业，1981年建立计算机科学系，1998年设立计算机学院，2005年5月，为了进一步整合教学和科研资源，学校决定，计算机学院和软件学院行政班子合并统一运作、实行教学和学生管理独立运行的模式。 学院下设三个系：计算机科学与技术系、物联网工程系、计算金融系；两个研究所：图象图形研究所、网络空间安全研究院（2015年成立）；三个教学实验中心：计算机基础教学实验中心、IBM技术中心和计算机专业实验中心。&apos;),<br>(&apos;外国语学院&apos;, &apos;四川大学外国语学院设有7个教学单位，6个文理兼收的本科专业；拥有1个一级学科博士授予点，3个二级学科博士授予点，5个一级学科硕士学位授权点，5个二级学科硕士学位授权点，5个硕士专业授权领域，同时还有2个硕士专业学位（MTI）专业；有教职员工210余人，其中教授、副教授80余人，教师中获得中国国内外名校博士学位和正在职攻读博士学位的教师比例占专任教师的60%以上。&apos;),<br>(&apos;经济管理学院&apos;, &apos;四川大学经济学院前身是创办于1905年的四川大学经济科；已故经济学家彭迪先、张与九、蒋学模、胡寄窗、陶大镛、胡代光，以及当代学者刘诗白等曾先后在此任教或学习；1905年，四川大学设经济科；1924年，四川大学经济系成立；1998年，四川大学经济管理学院变更为四川大学经济学院。&apos;);<br><br>-- 插入学生数据<br>insert into tb_student (stuid, stuname, stusex, stubirth, stuaddr, collid) values<br>(1001, &apos;杨逍&apos;, 1, &apos;1990-3-4&apos;, &apos;四川成都&apos;, 1),<br>(1002, &apos;任我行&apos;, 1, &apos;1992-2-2&apos;, &apos;湖南长沙&apos;, 1),<br>(1033, &apos;王语嫣&apos;, 0, &apos;1989-12-3&apos;, &apos;四川成都&apos;, 1),<br>(1572, &apos;岳不群&apos;, 1, &apos;1993-7-19&apos;, &apos;陕西咸阳&apos;, 1),<br>(1378, &apos;纪嫣然&apos;, 0, &apos;1995-8-12&apos;, &apos;四川绵阳&apos;, 1),<br>(1954, &apos;林平之&apos;, 1, &apos;1994-9-20&apos;, &apos;福建莆田&apos;, 1),<br>(2035, &apos;东方不败&apos;, 1, &apos;1988-6-30&apos;, null, 2),<br>(3011, &apos;林震南&apos;, 1, &apos;1985-12-12&apos;, &apos;福建莆田&apos;, 3),<br>(3755, &apos;项少龙&apos;, 1, &apos;1993-1-25&apos;, null, 3),<br>(3923, &apos;杨不悔&apos;, 0, &apos;1985-4-17&apos;, &apos;四川成都&apos;, 3),<br>(4040, &apos;隔壁老王&apos;, 1, &apos;1989-1-1&apos;, &apos;四川成都&apos;, 2);<br><br>-- 删除学生数据<br>delete from tb_student where stuid=4040;<br><br>-- 更新学生数据<br>update tb_student set stuname=&apos;杨过&apos;, stuaddr=&apos;湖南长沙&apos; where stuid=1001;<br><br>-- 插入老师数据<br>insert into tb_teacher (teaid, teaname, teatitle, collid) values <br>(1122, &apos;张三丰&apos;, &apos;教授&apos;, 1),<br>(1133, &apos;宋远桥&apos;, &apos;副教授&apos;, 1),<br>(1144, &apos;杨逍&apos;, &apos;副教授&apos;, 1),<br>(2255, &apos;范遥&apos;, &apos;副教授&apos;, 2),<br>(3366, &apos;韦一笑&apos;, &apos;讲师&apos;, 3);<br><br>-- 插入课程数据<br>insert into tb_course (couid, couname, coucredit, teaid) values <br>(1111, &apos;Python程序设计&apos;, 3, 1122),<br>(2222, &apos;Web前端开发&apos;, 2, 1122),<br>(3333, &apos;操作系统&apos;, 4, 1122),<br>(4444, &apos;计算机网络&apos;, 2, 1133),<br>(5555, &apos;编译原理&apos;, 4, 1144),<br>(6666, &apos;算法和数据结构&apos;, 3, 1144),<br>(7777, &apos;经贸法语&apos;, 3, 2255),<br>(8888, &apos;成本会计&apos;, 2, 3366),<br>(9999, &apos;审计学&apos;, 3, 3366);<br><br>-- 插入选课数据<br>insert into tb_record (sid, cid, seldate, score) values <br>(1001, 1111, &apos;2017-09-01&apos;, 95),<br>(1001, 2222, &apos;2017-09-01&apos;, 87.5),<br>(1001, 3333, &apos;2017-09-01&apos;, 100),<br>(1001, 4444, &apos;2018-09-03&apos;, null),<br>(1001, 6666, &apos;2017-09-02&apos;, 100),<br>(1002, 1111, &apos;2017-09-03&apos;, 65),<br>(1002, 5555, &apos;2017-09-01&apos;, 42),<br>(1033, 1111, &apos;2017-09-03&apos;, 92.5),<br>(1033, 4444, &apos;2017-09-01&apos;, 78),<br>(1033, 5555, &apos;2017-09-01&apos;, 82.5),<br>(1572, 1111, &apos;2017-09-02&apos;, 78),<br>(1378, 1111, &apos;2017-09-05&apos;, 82),<br>(1378, 7777, &apos;2017-09-02&apos;, 65.5),<br>(2035, 7777, &apos;2018-09-03&apos;, 88),<br>(2035, 9999, default, null),<br>(3755, 1111, default, null),<br>(3755, 8888, default, null),<br>(3755, 9999, &apos;2017-09-01&apos;, 92);<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询所有学生信息<br>select * from tb_student;<br><br>-- 查询所以课程名称及学分（投影和别名）<br>select counname, coucredit from tb_course;<br>select couname as 课程名称, coucredit as 学分 from tb_course;<br><br>-- 查询所以学生的姓名和性别（条件运算）<br>select stuname as 姓名, case stusex when 1 then &apos;男&apos; else &apos;女&apos; end as 性别 from tb_student;<br>select stuname as 姓名, if(stusex, &apos;男&apos;, &apos;女&apos;) as 性别 from tb_student;<br><br>-- 查询所有女学生的姓名和出生日期(筛选)<br>select stuname, stubirth from tb_student where stusex=0;<br><br>-- 查询所有80后学生的姓名、性别和出生日期(筛选)<br>select stuname, stusex, stubirth from tb_student where stubirth&gt;=&apos;1980-1-1&apos; and stubirth&lt;=&apos;1989-12-31&apos;;<br>select stuname, stusex, stubirth from tb_student where stubirth between &apos;1980-1-1&apos; and &apos;1989-12-31&apos;;<br><br>-- 查询姓&quot;杨&quot;的学生姓名和性别(模糊)<br>select stuname, stusex from tb_student where stuname like &apos;杨%&apos;;<br><br>-- 查询姓&quot;杨&quot;名字两个字的学生姓名和性别(模糊)<br>select stuname, stusex from tb_student where stuname like &apos;杨_&apos;;<br><br>-- 查询姓&quot;杨&quot;名字三个字的学生姓名和性别(模糊)<br>select stuname, stusex from tb_student where stuname like &apos;杨__&apos;;<br><br>-- 查询名字中有&quot;不&quot;字或&quot;嫣&quot;字的学生的姓名(模糊)<br>select stuname, stusex from tb_student where stuname like &apos;%不%&apos; or stuname like &apos;%嫣%&apos;;<br><br>-- 查询没有录入家庭住址的学生姓名(空值)<br>select stuname from tb_student where stuaddr is null;<br><br>-- 查询录入了家庭住址的学生姓名(空值)<br>select stuname from tb_student where stuaddr is not null;<br><br>-- 查询学生选课的所有日期(去重)<br>select distinct seldate from tb_record;<br><br>-- 查询学生的家庭住址(去重)<br>select distinct stuaddr from tb_student where stuaddr is not null;<br><br>-- 查询男学生的姓名和生日按年龄从大到小排列(排序)<br>select stuname as 姓名, datediff(curdate(), stubirth) div 365 as 年龄 from tb_student where stusex=1 order by 年龄 desc;<br><br>-- 查询年龄最大的学生的出生日期(聚合函数)<br>select min(stubirth) from tb_student;<br><br>-- 查询年龄最小的学生的出生日期(聚合函数)<br>select max(stubirth) from tb_student;<br><br>-- 查询男女学生的人数(分组和聚合函数)<br>select stusex, count(*) from tb_student group by stusex;<br><br>-- 查询课程编号为1111的课程的平均成绩(筛选和聚合函数)<br>select avg(score) from tb_record where cid=1111;<br><br>-- 查询学号为1001的学生所有课程的平均分(筛选和聚合函数)<br>select avg(score) from tb_record where sid=1001;<br><br>-- 查询每个学生的学号和平均成绩(分组和聚合函数)<br>select sid as 学号, avg(score) as 平均分 from tb_record group by sid;<br><br>-- 查询平均成绩大于等于90分的学生的学号和平均成绩<br>-- 分组以前的筛选使用where子句 / 分组以后的筛选使用having子句<br>select sid as 学号, avg(score) as 平均分 from tb_record group by sid having 平均分&gt;=90;<br><br>-- 查询年龄最大的学生的姓名(子查询/嵌套的查询)<br>select stuname from tb_student where stubirth=( select min(stubirth) from tb_student );<br><br>-- 查询年龄最大的学生姓名和年龄(子查询+运算)<br>select stuname as 姓名, datediff(curdate(), stubirth) div 365 as 年龄 from tb_student where stubirth=( select min(stubirth) from tb_student );<br><br>-- 查询选了两门以上的课程的学生姓名(子查询/分组条件/集合运算)<br>select stuname from tb_student where stuid in ( select stuid from tb_record group by stuid having count(stuid)&gt;2 );<br><br>-- 查询学生姓名、课程名称以及成绩(连接查询)<br>select stuname, couname, score from tb_student t1, tb_course t2, tb_record t3 where stuid=sid and couid=cid and score is not null;<br><br>-- 查询学生姓名、课程名称以及成绩按成绩从高到低查询第11-15条记录(内连接+分页)<br>select stuname, couname, score from tb_student inner join tb_record on stuid=sid inner join tb_course on couid=cid where score is not null order by score desc limit 5 offset 10;<br><br>select stuname, couname, score from tb_student inner join tb_record on stuid=sid inner join tb_course on couid=cid where score is not null order by score desc limit 10, 5;<br><br>-- 查询选课学生的姓名和平均成绩(子查询和连接查询)<br>select stuname, avgmark from tb_student, ( select sid, avg(score) as avgmark from tb_record group by sid ) temp where stuid=sid;<br><br>select stuname, avgmark from tb_student inner join ( select sid, avg(score) as avgmark from tb_record group by sid ) temp on stuid=sid;<br><br>-- 查询每个学生的姓名和选课数量(左外连接和子查询)<br>select stuname, ifnull(total, 0) from tb_student left outer join ( select sid, count(sid) as total from tb_record group by sid ) temp on stuid=sid;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Msql数据库概述&quot;&gt;&lt;a href=&quot;#Msql数据库概述&quot; class=&quot;headerlink&quot; title=&quot;Msql数据库概述&quot;&gt;&lt;/a&gt;Msql数据库概述&lt;/h1&gt;&lt;p&gt;Msql为关系数据库，关系数据库的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理论基础：集合论和关系代数&lt;/li&gt;
&lt;li&gt;具体表象：用二维表（有行和列）组织数据&lt;/li&gt;
&lt;li&gt;编程语言：结构化查询语言（sql）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://www.lhjailj.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://www.lhjailj.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Session&amp;&amp;cookie</title>
    <link href="http://www.lhjailj.top/2020/10/14/2020-10-14Sessioncookie/"/>
    <id>http://www.lhjailj.top/2020/10/14/2020-10-14Sessioncookie/</id>
    <published>2020-10-14T00:31:53.000Z</published>
    <updated>2021-03-14T13:00:02.300Z</updated>
    
    <content type="html"><![CDATA[<p>Session和Cookie产生的原因：</p><p>因为Http的一个显著特征为无状态！无状态意味着它不记录请求它的用户信息，无法区分是否来自同一个用户。</p><a id="more"></a><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。</p><p>session是另一种记录服务器和客户端会话状态的机制。</p><ol><li>用户第一次请求服务器时，服务器端会生成一个sessionid</li><li>服务器端将生成的sessionid返回给客户端，通过set-cookie</li><li>客户端收到sessionid会将它保存在cookie中，当客户端再次访问服务端时会带上这个sessionid</li><li>当服务端再次接收到来自客户端的请求时，会先去检查是否存在sessionid，不存在就新建一个sessionid重复1,2的流程，如果存在就去遍历服务端的session文件，找到与这个sessionid相对应的文件，文件中的键值便是sessionid，值为当前用户的一些信息</li><li>此后的请求都会交换这个 Session ID，进行有状态的会话。</li></ol><h2 id="Session的实现方式"><a href="#Session的实现方式" class="headerlink" title="Session的实现方式"></a>Session的实现方式</h2><p>1、借助Cookie的sessionId发送的方式</p><p>2、通过LocalStorage的方式</p><p>3、URL回写的方式，这是客户端禁止接收Cookie之后的方法。</p><p>4、隐藏表单字段（hidden）</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/HTTP/Overview%23HTTP_is_stateless_but_not_sessionless" target="_blank" rel="noopener">无状态</a>的HTTP协议记录稳定的状态信息成为了可能。</p><p>可以看到上面实现Session的方式第一项就是借助Cookie去携带Sessionid，所以可以说Cookie也是实现Session的一种方式</p><h2 id="Session与Cookie的区别"><a href="#Session与Cookie的区别" class="headerlink" title="Session与Cookie的区别"></a>Session与Cookie的区别</h2><ul><li><strong>安全性：</strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li><li><strong>存取值的类型不同</strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li><li><strong>有效期不同：</strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li><li><strong>存储大小不同：</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Session和Cookie产生的原因：&lt;/p&gt;
&lt;p&gt;因为Http的一个显著特征为无状态！无状态意味着它不记录请求它的用户信息，无法区分是否来自同一个用户。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://www.lhjailj.top/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Cookie" scheme="http://www.lhjailj.top/tags/Cookie/"/>
    
      <category term="session" scheme="http://www.lhjailj.top/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://www.lhjailj.top/2020/08/27/2021-08-27Promise/"/>
    <id>http://www.lhjailj.top/2020/08/27/2021-08-27Promise/</id>
    <published>2020-08-27T06:32:23.000Z</published>
    <updated>2021-04-01T11:46:28.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise 是异步编程的解决方案，比传统的解决方案–回调函数和事件–更合理和强大。</p><h2 id="创建一个Promsie实例"><a href="#创建一个Promsie实例" class="headerlink" title="创建一个Promsie实例"></a>创建一个<code>Promsie</code>实例</h2><p>Promise构造函数接收一个函数<code>exectuor</code>作为参数，这个函数将<code>resolve()</code>、<code>reject()</code>作为入口参数，接下来，他会调用<code>exectuor()</code>，直到退出</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 需用户声明的执行器函数</span><br>executor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;&#125;<br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// some code</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功*/</span>) &#123;<br>    resolve(value)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    reject(value)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="回调异步来处理异步"><a href="#回调异步来处理异步" class="headerlink" title="回调异步来处理异步"></a>回调异步来处理异步</h2><p>在JS中的异步处理，第一时间想到的就是利用回调函数</p><p>通过回调实现x+y运算</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//利用回调函数的异步处理</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">getX, getY, cb</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x, y;<br>  getX(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xVal</span>)</span>&#123;<br>    x = xVal;<br>    <span class="hljs-comment">//去判断是否有值</span><br>    <span class="hljs-keyword">if</span>(y != <span class="hljs-literal">undefined</span>) &#123;<br>      cb(x + y);<br>    &#125;<br>  &#125;);<br>  getY(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">yVal</span>)</span>&#123;<br>    y = yVal;<br>    <span class="hljs-comment">//去判断是否有值</span><br>    <span class="hljs-keyword">if</span>(x != <span class="hljs-literal">undefined</span>) &#123;<br>      cb(x + y);<br>    &#125;<br>  &#125;);<br>&#125;<br>add(fetchX, fetchY, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sum</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(sum)<br>&#125;)<br></code></pre></td></tr></table></figure><a id="more"></a><p>我们将x和y作为未来值，进行了一个运算add()</p><p>回调多了会出现层层嵌套，可读性变差，调试困难</p><p>一旦有所松动就会牵一发而动全身</p><p>当回调函数嵌套过多时</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">doA(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  doB();<br>  doC(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    doD();<br>  &#125;)<br>  doE()<br>&#125;)<br>doF()<br></code></pre></td></tr></table></figure><p>尽管你能够正确的确定实际的运行顺序，但是，这一眼看上去确实比较复杂</p><p>实际的运行顺序</p><ul><li>doA()</li><li>doF()</li><li>doB()</li><li>doC()</li><li>doE()</li><li>doD()</li></ul><p>这还只是简易模式，真正的异步JavaScript程序代码要混乱的多，使这种追踪难度成倍增加</p><p>回调的函数优美度不足，同时缺少信任度</p><p>尽管我们的大脑能够以顺序的方式（这个，然后这个，然后这个）计划一系列任务，但大脑运作的事件化的本质使得控制流的恢复/重试/复制几乎不费什么力气。如果你出外办事的时候发现把购物清单落在了家里，那么这一天并不会因为你没有预知到这一点就成为世界末日了。你的大脑很容易就能针对这个小意外做出计划：回家拿清单，然后立刻返回商店就是了。</p><p>但是，手工硬编码（即使包含了硬编码的出错处理）回调的脆弱本性可就远没有这么优雅了。一旦你指定（也就是预先计划）了所有的可能事件和路径，代码就会变得非常复杂，以至于无法维护和更新。这才是回调地狱的真正问题所在！嵌套和缩进基本上只是转移注意力的枝节而已。</p><p>用Promise实现x+y</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">xPromise, yPromise</span>) </span>&#123;<br>  <span class="hljs-comment">//.all方法接受一个promise数组并返回一个新的promise，这个新的promise等待数组中的所有promise完成</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all([xPromise, yPromise])<br>  <span class="hljs-comment">//promise决议之后，将取得x和y的值并加在一起</span><br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;<br>    <span class="hljs-comment">//value是来自于之前决议的promise的数组,那么value[0]就是第一个promise的结果，value[2]就是第二个promise的结果</span><br>    <span class="hljs-keyword">return</span> values[<span class="hljs-number">0</span>] + value[<span class="hljs-number">1</span>]<br>  &#125;)<br>&#125;<br>add(fetchX(), fetchY())<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sum</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(sum)<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>Promise</code>将类似的异步处理对象和处理规则规范化，并按照统一的接口编写，采取了规定之外的写法会报错</p><p>promise实例有三种状态：</p><ol><li>pending：初始状态，位履行或者拒绝</li><li>fulfilled： 意味着操作成功完成</li><li>rejected： 操作失败</li></ol><p>当promise从pending状态进行决议转为fulfilled或者出现某种异常信息导致转为reject，当其中任一一种情况出现时，Promise对象的then方法绑定的处理方法（handles）就会被调用，<strong><code>then</code>方法有两个函数参数</strong>分别指定成功与失败状态的<code>resolve</code>方法和<code>reject</code>方法的回调函数</p><p>下面这个例子阐述了promise为完成的状态：<code>promise</code>p中定义了一个定时器，当2s过后将8传递给resolve，将promise状态变为完成状态，然后定义定时器在1s后输出promise p的结果，那么1s过后promsie的状态还未确定，所以输出结果为pending，只有当promsie结果变为fulfilled才会输出结果</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> setTimeout(resolve, <span class="hljs-number">2000</span>, <span class="hljs-number">8</span>))<br>setTimeout(<span class="hljs-built_in">console</span>.log, <span class="hljs-number">1000</span>, p)<br></code></pre></td></tr></table></figure><p>例：在最开始我无法理解的就是resolve与reject是成功与失败，但是为什么使用他们，为什么将处理结果传递给了这个两个函数 ，<strong>最后我们要注意文档的两句话，Promise接受一个函数作为参数</strong>，也就是下面new Promise的参数function。<strong>同时这个函数又接收了两个函数作为参数，resolve，reject</strong>,我们调用readFIle方法读取文件，那么返回的结果要么成功返回文件的数据，或是失败返回一个err，那么resolve和reject的作用就来了，我们根据结果的不同来去设置这个promise在何种条件下变为何种状态，<strong>所以resolve的作用是将这个promise的状态变为成功，reject变为失败就可以理解了，如果返回了文件的数据，我们就使用resolve将这个promise的状态变为成功，否则就变为reject</strong></p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>   fs.readFile(<span class="hljs-string">'./hello.md'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">er,data</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span>(err)&#123;<br>        reject(err)<span class="hljs-comment">//如果请求失败状态转为rejected</span><br>      &#125;<br>     resolve(data)<span class="hljs-comment">//如果请求成功状态转为fulfilled</span><br>   &#125;)<br>&#125;)<br><span class="hljs-comment">//promise状态确定时调用then方法,包含两种状态的回调函数</span><br>p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(value.data)<span class="hljs-comment">//第一个函数为成功时的回调</span><br>&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'读取失败'</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用Promise封装ajax请求</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> getJSON = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.readyState !== <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-comment">// 当满足了返回数据请求的时候，我们将promise状态变为成功，那么我们就可以在通过.then方法获取到返回的res</span><br>        resolve(<span class="hljs-keyword">this</span>.response);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-keyword">this</span>.statusText));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    client.open(<span class="hljs-string">"GET"</span>, url);<br>    client.onreadystatechange = handler;<br>    client.responseType = <span class="hljs-string">"json"</span>;<br>    client.setRequestHeader(<span class="hljs-string">"Accept"</span>, <span class="hljs-string">"application/json"</span>);<br>    client.send();<br><br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> promise;<br>&#125;;<br><br>getJSON(<span class="hljs-string">"/posts.json"</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Contents: '</span> + json);<br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'出错了'</span>, error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  resolve(p1);<br>&#125;)<br></code></pre></td></tr></table></figure><p>p1与p2都是Promise的实例，但是p2的resolve方法将作为p1的参数，如果调用的时候p1的状态时pending，那么p2的回调函数就会等待p1的状态的改变，如果p1的状态已经确定那么p2的回调函数就会立刻执行。</p><p><strong>exector()函数中的resolve置值器可以接受任何值，（除了当前promise自身）</strong></p><p><strong><code>Promise</code>机制中并没有延时，也没有被延时的行为，更没有对时间这个纬度的控制，在js中创建一个promise时，创建过程是立即完成的，只不过重要的是这些promise所代理的那个值或者数据还没有就绪。这个就绪过程要推迟到未知的将来才会发生，而一旦数据就绪，promise.then就会触发了</strong></p><h2 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h2><p>Promise可以使用链式操作的原因是因为Promise.prototype.then方法返回的是一个新的Promise对象，因此可以采用链式写法,</p><p>then方法接收两个回调函数作为参数，分别是resolve的结果与reject的结果</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">getJSON(<span class="hljs-string">'1.json'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> json.name<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-comment">//proceed</span><br>&#125;)<br><span class="hljs-comment">// bad code</span><br><span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    reject(<span class="hljs-number">300</span>)<br>  &#125;, <span class="hljs-number">2000</span>)<br>&#125;)<br><br>promise.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(value + <span class="hljs-number">1</span>)<br>&#125;,(e)=&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(e)<br>&#125;)<br><span class="hljs-comment">// good</span><br>promise<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123; <span class="hljs-comment">//cb</span><br>    <span class="hljs-comment">// success</span><br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-comment">// error</span><br>  &#125;);<br></code></pre></td></tr></table></figure><p>上述代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><p>但是一般来说不要在then方法中定义reject的回调函数，最好使用catch方法捕获错误</p><h2 id="promise-portotype-finally"><a href="#promise-portotype-finally" class="headerlink" title="promise.portotype.finally()"></a>promise.portotype.finally()</h2><p><code>finally()</code>方法用于指定不管Promise对象最后状态如何，都会执行的操作。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">server.listen(port)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;)<br>  .finally(server.stop)<br></code></pre></td></tr></table></figure><p>使用promise处理请求，然后finally()关闭服务</p><h2 id="关于async函数"><a href="#关于async函数" class="headerlink" title="关于async函数"></a>关于async函数</h2><p>只要函数名之前加上async关键字，就表明该函数内部有异步操作。该异步操作应该返回一个Promise对象，前面用await关键字注明。当函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStockPrice</span>(<span class="hljs-params">symbol, currency</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> price = <span class="hljs-keyword">await</span> getStockPrice(symbol);<br>    <span class="hljs-keyword">return</span> convert(price, currency);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数将返回一个Promise对象。调用该函数时，当遇到await关键字，立即返回它后面的表达式（getStockPrice函数）产生的Promise对象，不再执行函数体内后面的语句。等到getStockPrice完成，再自动回到函数体内，执行剩下的语句。</p><p>另一个例子</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    setTimeout(resolve, ms);<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncValue</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> timeout(<span class="hljs-number">50</span>);<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，asyncvalue函数前面有async关键字，表明函数体内有异步操作。执行的时候，遇到await语句就会先返回，等到timeout函数执行完毕再喊回value</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h1&gt;&lt;p&gt;Promise 是异步编程的解决方案，比传统的解决方案–回调函数和事件–更合理和强大。&lt;/p&gt;
&lt;h2 id=&quot;创建一个Promsie实例&quot;&gt;&lt;a href=&quot;#创建一个Promsie实例&quot; class=&quot;headerlink&quot; title=&quot;创建一个Promsie实例&quot;&gt;&lt;/a&gt;创建一个&lt;code&gt;Promsie&lt;/code&gt;实例&lt;/h2&gt;&lt;p&gt;Promise构造函数接收一个函数&lt;code&gt;exectuor&lt;/code&gt;作为参数，这个函数将&lt;code&gt;resolve()&lt;/code&gt;、&lt;code&gt;reject()&lt;/code&gt;作为入口参数，接下来，他会调用&lt;code&gt;exectuor()&lt;/code&gt;，直到退出&lt;/p&gt;
&lt;figure class=&quot;hljs highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 需用户声明的执行器函数&lt;/span&gt;&lt;br&gt;executor = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;resolve, reject&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;&lt;br&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; promise = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;resolve, reject&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;br&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;// some code&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-comment&quot;&gt;/* 异步操作成功*/&lt;/span&gt;) &amp;#123;&lt;br&gt;    resolve(value)&lt;br&gt;  &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;br&gt;    reject(value)&lt;br&gt;  &amp;#125;&lt;br&gt;&amp;#125;)&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;回调异步来处理异步&quot;&gt;&lt;a href=&quot;#回调异步来处理异步&quot; class=&quot;headerlink&quot; title=&quot;回调异步来处理异步&quot;&gt;&lt;/a&gt;回调异步来处理异步&lt;/h2&gt;&lt;p&gt;在JS中的异步处理，第一时间想到的就是利用回调函数&lt;/p&gt;
&lt;p&gt;通过回调实现x+y运算&lt;/p&gt;
&lt;figure class=&quot;hljs highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//利用回调函数的异步处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;getX, getY, cb&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;br&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; x, y;&lt;br&gt;  getX(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;xVal&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;br&gt;    x = xVal;&lt;br&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;//去判断是否有值&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(y != &lt;span class=&quot;hljs-literal&quot;&gt;undefined&lt;/span&gt;) &amp;#123;&lt;br&gt;      cb(x + y);&lt;br&gt;    &amp;#125;&lt;br&gt;  &amp;#125;);&lt;br&gt;  getY(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;yVal&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;br&gt;    y = yVal;&lt;br&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;//去判断是否有值&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(x != &lt;span class=&quot;hljs-literal&quot;&gt;undefined&lt;/span&gt;) &amp;#123;&lt;br&gt;      cb(x + y);&lt;br&gt;    &amp;#125;&lt;br&gt;  &amp;#125;);&lt;br&gt;&amp;#125;&lt;br&gt;add(fetchX, fetchY, &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;sum&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;br&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(sum)&lt;br&gt;&amp;#125;)&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
      <category term="对象" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="ES6" scheme="http://www.lhjailj.top/tags/ES6/"/>
    
      <category term="Promise" scheme="http://www.lhjailj.top/tags/Promise/"/>
    
      <category term="异步" scheme="http://www.lhjailj.top/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>迭代器Iterator</title>
    <link href="http://www.lhjailj.top/2020/08/26/2020-08-26-%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator/"/>
    <id>http://www.lhjailj.top/2020/08/26/2020-08-26-%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator/</id>
    <published>2020-08-25T22:34:10.000Z</published>
    <updated>2021-03-10T10:05:30.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署Iterator接口，就可以完成遍历操作。</p><p>1、ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of循环使用</p><p>2、原生具备Iterator接口的数据可使用for of遍历</p><a id="more"></a><p>生成一个数组使用for…of遍历</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>       <span class="hljs-keyword">const</span> Arr = [<span class="hljs-string">'唐僧'</span>, <span class="hljs-string">'猪八戒'</span>, <span class="hljs-string">'孙悟空'</span>, <span class="hljs-string">'沙僧'</span>]<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> Arr) &#123;<br>           <span class="hljs-built_in">console</span>.log(i)<span class="hljs-comment">//唐僧 猪八戒 孙悟空 沙僧</span><br>       &#125;<br>   &lt;<span class="hljs-regexp">/script&gt;</span><br></code></pre></td></tr></table></figure><p>生成一个数组使用for…in遍历</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Arr = [<span class="hljs-string">'唐僧'</span>, <span class="hljs-string">'猪八戒'</span>, <span class="hljs-string">'孙悟空'</span>, <span class="hljs-string">'沙僧'</span>]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> Arr) &#123;<br>            <span class="hljs-built_in">console</span>.log(i)<br>        &#125;<br></code></pre></td></tr></table></figure><p><strong>for in循环保存的是键名，而for of保存的是键值</strong></p><h2 id="谁可以使用"><a href="#谁可以使用" class="headerlink" title="谁可以使用"></a>谁可以使用</h2><p>可以看到在该数组的方法中有一个<code>Symbol(Symbol.iterator)</code>方法</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> iterator = Arr[<span class="hljs-built_in">Symbol</span>.iterator]()<br>        <span class="hljs-built_in">console</span>.log(iterator)<br></code></pre></td></tr></table></figure>{% asset_img 4.png %}<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol><li>创建一个指针对象，指向当前数据结构的起始位置</li><li>第一次调用对象<code>next</code>方法，指针自动指向数据结构的第一个成员</li><li>接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员</li><li>每调用next方法返回一个包含value和done属性的对象</li></ol><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Arr = [<span class="hljs-string">'唐僧'</span>, <span class="hljs-string">'猪八戒'</span>, <span class="hljs-string">'孙悟空'</span>, <span class="hljs-string">'沙僧'</span>]<br>        <span class="hljs-keyword">let</span> iterator = Arr[<span class="hljs-built_in">Symbol</span>.iterator]()<br>        <span class="hljs-built_in">console</span>.log(iterator.next())<br>        <span class="hljs-built_in">console</span>.log(iterator.next())<br>        <span class="hljs-built_in">console</span>.log(iterator.next())<br>        <span class="hljs-built_in">console</span>.log(iterator.next())<br>        <span class="hljs-built_in">console</span>.log(iterator.next())<br></code></pre></td></tr></table></figure><p>当<code>done</code>为true时，表示循环已经完成</p><h2 id="自定义遍历数据"><a href="#自定义遍历数据" class="headerlink" title="自定义遍历数据"></a>自定义遍历数据</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> banji = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">"终极一班"</span>,<br>        <span class="hljs-attr">stus</span>: [<br>            <span class="hljs-string">'xiaoming'</span>,<br>            <span class="hljs-string">'xiaobai'</span>,<br>            <span class="hljs-string">'xiaohei'</span>,<br>            <span class="hljs-string">'xiaoli'</span>,<br>            <span class="hljs-string">'xiaoning'</span><br>        ],<br>        [<span class="hljs-built_in">Symbol</span>.iterator]()&#123;<br>            <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>                    <span class="hljs-keyword">if</span>(index&lt; <span class="hljs-keyword">this</span>.stus.length)&#123;<br>                        <span class="hljs-keyword">const</span> result = &#123;<span class="hljs-attr">value</span>: <span class="hljs-keyword">this</span>.stus[index], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br>                        index++<br>                        <span class="hljs-keyword">return</span> result<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;<br>                    &#125;<br>                    <br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> banji) &#123;<br>        <span class="hljs-built_in">console</span>.log(v)<br>    &#125;<br><span class="hljs-comment">//其中的if判断可以优化</span><br><span class="hljs-comment">//优化</span><br>       index &lt; <span class="hljs-keyword">this</span>.stus.length ? <br>       &#123;<span class="hljs-attr">value</span>: <span class="hljs-keyword">this</span>.stus[index++], <span class="hljs-attr">done</span>:<span class="hljs-literal">false</span>&#125; : <br>       &#123;<span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;<br><span class="hljs-comment">//再优化</span><br><span class="hljs-keyword">let</span> _this = <span class="hljs-keyword">this</span><br><span class="hljs-keyword">return</span> index &lt; _this.stus.length ?<br>&#123;<span class="hljs-attr">value</span>: _this.stus[index++]&#125; :<br>&#123;<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h1&gt;&lt;p&gt;迭代器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署Iterator接口，就可以完成遍历操作。&lt;/p&gt;
&lt;p&gt;1、ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of循环使用&lt;/p&gt;
&lt;p&gt;2、原生具备Iterator接口的数据可使用for of遍历&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
      <category term="对象" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="控制抽象对象" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/%E5%AF%B9%E8%B1%A1/%E6%8E%A7%E5%88%B6%E6%8A%BD%E8%B1%A1%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="javascript" scheme="http://www.lhjailj.top/tags/javascript/"/>
    
      <category term="ES6" scheme="http://www.lhjailj.top/tags/ES6/"/>
    
      <category term="迭代器" scheme="http://www.lhjailj.top/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="http://www.lhjailj.top/2020/08/20/2020-8-20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://www.lhjailj.top/2020/08/20/2020-8-20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-08-20T13:28:09.000Z</published>
    <updated>2021-03-14T12:59:52.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>提到深拷贝与浅拷贝就要探讨js中的数据类型，基本类型例如，<code>Number</code>,<code>String</code>等，他们的值是不可变的，动态的修改了基本数据类型的值它的原始值也是不会改变的</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">"abc"</span><br><span class="hljs-built_in">console</span>.log(st[<span class="hljs-number">1</span>]=<span class="hljs-string">"d"</span>)<br><span class="hljs-built_in">console</span>.log(s)<span class="hljs-comment">//abc</span><br></code></pre></td></tr></table></figure><a id="more"></a><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型是存放在堆内存中的，变量实际上存放着一个放在栈内存的指针，引用类型可以直接改变它的值</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝是将原对象或数组的引用直接赋给新对象，新数组它们只是原对象的一个引用</p><p>首先我们通过赋值复制一个数组</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = &#123;<br>       <span class="hljs-string">'name'</span> : <span class="hljs-string">'zhangsan'</span>,<br>       <span class="hljs-string">'age'</span> :  <span class="hljs-string">'18'</span>,<br>       <span class="hljs-string">'language'</span> : [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]],<br>   &#125;;<br><br>   <span class="hljs-keyword">var</span> obj2 = obj1;<br><br><br>   <span class="hljs-keyword">var</span> obj3 = shallowCopy(obj1);<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowCopy</span>(<span class="hljs-params">src</span>) </span>&#123;<br>       <span class="hljs-keyword">var</span> dst = &#123;&#125;;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> src) &#123;<br>           <span class="hljs-keyword">if</span> (src.hasOwnProperty(prop)) &#123;<br>               dst[prop] = src[prop];<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dst;<br>   &#125;<br><br>   obj2.name = <span class="hljs-string">"lisi"</span>;<br>   obj3.age = <span class="hljs-string">"20"</span>;<br><br>   obj2.language[<span class="hljs-number">1</span>] = [<span class="hljs-string">"二"</span>,<span class="hljs-string">"三"</span>];<br>   obj3.language[<span class="hljs-number">2</span>] = [<span class="hljs-string">"四"</span>,<span class="hljs-string">"五"</span>];<br><br>   <span class="hljs-built_in">console</span>.log(obj1);  <br>   <span class="hljs-comment">//obj1 = &#123;</span><br>   <span class="hljs-comment">//    'name' : 'lisi',</span><br>   <span class="hljs-comment">//    'age' :  '18',</span><br>   <span class="hljs-comment">//    'language' : [1,["二","三"],["四","五"]],</span><br>   <span class="hljs-comment">//&#125;;</span><br><br>   <span class="hljs-built_in">console</span>.log(obj2);<br>   <span class="hljs-comment">//obj2 = &#123;</span><br>   <span class="hljs-comment">//    'name' : 'lisi',</span><br>   <span class="hljs-comment">//    'age' :  '18',</span><br>   <span class="hljs-comment">//    'language' : [1,["二","三"],["四","五"]],</span><br>   <span class="hljs-comment">//&#125;;</span><br><br>   <span class="hljs-built_in">console</span>.log(obj3);<br>   <span class="hljs-comment">//obj3 = &#123;</span><br>   <span class="hljs-comment">//    'name' : 'zhangsan',</span><br>   <span class="hljs-comment">//    'age' :  '20',</span><br>   <span class="hljs-comment">//    'language' : [1,["二","三"],["四","五"]],</span><br>   <span class="hljs-comment">//&#125;;</span><br></code></pre></td></tr></table></figure><p>如果属性是基本数据类型，拷贝的就是基本类型的值，如果属性是引用类型拷贝的就是内存地址，所以如果其中一个对像改变了，这个引用类型的属性或者说是地就会影响到另一个对像。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>创建一个新的对像和数组，将原对象的各个属性的值（数组的所有元素）拷贝过来，<strong>是值而不是引用</strong></p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> array = [<br>    &#123; <span class="hljs-attr">number</span>: <span class="hljs-number">1</span> &#125;,<br>    &#123; <span class="hljs-attr">number</span>: <span class="hljs-number">2</span> &#125;,<br>    &#123; <span class="hljs-attr">number</span>: <span class="hljs-number">3</span> &#125;<br>];<br><span class="hljs-keyword">var</span> copyArray = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(array))<br>copyArray[<span class="hljs-number">0</span>].number = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">console</span>.log(array); <span class="hljs-comment">//  [&#123;number: 1&#125;, &#123; number: 2 &#125;, &#123; number: 3 &#125;]</span><br><span class="hljs-built_in">console</span>.log(copyArray); <span class="hljs-comment">// [&#123;number: 100&#125;, &#123; number: 2 &#125;, &#123; number: 3 &#125;]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深拷贝与浅拷贝&quot;&gt;&lt;a href=&quot;#深拷贝与浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;深拷贝与浅拷贝&quot;&gt;&lt;/a&gt;深拷贝与浅拷贝&lt;/h1&gt;&lt;h2 id=&quot;基本类型&quot;&gt;&lt;a href=&quot;#基本类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型&quot;&gt;&lt;/a&gt;基本类型&lt;/h2&gt;&lt;p&gt;提到深拷贝与浅拷贝就要探讨js中的数据类型，基本类型例如，&lt;code&gt;Number&lt;/code&gt;,&lt;code&gt;String&lt;/code&gt;等，他们的值是不可变的，动态的修改了基本数据类型的值它的原始值也是不会改变的&lt;/p&gt;
&lt;figure class=&quot;hljs highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; s = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(st[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]=&lt;span class=&quot;hljs-string&quot;&gt;&quot;d&quot;&lt;/span&gt;)&lt;br&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(s)&lt;span class=&quot;hljs-comment&quot;&gt;//abc&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
      <category term="对象" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="javascript" scheme="http://www.lhjailj.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Date函数</title>
    <link href="http://www.lhjailj.top/2020/08/17/2020-8-17-Date%E5%87%BD%E6%95%B0/"/>
    <id>http://www.lhjailj.top/2020/08/17/2020-8-17-Date%E5%87%BD%E6%95%B0/</id>
    <published>2020-08-17T09:40:18.000Z</published>
    <updated>2021-03-10T09:37:56.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS日期"><a href="#JS日期" class="headerlink" title="JS日期"></a>JS日期</h1><h2 id="关于创建时间对象"><a href="#关于创建时间对象" class="headerlink" title="关于创建时间对象"></a>关于创建时间对象</h2><h3 id="创建日期对象的四种方法"><a href="#创建日期对象的四种方法" class="headerlink" title="创建日期对象的四种方法"></a>创建日期对象的四种方法</h3><p><code>new Date()</code></p><p><code>new Date(year, month,day, hours, minutes, seconds, milliseconds)</code></p><p><code>new Date(milliseconds)</code></p><p><code>new Date(date string)</code></p><p>1、不传参数创建日期</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-comment">//Mon Aug 17 2020 17:47:35 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure><p>2、加入年月日等参数</p><a id="more"></a><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2020</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>);<span class="hljs-comment">//Fri Dec 11 2020 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="hljs-comment">//为日期指定内容</span><br></code></pre></td></tr></table></figure><p>注：<strong>对于月份来说一月的索引为0，12月为11</strong></p><p>所以我们在获取月份时也要注意+1才是正确的我们所说的月份</p><p>3、如果只传入一个参数，则按照毫秒为参数添加进函数,将返回一个按照零时加上毫秒数的新的日期对象</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>JavaScript 将日期存储为自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。</p><p>零时间是 1970 年 1 月 1 日 00:00:00 UTC。</p><p>4、传入时间字符串会返回一个新的日期对象</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"October 13, 2014 11:13:00"</span>);<br></code></pre></td></tr></table></figure><h3 id="日期的获取方法"><a href="#日期的获取方法" class="headerlink" title="日期的获取方法"></a>日期的获取方法</h3><h3 id="关于-new-Date"><a href="#关于-new-Date" class="headerlink" title="关于+new Date()"></a>关于+new Date()</h3><p>这个操作是将日期函数转换类型</p><p>以毫秒显示</p><p>对时间进行格式化,后端提供以秒为单位的时间数据</p><p>将其转换为00:00:00（小时：分钟：秒），并且位数为一位数时，进行补0，避免出现3:20这样的时间应该显示为03:20。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">formateTime(seconds) &#123;<br>      <span class="hljs-keyword">if</span> (seconds &lt; <span class="hljs-number">60</span>) &#123;<br>        <span class="hljs-keyword">return</span> seconds.toString().padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (seconds &lt; <span class="hljs-number">3600</span>) &#123;<br>        <span class="hljs-keyword">const</span> m = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>(seconds / <span class="hljs-number">60</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>        <span class="hljs-keyword">const</span> s = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>(seconds % <span class="hljs-number">60</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;m&#125;</span>:<span class="hljs-subst">$&#123;s&#125;</span>`</span><br>      &#125;<br>      <span class="hljs-keyword">const</span> h = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>(seconds / <span class="hljs-number">3600</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>      <span class="hljs-keyword">const</span> m = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>((seconds % <span class="hljs-number">3600</span>) / <span class="hljs-number">60</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>      <span class="hljs-keyword">const</span> s = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>((seconds % <span class="hljs-number">3600</span>) % <span class="hljs-number">60</span>)).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">'0'</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;h&#125;</span>:<span class="hljs-subst">$&#123;m&#125;</span>:<span class="hljs-subst">$&#123;s&#125;</span>`</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="时间戳转换"><a href="#时间戳转换" class="headerlink" title="时间戳转换"></a>时间戳转换</h3><p>new Date(1598338225474)，如果是秒为单位需要乘1000</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS日期&quot;&gt;&lt;a href=&quot;#JS日期&quot; class=&quot;headerlink&quot; title=&quot;JS日期&quot;&gt;&lt;/a&gt;JS日期&lt;/h1&gt;&lt;h2 id=&quot;关于创建时间对象&quot;&gt;&lt;a href=&quot;#关于创建时间对象&quot; class=&quot;headerlink&quot; title=&quot;关于创建时间对象&quot;&gt;&lt;/a&gt;关于创建时间对象&lt;/h2&gt;&lt;h3 id=&quot;创建日期对象的四种方法&quot;&gt;&lt;a href=&quot;#创建日期对象的四种方法&quot; class=&quot;headerlink&quot; title=&quot;创建日期对象的四种方法&quot;&gt;&lt;/a&gt;创建日期对象的四种方法&lt;/h3&gt;&lt;p&gt;&lt;code&gt;new Date()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new Date(year, month,day, hours, minutes, seconds, milliseconds)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new Date(milliseconds)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new Date(date string)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1、不传参数创建日期&lt;/p&gt;
&lt;figure class=&quot;hljs highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; d = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;();&lt;span class=&quot;hljs-comment&quot;&gt;//Mon Aug 17 2020 17:47:35 GMT+0800 (中国标准时间)&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;2、加入年月日等参数&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JS" scheme="http://www.lhjailj.top/tags/JS/"/>
    
      <category term="Date对象" scheme="http://www.lhjailj.top/tags/Date%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>记this的指向</title>
    <link href="http://www.lhjailj.top/2020/08/01/2020-08-01%E8%AE%B0this%E7%9A%84%E6%8C%87%E5%90%91/"/>
    <id>http://www.lhjailj.top/2020/08/01/2020-08-01%E8%AE%B0this%E7%9A%84%E6%8C%87%E5%90%91/</id>
    <published>2020-08-01T13:27:39.000Z</published>
    <updated>2021-03-10T09:38:20.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p>this的指向在函数的定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，所以this的最终指向的是调用它的对象（理论上）</p><p>第一个例子</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">app</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> user = <span class="hljs-string">"bpp"</span>; <br>    <span class="hljs-built_in">console</span>.log(user);<span class="hljs-comment">//undefined</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//window</span><br>&#125;<br>app()在全局作用域<span class="hljs-built_in">window</span>中调用app()<br></code></pre></td></tr></table></figure><p>此时this最终指向的是调用它的对象window，相当于<code>window.app()</code></p><a id="more"></a><p>第二个例子</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> temp = &#123;<br>    <span class="hljs-attr">user</span>: <span class="hljs-string">'name'</span>,<br>    <span class="hljs-attr">fn</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.user);<span class="hljs-comment">//name</span><br>    &#125;<br>&#125;<br>temp.fn()<br></code></pre></td></tr></table></figure><p>此时因为是对象temp调用了fn，所以this指向它的调用者temp</p><p>例子三证明了我们的this指向它的调用者是一个理论上的说法</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> temp = &#123;<br>    <span class="hljs-attr">user</span>: <span class="hljs-string">'name'</span>,<br>    <span class="hljs-attr">fn</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.user);<span class="hljs-comment">//name</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">window</span>.temp.fn()<br></code></pre></td></tr></table></figure><p><strong>通过window调用发现this没有指向window</strong></p><p>例子四</p><figure class="hljs highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">var <span class="hljs-keyword">temp</span> = &#123;<br><span class="hljs-keyword">user</span>:<span class="hljs-string">'yy'</span><br>temp2：&#123;<br> <span class="hljs-keyword">user</span>: <span class="hljs-string">'name'</span>,<br>    fn:<span class="hljs-keyword">function</span>()&#123;<br>        console.log(this.<span class="hljs-keyword">user</span>);//<span class="hljs-type">name</span><br>  &#125;<br> &#125;  <br>&#125;<br><span class="hljs-keyword">temp</span>.temp2.fn()<br></code></pre></td></tr></table></figure><p>这里的temp2是通过temp点出来的，this同样没有指向它说明</p><ol><li>如果一个函数中有this没有通过上一级对象调用，那么它指向window</li><li>如果有上一级对象调用，那么this指向它的上一级对象</li><li>如果这个函数被多个对象嵌套，那么尽管这个函数被最外层的对象调用，this也指向它的上一级对象。</li></ol><p><strong>特殊情况</strong></p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> temp1 = &#123;<br>    <span class="hljs-attr">b</span>:&#123;<br>        a = <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">fn</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a);<span class="hljs-comment">//undefined</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//window</span><br>  &#125;<br>   &#125;<br>  <br>&#125;<br><span class="hljs-keyword">var</span> j = temp1.b.fn;<br>j()<br></code></pre></td></tr></table></figure><p>此时的this没有指向最后调用它的b，因为在fn赋值给变量j的时候函数并没有运行，最终指向的是window</p><p>构造函数的this</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">this</span>.user= <span class="hljs-string">"aaa"</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.log(a.user);<span class="hljs-comment">//aaa</span><br></code></pre></td></tr></table></figure><p>这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a，为什么我说a是对象，因为用了new关键字就是创建一个对象实例，理解这句话可以想想我们的例子3，我们这里用变量a创建了一个Fn的实例（相当于复制了一份Fn到对象a里面），此时仅仅只是创建，并没有执行，而调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象a中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。</p><p>　　除了上面的这些以外，我们还可以自行改变this的指向，关于自行改变this的指向请看<a href="http://www.cnblogs.com/pssp/p/5215621.html" target="_blank" rel="noopener">JavaScript中call,apply,bind方法的总结</a>这篇文章，详细的说明了我们如何手动更改this的指向。</p><p>当this碰到return时</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">this</span>.uer=<span class="hljs-string">"aaa"</span>;<br>    <span class="hljs-keyword">return</span> &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.log(a.user); <span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)  <br></span>&#123;  <br>    <span class="hljs-keyword">this</span>.user = <span class="hljs-string">'aaaa'</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn;  <br><span class="hljs-built_in">console</span>.log(a.user); <span class="hljs-comment">//aaaa</span><br></code></pre></td></tr></table></figure><p><strong>如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</strong></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在严格模式中默认的this不再时window，而是undefined</p><p>new操作符会改变this的指向问题</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">this</span>.user= <span class="hljs-string">"aaa"</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.log(a.user);<span class="hljs-comment">//aaa</span><br></code></pre></td></tr></table></figure><p>为什么this会指向a？首先new关键字会创建一个空的对象，然后会自动调用一个函数（比如apply）方法，将this指向这个空对象，这样的化函数内部的this就会被这个空的对象替代</p><h2 id="Vue中的this"><a href="#Vue中的this" class="headerlink" title="Vue中的this"></a>Vue中的this</h2><p>我们可以看到在vue的组件中，我们调用了某个ui组件，使用的使用都会用到this，并且在获取数据的时候也会用到this</p><p>获取用户列表数据</p><p>使用elementui框架的弹框组件</p><p>Vue中的this指向当前组件的实例</p><p>使用箭头函数没有自己的this，所以指向组件当前的实例</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this的指向&quot;&gt;&lt;a href=&quot;#this的指向&quot; class=&quot;headerlink&quot; title=&quot;this的指向&quot;&gt;&lt;/a&gt;this的指向&lt;/h2&gt;&lt;p&gt;this的指向在函数的定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，所以this的最终指向的是调用它的对象（理论上）&lt;/p&gt;
&lt;p&gt;第一个例子&lt;/p&gt;
&lt;figure class=&quot;hljs highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;app&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; user = &lt;span class=&quot;hljs-string&quot;&gt;&quot;bpp&quot;&lt;/span&gt;; &lt;br&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(user);&lt;span class=&quot;hljs-comment&quot;&gt;//undefined&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;);&lt;span class=&quot;hljs-comment&quot;&gt;//window&lt;/span&gt;&lt;br&gt;&amp;#125;&lt;br&gt;app()在全局作用域&lt;span class=&quot;hljs-built_in&quot;&gt;window&lt;/span&gt;中调用app()&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;此时this最终指向的是调用它的对象window，相当于&lt;code&gt;window.app()&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JS" scheme="http://www.lhjailj.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>7-31记</title>
    <link href="http://www.lhjailj.top/2020/07/31/7-31%E8%AE%B0/"/>
    <id>http://www.lhjailj.top/2020/07/31/7-31%E8%AE%B0/</id>
    <published>2020-07-31T15:44:22.000Z</published>
    <updated>2021-03-10T09:40:27.738Z</updated>
    
    <content type="html"><![CDATA[<p>模板字符串</p><p>数据库中返回的是纯数字模式的时间，例如下午四点，数据库中存储的为16，下午六点，数据库中储存的为18，</p><p>要求是我们需要将16展示为16：00-16：59的时间段</p><p>在elementUi的表格中</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"姓名"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"180"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">"&#123;row&#125;"</span>&gt;</span>&#123;&#123; `$(row.hour):00 - $(row.hour):59` &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span><br></code></pre></td></tr></table></figure><a id="more"></a><ol><li><p>解构赋值</p><p>对象的解构赋值</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123;foo, bar&#125; = &#123;<span class="hljs-attr">foo</span>: <span class="hljs-string">'aaa'</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">'bbb'</span>&#125;<br>foo <span class="hljs-comment">// 'aaa'</span><br>bar <span class="hljs-comment">// 'bbb'</span><br></code></pre></td></tr></table></figure><p>对像的属性没有次序，变量必须与属性同名，才能正确的值</p><ol start="3"><li>JSON.stringify({x:5,y:6}) //{‘x’:’5’,”y”,’6’}</li><li>JSON.parse(json)//解析json转为js值或对象</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模板字符串&lt;/p&gt;
&lt;p&gt;数据库中返回的是纯数字模式的时间，例如下午四点，数据库中存储的为16，下午六点，数据库中储存的为18，&lt;/p&gt;
&lt;p&gt;要求是我们需要将16展示为16：00-16：59的时间段&lt;/p&gt;
&lt;p&gt;在elementUi的表格中&lt;/p&gt;
&lt;figure class=&quot;hljs highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs html&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;el-table-column&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;label&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;姓名&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;width&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;180&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;slot-scope&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;#123;row&amp;#125;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;&amp;#123; `$(row.hour):00 - $(row.hour):59` &amp;#125;&amp;#125;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;el-table-column&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://www.lhjailj.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="http://www.lhjailj.top/tags/JS/"/>
    
      <category term="组件库" scheme="http://www.lhjailj.top/tags/%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    
  </entry>
  
</feed>
